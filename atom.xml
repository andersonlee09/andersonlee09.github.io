<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anderson&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-16T15:20:11.481Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Anderson Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于radius的认证过程分析</title>
    <link href="http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2022-03-16T12:11:57.000Z</published>
    <updated>2022-03-16T15:20:11.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预讲"><a href="#预讲" class="headerlink" title="预讲"></a>预讲</h2><p>在了解认证过程之前先了解一些基础的东西</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201426576.png" class><p>如图radius服务有三个部分</p><ul><li>Users：用于存储用户信息（如用户名、密码以及使用的协议、IP地址等配置信息）。</li><li>Clients：用于存储RADIUS客户端的信息（如共享密钥、IP地址等）。</li><li>Dictionary：用于存储RADIUS协议中的属性和属性值含义的信息。</li></ul><p>认证过程如图：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201529044.png" class><ol><li>当用户接入网络时，用户发起连接请求，向RADIUS客户端（即设备）发送用户名和密码。</li><li>RADIUS客户端向RADIUS服务器发送包含用户名和密码信息的认证请求报文。</li><li>RADIUS服务器对用户身份的合法性进行检验：<ul><li>如果用户身份合法，RADIUS服务器向RADIUS客户端返回认证接受报文，允许用户进行下一步动作。由于RADIUS协议合并了认证和授权的过程，因此认证接受报文中也包含了用户的授权信息。</li><li>如果用户身份不合法，RADIUS服务器向RADIUS客户端返回认证拒绝报文，拒绝用户访问接入网络。</li></ul></li><li>RADIUS客户端通知用户认证是否成功。</li><li>RADIUS客户端根据接收到的认证结果接入&#x2F;拒绝用户。如果允许用户接入，则RADIUS客户端向RADIUS服务器发送计费开始请求报文。</li><li>RADIUS服务器返回计费开始响应报文，并开始计费。</li><li>用户开始访问网络资源。</li><li>（可选）在使能实时计费功能的情况下，RADIUS客户端会定时向RADIUS服务器发送实时计费请求报文，以避免因付费用户异常下线导致的不合理计费。</li><li>（可选）RADIUS服务器返回实时计费响应报文，并实时计费。</li><li>用户发起下线请求，请求停止访问网络资源。</li><li>RADIUS客户端向RADIUS服务器提交计费结束请求报文。</li><li>RADIUS服务器返回计费结束响应报文，并停止计费。</li><li>RADIUS客户端通知用户访问结束，用户结束访问网络资源。</li></ol><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>下面开始分析过程:</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201718841.png" class><p>上的抓包time 为相对时间，source 为源IP，destination 为目的IP protocol为数据包所对应的协议类型，info为包的大概行为 </p><p>如图为分析过程，下面需要先去定位三个东西：users-&gt;IP &#x2F; radius server-&gt;IP &#x2F; radius clients-&gt;IP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204705680.png" class><p>首先看第60个包这是一个access-reqest, 应该是用户请求上网数据包，我们先来看看包内容</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204837737.png" class><p>里面包括用户名、密码等内容，大概可以确定userIP—61.174.80.81,client—-172.21.5.2，server—-172.30.5.255</p><p>ip.addr &#x3D;&#x3D; 61.174.80.81 </p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230353885.png" class><p>对IP过滤以后发现这个用户的请求被拒绝过，<strong>拒绝的具体过程应该在No.60~329</strong>之间</p><p>接下来继续过滤</p><p>(ip.dst &#x3D;&#x3D; 172.21.5.2 &amp;&amp; ip.src &#x3D;&#x3D; 172.30.5.225) || (ip.dst &#x3D;&#x3D; 172.30.5.225 &amp;&amp; ip.src &#x3D;&#x3D; 172.21.5.2)</p><p>我把包限制为只能在client和server之间传输</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230522064.png" class><p>接下来继续看，刚才的那个用户61.174.80.81</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316214832327.png" class><p>可以看到他和client除了access类型还有accounting-request类型，accounting这应该是计费数据包，其中每个包都会有回复</p><p>接下来对流进行追踪</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231040036.png" class><p>我不知道为什么这个用户的验证会如此频繁，按道理只有登录请求一次就可以了，但是这个access-request却异常多，可能是在用户上网过程中，这个还在不断验证</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316222552133.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231505350.png" class><p>除了 access-request还有account-request，这应该是计费请求，计费请求通常回复非常快，中间很少插有其他用户的包。</p><p>接下来对于包的内容进行分析</p><h2 id="包分析"><a href="#包分析" class="headerlink" title="包分析"></a>包分析</h2><p>一下均为让radius数据包，因为ICMP或TCP包数量极少且我在上一篇文章就有讲解过</p><h3 id="access-request"><a href="#access-request" class="headerlink" title="access-request"></a>access-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215313010.png" class><p>请求的内容还是比较多的，有用户名、CHAP(挑战握手协议)密码.NAS(<strong>网络附属存储</strong>)</p><p>端口、IP。服务类型。我觉得最重要的应该是acct-session-Id。用户session已经被存储在服务端了。</p><h3 id="access-reject"><a href="#access-reject" class="headerlink" title="access-reject"></a>access-reject</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215749901.png" class><p>应该是拒绝策略</p><p>包括用户名、发送的类型，6应该表示拒绝，回复信息、身份信息验证信息</p><h3 id="access-accept"><a href="#access-accept" class="headerlink" title="access-accept"></a>access-accept</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220117502.png" class><p>可以看到一旦认证成功返回的信息还是比较多的。</p><p>返回信息包括用户名，服务类型（应该是校园网套餐类型），成帧协议，session过期时间，用户临时间隔下面还有一些设备型号，应该是设备供应商</p><h3 id="accounting-request"><a href="#accounting-request" class="headerlink" title="accounting-request"></a>accounting-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220936712.png" class><p>可以看到内容还是比较多的，就讲讲Acct开头的吧，主要就是一些用户状态，延迟时间、输出输出八进制数、session id、session有效时间端口等待，和上面还是比较相似的。</p><h3 id="accounting-response"><a href="#accounting-response" class="headerlink" title="accounting-response"></a>accounting-response</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316223042147.png" class><p>这个回复的数据包信息还是比较少的，只有用户session-id和代理状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;预讲&quot;&gt;&lt;a href=&quot;#预讲&quot; class=&quot;headerlink&quot; title=&quot;预讲&quot;&gt;&lt;/a&gt;预讲&lt;/h2&gt;&lt;p&gt;在了解认证过程之前先了解一些基础的东西&lt;/p&gt;
&lt;img src=&quot;/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark抓包分析</title>
    <link href="http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</id>
    <published>2022-03-16T08:55:52.000Z</published>
    <updated>2022-03-16T15:19:34.851Z</updated>
    
    <content type="html"><![CDATA[<p>下面我将对不同种类的包进行讲解</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>我们知道，arp协议工作于数据链路层，是为了完成IP地址与mac地址的转化，即根据IP地址来找到mac地址</p><p>可以看到我筛选了arp种类的包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316164021419.png" class><p>Source为发送源，Info为具体的这个包功能的介绍，翻译为：谁有xxxip,我是xxxIP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170122119.png" class><p>这是包的具体内容，我们依次展开进行讲解</p><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170208880.png" class><h3 id="Linux-cooked"><a href="#Linux-cooked" class="headerlink" title="Linux cooked"></a>Linux cooked</h3><p>这里记载了包的发送或接收时间、包的id号、种类等等</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170504076.png" class><p>这里记载了包的源地址的网络类型（address type），这里是指以太网、源地址长度(adress length)、源（source）</p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316171056031.png" class><p>hardware type : 网络类型，这里指以太网</p><p>protocol type : 表示arp包所映射地址的协议类型，这里是IP v4</p><p>opcode：包的类型，这是一个请求报文</p><p>send mac Adress: 发送方的mac地址，</p><p>send ip Adress: 发送方IP</p><p>target mac Adress: 接收方mac地址，这里还不知道，所以全部为0</p><p>target IP adress: 接收方IP地址</p><p>下面我们找一个回复报文的例子</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172158040.png" class><p>可以看到，其实基本一致，就是内容略有不同</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP工作于网络层，它负责传递一些错误消息的报文和一些需要传递的东西，比如说：哥们儿，包丢了xxx。我们常见的ping命令。就是icmp报文。</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172534725.png" class><p>接下来我们筛选一批ICMP包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173129471.png" class><h4 id="Internet-Portocol"><a href="#Internet-Portocol" class="headerlink" title="Internet Portocol"></a>Internet Portocol</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173509875.png" class><p>这里和arp基本相似，就是一些源IP，目的IP之类的。</p><h3 id="Internet-Control"><a href="#Internet-Control" class="headerlink" title="Internet Control"></a>Internet Control</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173804613.png" class><p>这里就是一些校验码之类的</p><h4 id="User-Datagram"><a href="#User-Datagram" class="headerlink" title="User Datagram"></a>User Datagram</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174024218.png" class><p>这里是源端口与目的端口</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173924969.png" class><p>这里就是十六进制信息</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS是域名解析协议，就是把具体的url转化为IP，接下来我们抓包试试看</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174642420.png" class><p>可以看到，这里有很多包，info里有详细的内容，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175152003.png" class><p>可以看到UDP的端口默认53，打到DNS服务器51132端口</p><h3 id="Domain-Name"><a href="#Domain-Name" class="headerlink" title="Domain Name"></a>Domain Name</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175935998.png" class><p>这里的Question是问题是指问题数目，有时候会访问多个IP</p><p>RRS: 回答数</p><p>authority RRS： 授权记录 </p><p>ADDITIONAL RRS: 附加记录</p><p>下面我们看看query和answears</p><p>这个分别是查询和回复报文</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180135125.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180054451.png" class><p>可以看到：这个查询和回复十分明了，我们就不进行讲解了</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>如下图，为一些TCP的报文段</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180523773.png" class><p>可以看到，TCP请求种类繁多</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180734368.png" class><p>我们可以右键一个包，然后点击追踪stream流，就可以把和它相关的包都给找出来</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181039224.png" class><p>如下：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181128838.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181954063.png" class><p>可以看到：这里记录了源端口与目的端口，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182202815.png" class><p>如图为三次握手的具体过程</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182359117.png" class><p>可以看到，这里对上图进行了完美诠释从请求号到请求报文段都是如此</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182655126.png" class><p>如图对HTTP报文进行分析</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182753793.png" class><p>这里就是一些很常规的请求行、请求头、请求尾的内容。这里不同的同学可以去看看HTTP协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面我将对不同种类的包进行讲解&lt;/p&gt;
&lt;h2 id=&quot;ARP&quot;&gt;&lt;a href=&quot;#ARP&quot; class=&quot;headerlink&quot; title=&quot;ARP&quot;&gt;&lt;/a&gt;ARP&lt;/h2&gt;&lt;p&gt;我们知道，arp协议工作于数据链路层，是为了完成IP地址与mac地址的转化，即根据IP</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark抓包基础</title>
    <link href="http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-15T07:51:44.000Z</published>
    <updated>2022-03-15T10:23:13.777Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="https://www.wireshark.org/#download">下载路径</a>，这里不作讲解，我们直接打开软件如图：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162610586.png" class><p>可以看到可选项非常多，我们重点关注</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162702297.png" class><p>选择WLAN就可以，表示无线网连接</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162954778.png" class><p>双击后如图，可以看到现在有非常多的数据包正在进行传输，</p><p>点击左侧的那个蓝色小按钮可以看到如下内容：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163150380.png" class><p>点击管理显示过滤器</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163804075.png" class><p>如图，左侧为自定义的名称，右侧为一些过滤条件，关于过滤条件我会细讲</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>表达式组合</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315164228353.png" class><h3 id="针对ip"><a href="#针对ip" class="headerlink" title="针对ip"></a>针对ip</h3><ul><li>对源ip地址过滤</li></ul><p>ip.src &#x3D;&#x3D; 192.168.0.1</p><ul><li>对目的地址过滤</li></ul><p>ip.dst &#x3D;&#x3D; 192.168.0.1</p><ul><li>对源地址或者目的地址进行过滤</li></ul><p>ip.addr &#x3D;&#x3D; 192.168.0.1</p><ul><li>如果想排除以上的数据包，只需要将其用括号囊括，然后使用 “!” 即可</li></ul><p>!(ip.addr &#x3D;&#x3D; 192.168.0.1)</p><h3 id="针对协议"><a href="#针对协议" class="headerlink" title="针对协议"></a>针对协议</h3><p><strong>注意！！！！！</strong>这里的协议都是小写，不要用大写</p><ul><li>获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可</li></ul><p>http</p><ul><li>捕获多种协议的数据包</li></ul><p>http or telnet</p><ul><li>排除某种协议的数据包</li></ul><p>not arp   或者   !tcp</p><h3 id="针对端口"><a href="#针对端口" class="headerlink" title="针对端口"></a>针对端口</h3><ul><li>捕获某一端口的数据包（以tcp协议为例）</li></ul><p>tcp.port &#x3D;&#x3D; 80</p><ul><li>捕获多端口的数据包，可以使用and来连接，下面是捕获高于某端口的表达式（以udp协议为例）</li></ul><p>udp.port &gt;&#x3D; 2048</p><h3 id="针对长度和内容的过滤"><a href="#针对长度和内容的过滤" class="headerlink" title="针对长度和内容的过滤"></a>针对长度和内容的过滤</h3><p>针对长度的过虑（这里的长度指定的是数据段的长度）</p><p>udp.length &lt; 20</p><p>http.content_length &lt;&#x3D;30</p><h3 id="针对url的过滤"><a href="#针对url的过滤" class="headerlink" title="针对url的过滤"></a>针对url的过滤</h3><p>http.request.uri matches “user” (请求的uri中包含“user”关键字的)</p><h3 id="针对http请求的一些过滤实例"><a href="#针对http请求的一些过滤实例" class="headerlink" title="针对http请求的一些过滤实例"></a>针对http请求的一些过滤实例</h3><ul><li>过滤出请求地址中包含“user”的请求，不包括域名；</li></ul><p>http.request.uri contains “User”</p><ul><li>精确过滤域名</li></ul><p>http.host&#x3D;&#x3D;baidu.com</p><ul><li>模糊过滤域名</li></ul><p>http.host contains “baidu”</p><ul><li>过滤请求的content_type类型</li></ul><p>http.content_type &#x3D;&#x3D;”text&#x2F;html”</p><ul><li>过滤http请求方法</li></ul><p>http.request.method&#x3D;&#x3D;”POST”</p><ul><li>过滤tcp端口</li></ul><p>http &amp;&amp; tcp.port&#x3D;&#x3D;80 or tcp.port&#x3D;&#x3D;5566</p><ul><li>过滤http响应状态码</li></ul><p>http.response.code&#x3D;&#x3D;302</p><ul><li>过滤含有指定cookie的http数据包</li></ul><p>http.cookie contains “userid”</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315173626612.png" class><p>遇到问题了…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是&lt;a href=&quot;https://www.wireshark.org/#download&quot;&gt;下载路径&lt;/a&gt;，这里不作讲解，我们直接打开软件如图：&lt;/p&gt;
&lt;img src=&quot;/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%9</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础使用</title>
    <link href="http://example.com/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-15T07:32:32.000Z</published>
    <updated>2022-03-15T07:40:47.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文章主要讲解docker的安装、基础命令以及容器数据卷配置等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>环境：Ubuntu 20.04</p></blockquote><p>**注意:**所有安装过程最好在root权限下进行</p><p>首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源：</p><figure class="highlight cmd"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cmd">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure><p>使用下面的 <code>curl</code> 导入源仓库的 GPG key：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>将 Docker APT 软件源添加到你的系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br></code></pre></td></tr></table></figure><p>现在，Docker 软件源被启用了，你可以安装软件源中任何可用的 Docker 版本。</p><p><strong>注意</strong></p><p>如果在 <code>/etc/docker</code>目录下没有 <code>daemon.json</code>就去自行创建</p><p>先运行命令</p><p><code>touch daemon.json</code></p><p>然后填写以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;192.168.2.2:8080&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;oom-score-adjust&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1000</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;exec-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://ucjisdvf.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;overlay2&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>     <span class="hljs-attr">&quot;max-size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100m&quot;</span><span class="hljs-punctuation">,</span> <br>     <span class="hljs-attr">&quot;max-file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;data-root&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/docker&quot;</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我这里安装了最新的Docker版本，如果有想安装指定版本的的可以自行查看</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt <span class="hljs-keyword">update</span><br>sudo apt install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>使用以下命令开启docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service docker <span class="hljs-literal">start</span> <br></code></pre></td></tr></table></figure><p>一旦Docker 服务将会自动启动。你可以输入下面的命令，验证它：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl status docker</span><br></code></pre></td></tr></table></figure><p>输出将会类似下面这样：</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315134519801.png" class><p>如果你想阻止 Docker 自动更新，锁住它的版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-mark hold docker-ce<br></code></pre></td></tr></table></figure><h3 id="非root用户执行docker"><a href="#非root用户执行docker" class="headerlink" title="非root用户执行docker"></a>非root用户执行docker</h3><p>默认情况下，只有 root 或者 有 sudo 权限的用户可以执行 Docker 命令。</p><p>想要以非 root 用户执行 Docker 命令，你需要将你的用户添加到 Docker 用户组，该用户组在 Docker CE 软件包安装过程中被创建。想要这么做，输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p><code>$USER</code>是一个环境变量，代表当前用户名。</p><p>登出，并且重新登录，以便用户组会员信息刷新。</p><h3 id="验证安装过程"><a href="#验证安装过程" class="headerlink" title="验证安装过程"></a>验证安装过程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker container <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>如果本地没有该镜像，这个命令将会下载测试镜像，在容器中运行它，打印出 “Hello from Docker”，并且退出。</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135323553.png" class><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135918749.png" class><h3 id="daemon-操作docker服务"><a href="#daemon-操作docker服务" class="headerlink" title="daemon(操作docker服务)"></a>daemon(操作docker服务)</h3><p>启动</p><p>service docker start </p><p>关闭</p><p>service docker start </p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140243394.png" class><p>查看状态</p><p>service docker status</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140357355.png" class><p>重启</p><p>service docker restart</p><p>开机自启动</p><p>sudo systemctl enable docker</p><h3 id="image-操作镜像"><a href="#image-操作镜像" class="headerlink" title="image(操作镜像)"></a>image(操作镜像)</h3><p>docker image 查看本地镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140919401.png" class><p>可以看到我这里啥都没有，不用担心啊</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>docker searck xxx</p><p>xxx为要搜索的镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141121723.png" class><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>docker pull pro:ver</p><p>pro为要下载的东西;ver即version即版本号，默认为最高版本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141515632.png" class><p>如图redis已经下载好了</p><p>可以在<a href="https://hub.docker.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84%E7%89%88%E6%9C%AC">https://hub.docker.com/搜索需要的版本</a></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>与下载类似</p><p>docker rmi pro:ver</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315142128410.png" class><p>docker rmi IMAGE ID</p><p>即加上IMAGE ID 也可以</p><h3 id="container-操作容器"><a href="#container-操作容器" class="headerlink" title="*container(操作容器)"></a>*container(操作容器)</h3><p>我们上节已经看过如何创建镜像了，把多个镜像放在一个容器里面就是我们想要的环境了，所以说能操作容器至关重要</p><p>docker run -i -t –name&#x3D;springboot2.3 redis &#x2F;bin&#x2F;bash</p><p>-i表示一直运行容器</p><p>-t是为了让我们去接受后续的命令</p><p>– name 是起名字</p><p>redis表示当前需要加载的东西，在这里我加了redis，可以在:后面加版本，比如redis:5.0</p><p>&#x2F;bin&#x2F;bash表示打开运行脚本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315143743403.png" class><p>可以看到这里的前缀已经改变了，这表示此时我们已经进入容器内部</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144108011.png" class><p>这里可以看到，docker内部其实与Linux十分相似</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144203061.png" class><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>docker ps -a</p><p>-a表示展示也历史容器，如果不加a就只展示当前容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144337598.png" class><h4 id="创建（守护式–推荐）"><a href="#创建（守护式–推荐）" class="headerlink" title="创建（守护式–推荐）"></a>创建（守护式–推荐）</h4><p>docker run -i -d –name&#x3D;springboot2.3 </p><p>这里把-t改成了-d,表示后台打开docker,这样docker会一直运行，不会因为我们exit容器就消失了</p><p>这里可以使用docker ps -a查看</p><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>docker exec -it springboot2.3 &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144916932.png" class><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>docker start name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145341070.png" class><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>docker stop name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145217330.png" class><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>docker rm name</p><p>这里的删除不能删除正在运行的容器，最好先把它停止后再运行</p><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>我们来思想一个问题</p><ul><li>docker删除后，数据是否还在？</li></ul><p>我们知道，一旦docker部署，数据都存储再容器里，此时数据就会消失，这太糟糕了</p><ul><li>docker和外部机器可以直接交换文件嘛？（docker和Linux主机）</li></ul><p>不可以</p><ul><li>容器之间直接数据交互可以吗</li></ul><p>不可以</p><p>以上三个问题引出了很多问题，比如一旦docker用不了，那数据就没了，数据不能相互交互。。。那该怎么完成呢？</p><p><strong>容器数据卷</strong></p><p>数据卷是宿主机中的一个目录或文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315150325837.png" class><p>相当于容器和数据卷的数据相互同步，这样上面三个问题就迎刃而解，一个数据卷可以被多个容器挂在，一个容器可以被挂载多个数据卷</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>docker run …  -v 宿主机目录（文件）：容器内目录（文件）</p><ul><li>目录必须是绝对路径</li><li>目录不存在就会自动创建</li><li>可挂载多个数据卷</li></ul><p>docker run -it –name&#x3D;c1 -v &#x2F;root&#x2F;data:&#x2F;root&#x2F;data_container redis &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151047744.png" class><p>查看容器内文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151255297.png" class><p>挂载多个容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151729896.png" class><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><ul><li>多个容器进行数据交换</li></ul><p>可以让多个容器挂载一个数据卷，实现间接共享，但这样十分麻烦，我们一般不用，推荐使用容器数据卷</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152209873.png" class><p>如图：c3就为数据卷容器</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ol><li>先配置c3</li></ol><p>docker run -it –name&#x3D;c3 -v &#x2F;volume redis</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152649165.png" class><ol start="2"><li>创建c1 &amp; c2,</li></ol><p>docker run -it –name&#x3D;c1 –volumes-from c3 redis </p><p>docker run -it –name&#x3D;c2 –volumes-from c3 redis </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文章主要讲解docker的安装、基础命令以及容器数据卷配置等。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;环境：Ubuntu 20.04&lt;/</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode225+232栈与队列</title>
    <link href="http://example.com/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2022-03-14T15:15:24.000Z</published>
    <updated>2022-03-15T00:46:14.485Z</updated>
    
    <content type="html"><![CDATA[<p>今天有点累，我想给自己放个假，就只分享两道题目吧。<br>这两道题有很大的相似性，关于栈与队列的相互转化，我就把他们放在一起了</p><h4 id="用栈实现队列-amp-用队列实现栈"><a href="#用栈实现队列-amp-用队列实现栈" class="headerlink" title=" 用栈实现队列&amp; 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/"> 用栈实现队列</a>&amp;<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/"> 用队列实现栈</a></h4><p>首先我们要先明白栈与队列有什么区别</p><h2 id="栈的特性"><a href="#栈的特性" class="headerlink" title="栈的特性"></a>栈的特性</h2><p><strong>先入后出，后入先出</strong></p><p>我相信大家都知道手枪的弹夹是什么样子</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314232350372.png" class><p>如图我们把它理解为一个弹夹,按顺序压入 1-&gt;2-&gt;3-&gt;4 一共四个子弹</p><p>那现在我们打出子弹的顺序是什么样子呢？那肯定是4-&gt;3-&gt;2-&gt;1啦，你这么聪明肯定知道哈哈😄</p><p>这就是栈，先入后出啦</p><h2 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h2><p><strong>先入先出，后入后出（FIFO）</strong></p><p>现在我们设想一下我们平时在餐厅买饭的场景，1-&gt;2-&gt;3-&gt;4排队按顺序进入餐厅前台点餐，如下图：</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315001104611.png" class><p>现在点餐完成后依次出去，这样出去的顺序就是1-&gt;2-&gt;3-&gt;4,与进来的顺序一致，这就是队列的特性了，你一定可以理解！</p><p>接下来我们先来讲如何用两个栈实现一个队列</p><h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><p>如图我们先给其中一个栈压入四个元素</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314233455839.png" class><p>现在我们想让两个栈相互配合，弹出最先进来的元素，怎么做呢？</p><p>首先，按照实现队列的先入先出思想，我们应该弹出的应该是1，那怎么弹出1呢？</p><p>直接把stack1的元素全部放入stack2里，然后弹出1就可以啦！</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314233925963.png" class><p>如上图所示为弹出过程</p><p>接下来我们再压入元素，和以前一样，我们直接压入stack1就可以啦，假如我们压入了5和6.</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314234112759.png" class><p>如果现在我们再想弹出元素该怎么弹出呢？</p><p>结果很明显，直接弹出stack2的元素就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>接下来我们总结一下思想：</p><p>只要是压入元素，我们之间压入stack1就可以</p><p>如果要弹出元素，我们先看看stack2是否为空</p><ul><li>如果不为空</li></ul><p>直接弹出stack2的最上面元素</p><ul><li>如果不为空</li></ul><p>把stack1的所有元素全部压入stack2，然后弹出stack2的最上面元素</p><p>至此，本道题的讲解已经全部结束</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackOne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackTwo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackOne.push(x);<br>    &#125;<br>    <span class="hljs-comment">// 判断stack2是否为空，如果为空就把stack1的元素全部压入stack2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">judge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stackTwo.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!stackOne.isEmpty()) &#123;<br>                stackTwo.push(stackOne.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        judge();<br>        <span class="hljs-keyword">return</span> stackTwo.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        judge();<br>        <span class="hljs-keyword">return</span> stackTwo.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackOne.isEmpty() &amp;&amp; stackTwo.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>代码如上</p><h2 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h2><p>如图所示我们向一个队列放入了四个元素 1-&gt;2-&gt;3-&gt;4</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314235125651.png" class><p>现在我们想模仿栈，让两个队列去配合弹出一个元素</p><p><strong>注意：</strong>队列是先入先出的，也就是说只能先让1从队列出去</p><p>而按照栈的思想，我们想让它出去的元素应是4</p><p>那我们应该怎么做呢？</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314235639721.png" class><p>如图，我们让前三个元素排队进入Queue1，然后让4从Queue1消失就可以了</p><p>假如现在我们继续压入2个元素5和6，现在问题来了，我们应该压入哪个队列呢？</p><ul><li>继续压入Queue1</li></ul><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315000031882.png" class><p>可以看到，这个时候假如我们想弹出一个元素，也就是弹出6，应该怎么做呢?</p><p>首先，在程序的角度，我们是不知道6在哪个队列的，因为我们只能查到Queue1的首元素5和Queue2的首元素1</p><p><strong>所以这个方法是行不通的！！！</strong></p><ul><li>压入<strong>已经有元素</strong>的Queue2</li></ul><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315000609644.png" class><p>如图，我们压入了5和6，现在想要弹出元素应该弹出6，我们就可以根据开始的方法，把一个队列的前N-1个元素压入另一个队列，删除最后一个元素就可以了</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>始终保持一个队列为空，</p><p>如果有元素要进来，直接压入不为空的那个队列</p><p>如果要删除元素，前N-1个元素压入为空的那个队列，然后删除剩下的最后一个元素</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queueOne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queueTwo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 保持一个队列一直为空</span><br>    <span class="hljs-comment">// 如果需要删除元素，就把其中一个队列的所有元素投入另一个队列</span><br>    <span class="hljs-keyword">public</span> Queue&lt;Integer&gt; <span class="hljs-title function_">getNotNullQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queueOne.isEmpty() ? queueTwo : queueOne;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        getNotNullQueue().add(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (getNotNullQueue() == queueOne) &#123;<br>            <span class="hljs-keyword">while</span> (queueOne.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                queueTwo.add(queueOne.remove());<br>            &#125;<br>            <span class="hljs-keyword">return</span> queueOne.remove();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (queueTwo.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                queueOne.add(queueTwo.remove());<br>            &#125;<br>            <span class="hljs-keyword">return</span> queueTwo.remove();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pop();<br>        push(i);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queueOne.isEmpty() &amp;&amp; queueTwo.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>至此，关于栈与队列的相互转化都已经完成了，感谢大家的观看！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天有点累，我想给自己放个假，就只分享两道题目吧。&lt;br&gt;这两道题有很大的相似性，关于栈与队列的相互转化，我就把他们放在一起了&lt;/p&gt;
&lt;h4 id=&quot;用栈实现队列-amp-用队列实现栈&quot;&gt;&lt;a href=&quot;#用栈实现队列-amp-用队列实现栈&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离级别</title>
    <link href="http://example.com/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2022-03-13T06:09:15.000Z</published>
    <updated>2022-03-13T06:58:17.735Z</updated>
    
    <content type="html"><![CDATA[<p>本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。</p><p>我们都知道MySQL事务有四大特性ACID，没有看过的可以去看以前的文章。</p><p>要实现这四大特性就必须要克服一些问题</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a><strong>脏读</strong></h3><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a><strong>不可重复读</strong></h3><p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a><strong>幻读</strong></h3><p>幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h2><img src="/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220313142716984.png" class><p>QL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读已提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。</p><p>启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age&#x3D;10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。</p><p>读未提交，<strong>其实就是可以读到其他事务未提交的数据</strong>，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>读已提交就是<strong>一个事务只能读到其他事务已经提交过的数据</strong>，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。</p><p>同样开启事务A和事务B两个事务，在事务A中使用 update 语句将 id&#x3D;1 的记录行 age 字段改为 10。此时，在事务B中使用 select 语句进行查询，我们发现在事务A提交之前，事务B中查询到的记录 age 一直是1，直到事务A提交，此时在事务B中 select 查询，发现 age 的值已经是 10 了。</p><p>这就出现了一个问题，在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。</p><p>读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p><p>这里就提到了MVCC的问题，因为可重复读时，read view是以事务为单位的，每次读取的数据以第一次的数据为准。</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。&lt;/p&gt;
&lt;p&gt;我们都知道MySQL事务有四大特性ACID，没有看过的可以去看以前的文章。&lt;/p&gt;
&lt;p&gt;要实现这四大特性就必须要克服一些问题&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>索引失效</title>
    <link href="http://example.com/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    <id>http://example.com/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</id>
    <published>2022-03-13T04:39:54.000Z</published>
    <updated>2022-03-13T06:08:17.932Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，MySQL的索引的数据结构是B+树，它相较于AVL树来说层数更低查找更快，相较于B树来说可以实现范围查找更快，关于这里不懂的同学可以在网上自行百度，今天我们主要讲讲索引为什么会失效。</p><h2 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h2><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313125531687.png" class><p>假如联合索引为(a, b),可以看到，索引的排序是先以a为基准进行排序的，也就是左边为（1， 1， 2）；右边为（2， 3， 3），而b字段是无序的。那也就是说只有a相等的情况下b才会有序。</p><p>这里是重点，如果这里看不懂，那后面就不用看了</p><p>这时候我们如果select * from table where a &#x3D; xx and b &#x3D; xx;</p><p>那它一定是走索引的</p><p>而select * from table where b &#x3D; xx;</p><p>它一定是不走索引的，因为没有a的情况下b一定无序</p><h2 id="x3D-或-lt-gt-导致索引失效"><a href="#x3D-或-lt-gt-导致索引失效" class="headerlink" title="!&#x3D; 或 &lt;&gt;导致索引失效"></a>!&#x3D; 或 &lt;&gt;导致索引失效</h2><p>假如我们select * from table where  a &gt; 1 and b &#x3D; 1;</p><p>那这样的话根据a&gt;1查到a很容易，但是b都是无序的，假如a&gt;1有很多数据，而要查到b&#x3D;1的数据，而此时是先按照a来排序，再按照b来排序，那此时b就相当于无序，所以此时索引就会失效</p><h2 id="like-导致索引失效"><a href="#like-导致索引失效" class="headerlink" title="like%导致索引失效"></a>like%导致索引失效</h2><p>我们都知道，无论是 %like还是%like%，此时索引都会失效，这是为什么呢？</p><blockquote><p>%代表任意数量的任意符号</p></blockquote><p>这个很好理解啊，字符串再索引里的排序也是按字母大小进行排序，和左前缀法则一样，当第一个字母相同的时候，它才会去匹配第二个，而当%代替了前面的任意字段以后，它如果根据后面查它就是无序的，</p><h2 id="OR导致索引失效"><a href="#OR导致索引失效" class="headerlink" title="OR导致索引失效"></a>OR导致索引失效</h2><p>OR连接的如果不是相同字段，那就会产生不符合最左前缀法则的东西，那它一定会失效，但是如果连接的是相同字段，那就无所谓了。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>聚簇索引就是把数据和索引放在了一起，索引叶子节点存储了行数据。这也是<strong>Innodb</strong>的默认索引，一般为主键索引</p><p>像普通索引、复合索引、唯一索引都是辅助索引，它存储了数据的id值而不是数据本身，他会先查找到id&#x3D;20的主键，然后通过真实的主键索引去查找到相应的数据</p><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313132747042.png" class><p>非聚簇索引的数据和索引分开存储</p><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313132545786.png" class><p>它的叶子节点存储的是数据的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道，MySQL的索引的数据结构是B+树，它相较于AVL树来说层数更低查找更快，相较于B树来说可以实现范围查找更快，关于这里不懂的同学可以在网上自行百度，今天我们主要讲讲索引为什么会失效。&lt;/p&gt;
&lt;h2 id=&quot;最佳左前缀法则&quot;&gt;&lt;a href=&quot;#最佳左前缀法则&quot;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>ACID</title>
    <link href="http://example.com/2022/03/12/MySQL/ACID/"/>
    <id>http://example.com/2022/03/12/MySQL/ACID/</id>
    <published>2022-03-12T15:08:20.000Z</published>
    <updated>2022-03-12T15:45:14.494Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，MySQL的事务有四大特性：持久性、原子性、一致性、隔离性。这就是ACID，那这究竟是怎么实现的呢？</p><img src="/2022/03/12/MySQL/ACID/image-20220312231113528.png" class><p>事务是访问数据库的程序执行单元，它可能包含一个或多个SQL语句，SQL要么都执行，要么都不执行。事务执行基于存储引擎，比如我们常见的Innodb,Myisam,Myisam不支持事务，所以我们只讲Innodb.</p><p>执行数据包含三个部分：开启事务-&gt;执行SQL-&gt;提交事务。默认是自动提交，</p><h2 id="原子性-Atomicty"><a href="#原子性-Atomicty" class="headerlink" title="原子性(Atomicty)"></a>原子性(Atomicty)</h2><p>一个事务是一个操作单位，这些东西要不全部执行，要不全部不执行，假如执行过程中一个SQL执行出错，那已经执行的SQL就要回滚</p><p><strong>undo log</strong></p><p>当事务对数据库进行操作的时候，innodb会生成undo log记录SQL执行的相关信息，一旦执行出错，那innodb就会根据undo log去进行相反的操作。</p><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p>指事务执行以后，数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态，比如主键要唯一，大小要符合规范，外键约束要符合，</p><h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h2><img src="/2022/03/12/MySQL/ACID/image-20220312233607667.png" class><p>隔离性分为两种情况</p><ul><li>写写操作</li></ul><p>通过锁实现，在事务执行之前，事务要先获取锁，获取以后才可以操作数据，没有锁只能等待，当锁被释放以后，其他线程就会去争抢，</p><ul><li>写读操作</li></ul><p>通过MVCC实现，想了解可以看我的上一篇文章。</p><h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>持久性指一个事务一旦提交，它对数据库的改变就是永久性的，我们知道MySQL数据存储于磁盘，直接读取磁盘是很慢的，所以innodb提供了一个buffer，包含了磁盘部分数据页的一个映射，作为访问数据库的一个缓存。</p><p>在访问数据库的时候我们会先访问buffer，buffer没有才访问磁盘，这就类似于CPU和内存之间的Cache</p><p>当写入数据的时候也会先写入buffer中，然后定期将buffer中数据写入磁盘，这就产生了数据丢失的风险，假如buffer中数据还没有写入磁盘，这个时候数据库宕机，那buffer数据就会丢失，这就产生了<strong>redo log</strong>。</p><p>当数据库数据进行新增或修改的时候，除了修改buffer数据，还会把操作写入redo log，redo log是一个预写式的日志，也就是先把操作写入redo log,接下来才会写入buffer，这就保证了数据不会出现数据丢失。</p><p>在事务提交的时候将缓冲区中的redo日志同步写入磁盘，保证写入一定成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，MySQL的事务有四大特性：持久性、原子性、一致性、隔离性。这就是ACID，那这究竟是怎么实现的呢？&lt;/p&gt;
&lt;img src=&quot;/2022/03/12/MySQL/ACID/image-20220312231113528.png&quot; class&gt;

&lt;p&gt;事务是访</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="ACID" scheme="http://example.com/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>MVCC</title>
    <link href="http://example.com/2022/03/12/MySQL/MVCC/"/>
    <id>http://example.com/2022/03/12/MySQL/MVCC/</id>
    <published>2022-03-12T12:43:30.000Z</published>
    <updated>2022-03-12T15:03:29.080Z</updated>
    
    <content type="html"><![CDATA[<p>MVCC全称Multi-Version Concurrency Control，即多版本并发控制。主要是为了提高数据库的读写性能。让数据库读写的时候不用加锁，MVCC主要是处理快照读，这个读指的是快照读而不是当前读。</p><blockquote><p>快照读指普通的 select 读</p><p>当前读为悲观锁读 即update insert delete等</p></blockquote><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><img src="/2022/03/12/MySQL/MVCC/image-20220312220616131.png" class><p>我们以这张图为例，张三、李四、王五、赵六对应的id都为1，第一次插入张三，后面用update进行更新，更新了若干次，最后一次更新结果为赵六。</p><p>历史数据就存储到了undo log日志里面，可以看到每条数据除了数据本身以外还有个roll_pointer和tx_id，tx_id为事务id，自增，roll_pointer是一个回滚指针，用来回滚到上一个版本。</p><h2 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h2><p>我们可以看到一个id有多条数据，那readview就来记录我们在查询的时候要在版本链里的要选择的数据。</p><img src="/2022/03/12/MySQL/MVCC/image-20220312221840189.png" class><p>read view里有多个参数，</p><ul><li>m_ids</li></ul><p>表示生成read view时当前系统活跃的读写事务的id列表，活跃是指没有commit。</p><ul><li>min_trx_id</li></ul><p>表示m_ids里最小的值</p><ul><li>max_trx_id</li></ul><p>它表示系统应该分配给下一个事务的id</p><ul><li>creator_trx_id</li></ul><p>生成readview的事务的事务id，表示是谁生成了这个read view</p><h3 id="read-view如何判断版本链哪个id可用？"><a href="#read-view如何判断版本链哪个id可用？" class="headerlink" title="read view如何判断版本链哪个id可用？"></a>read view如何判断版本链哪个id可用？</h3><img src="/2022/03/12/MySQL/MVCC/image-20220312222452263.png" class><ul><li>trx_id &#x3D;&#x3D; creator_trx_id</li></ul><p>trx_id为刚才链表里的事务id，这时候就代表这条记录是事物本身的记录，这肯定是可以的。</p><ul><li>trx_id &lt; min_trx_id</li></ul><p>这就说明这个id已经commit了，而提交的事务id是可以被访问的。</p><ul><li>trx_id &gt; max_trx_id</li></ul><p>我们知道，读取事务的时候只能读取版本链里面的数据，如果满足trx_id &gt; min_trx_id，那就说明这个数据没有在版本链里，因为max_trx_id都没有被分配过，而trx_id还是自增的。</p><ul><li>min_trx_id&lt;trx_id &lt; max_trx_id</li></ul><p>如果trx_id在m_ids里面，那就不可以，因为里的事务都是活跃的，还没有commit,而我们是不可以访问没有commit的数据的。</p><p>如果trx_id不在m_ids里面，那就说明它已经不活跃，即已经提交了，那它一定可以访问</p><h2 id="MVCC如何实现读已提交-RC-和可重复读-RR"><a href="#MVCC如何实现读已提交-RC-和可重复读-RR" class="headerlink" title="MVCC如何实现读已提交(RC)和可重复读(RR)"></a>MVCC如何实现读已提交(RC)和可重复读(RR)</h2><img src="/2022/03/12/MySQL/MVCC/image-20220312223743798.png" class><p>假如，某张表现在有一条数据，现在我们执行以下两个事务：20和60</p><img src="/2022/03/12/MySQL/MVCC/image-20220312223850569.png" class><p>20事务执行了两条update</p><img src="/2022/03/12/MySQL/MVCC/image-20220312223939428.png" class><p>执行之后它的版本链就如图所示，王五为最新数据</p><img src="/2022/03/12/MySQL/MVCC/image-20220312224034702.png" class><p>这就是它的read view，刚才我们的20和60没有commit，所以m_ids为[20, 60],最小事务min_trx_id为20，下次要分配max_trx_id的就是61，creator_trx_id默认为0.</p><img src="/2022/03/12/MySQL/MVCC/image-20220312224435581.png" class><p>这就是每个版本的情况，最小活跃事务id为20，张三的id为10，10&lt;20,因此条件满足，这就实现了读已提交。</p><p><strong>RC与RR区别</strong></p><p>读已提交和可重复读生成的read view时机不同</p><ul><li>读已提交</li></ul><p>每次执行select查询的时候就生成了read view，也就是说<strong>一个事务</strong>的两次的select就会生成两个read view</p><p>假如我们现在在更新最后一条数据王五的时候还没有提交，这时候事务1的select进行了第一次查询生成一个read view，然后事务2的update操作提交以后以后事务1select又进行了第二次查询又生成一个read view，它这个时候读取到了王五的最新数据，这个时候一个事务查到的两条数据不同，那就违背了可重复读。</p><p>最终原因还是因为每一次select都会生成一个read view</p><ul><li>可重复读</li></ul><p>可重复读生成read view是以事务为单位</p><p>假如我们现在在更新最后一条数据王五的时候还没有提交，这时候事务1的select进行了第一次查询生成一个read view，然后事务2的update操作提交以后以后事务1select又进行了第二次查询它就会去使用上一次的read view，不会生成新的read view，一个事务只生成一个read view，那它两次查询到的数据都是李四而不是王五。这就实现了可重复读</p><p>同时这也解决了幻读的问题，因为它每次只有一个read view，即使是insert以后，它查询的还是第一次生成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MVCC全称Multi-Version Concurrency Control，即多版本并发控制。主要是为了提高数据库的读写性能。让数据库读写的时候不用加锁，MVCC主要是处理快照读，这个读指的是快照读而不是当前读。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快照读指普通的 </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="MVCC" scheme="http://example.com/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch</title>
    <link href="http://example.com/2022/03/12/JUC/CountDownLatch/"/>
    <id>http://example.com/2022/03/12/JUC/CountDownLatch/</id>
    <published>2022-03-12T11:04:47.000Z</published>
    <updated>2022-03-12T11:41:36.846Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们一起来讲讲CountDownLatch</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">A synchronization aid that allows <span class="hljs-literal">one</span> <span class="hljs-keyword">or</span> more threads <span class="hljs-built_in">to</span> <span class="hljs-built_in">wait</span> <span class="hljs-keyword">until</span><br><span class="hljs-keyword">a</span> <span class="hljs-built_in">set</span> <span class="hljs-keyword">of</span> operations being performed <span class="hljs-keyword">in</span> other threads completes.<br></code></pre></td></tr></table></figure><p>这是CountDownLatch源码中的解释：CountDownLatch这个同步工具允许一条或多条线程等待其他线程中的一组操作完成后，再继续执行。</p><p>我们都看过复仇者联盟，这里的灭霸需要集齐所有的原石就可以超神。我们现在假设它可以派出多个小弟去分别寻找原石，灭霸只进行合成就可以。但是每个小弟找到的时间是不一样的，那灭霸怎么知道所有的小弟都把这个东西找到了呢？</p><p>这就是CountDownLatch的用武之地了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>这一句话就是新建一个CountDownLatch对象，构造函数中的数字为灭霸需要的原石的数目，也就是5个任务，每当一个任务完成，那latch就会调用countDown（）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br><br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br></code></pre></td></tr></table></figure><p>CountDownLatch有一个子属性为Sync，可以看到Sync继承了AQS，它重写了AQS中的tryReleaseShared等方法，可以看出来它想做到共享模式，我们在以前的AQS讲解中只讲了独占模式，其实差距不大，我们知道，在独占模式下，只有将要出队的节点中的线程被唤醒，共享模式下，除了要把要出队的节点唤醒外，还会去唤醒后续处于挂起状态的节点。</p><p>这里的tryAcquireShared就是获取AQS内部state，之后判断如果该值为0，表示锁空闲，那就返回1，否则返回-1</p><p>tryReleaseShared每次通过一个自旋的CAS操作来将AQS内部的state-1，如果不需要释放锁，或未完全释放，就返回false，否则返回true。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br></code></pre></td></tr></table></figure><p>await用于等待子任务结束，unit为等待时间，不填默认一直等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>countDown用于子任务告诉当前线程任务完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.getCount();<br>&#125;<br></code></pre></td></tr></table></figure><p>获取还未完成的任务数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们一起来讲讲CountDownLatch&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>JVM双亲委派</title>
    <link href="http://example.com/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    <id>http://example.com/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</id>
    <published>2022-03-12T10:17:02.000Z</published>
    <updated>2022-03-12T11:01:14.059Z</updated>
    
    <content type="html"><![CDATA[<p>我们上一篇文章说了，类加载就是把一份被javac编译过的class文件通过加载生成某种结构的数据结构进入内存，程序可以调用这个数据结构来构造出object。</p><p>那这里就产生了两个问题</p><ol><li>不同类加载器，除了读取二进制流的动作不同和范围不一样，那后续的加载逻辑是否一样？</li><li>遇到限定名一样的类，那么多类加载器会不会产生混乱？</li></ol><p>每个类加载器都有属于自己的命名空间，一个类如果被不同的类加载器所加载就会产生混乱。</p><img src="/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/image-20220312182445758.png" class><p>我们希望：在默认情况下，一个限定名的类只会被一个类加载器加载并解析使用，这样在程序中，它就是不唯一的，不会产生歧义。</p><p>这就要提到双亲委派模型了，当一个类加载器收到加载请求，它不会自己去加载，而是先传递给父系加载器，这样所有的类都会被传递到Bootstrap ClassLoader,如果父加载器没有办法加载了，那么儿子加载器才会去加载</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是Java类加载的源码</p><p>它首先通过Class&lt;?&gt; c &#x3D; findLoadedClass(name);判断类有没有被加载，如果没有，它就开启加载流程，如果有就加载缓存。</p><p>parent代表当前类的父加载器，注意：<strong>这里的父亲不是继承关系，只是父亲的意思</strong>，当parent为null的时候，它需要的类加载器就是BootstrapClassLoader，如果它不为null，那就要让它根据它的限定名去尝试加载该类了，并且返回class对象，如果返回为null，那就说明该类加载器没有能力去加载这个类，那就调用findClass，</p><p>if (c &#x3D;&#x3D; null) {<br>                &#x2F;&#x2F; If still not found, then invoke findClass in order<br>                &#x2F;&#x2F; to find the class.<br>                long t1 &#x3D; System.nanoTime();<br>                c &#x3D; findClass(name);</p><p>​    … …</p><p>就是这里，这就表示这个时候各个类加载器自己去寻找实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,<br>                                     ProtectionDomain protectionDomain)<br>    <span class="hljs-keyword">throws</span> ClassFormatError<br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> b.remaining();<br><br>    <span class="hljs-comment">// Use byte[] if not a direct ByteBufer:</span><br>    <span class="hljs-keyword">if</span> (!b.isDirect()) &#123;<br>        <span class="hljs-keyword">if</span> (b.hasArray()) &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, b.array(),<br>                               b.position() + b.arrayOffset(), len,<br>                               protectionDomain);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// no array, or read-only array</span><br>            <span class="hljs-type">byte</span>[] tb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>            b.get(tb);  <span class="hljs-comment">// get bytes out of byte buffer.</span><br>            <span class="hljs-keyword">return</span> defineClass(name, tb, <span class="hljs-number">0</span>, len, protectionDomain);<br>        &#125;<br>    &#125;<br><br>    protectionDomain = preDefineClass(name, protectionDomain);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> defineClassSourceLocation(protectionDomain);<br>    Class&lt;?&gt; c = defineClass2(name, b, b.position(), len, protectionDomain, source);<br>    postDefineClass(c, protectionDomain);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是它的加载过程，final修饰，这就严重我们以前提到了Java类加载的加载部分只能让JVM自己完成，而不能自己来</p><ol><li>不同类加载器，除了读取二进制流的动作不同和范围不一样，那后续的加载逻辑是否一样？</li></ol><p>除了BootstrapClassLoader，所有非BootstrapClassLoader都继承了Java.lang.ClassLoader,都由这个类的defineClass进行后续处理。</p><ol start="2"><li>遇到限定名一样的类，那么多类加载器会不会产生混乱？</li></ol><p>越核心的类库被越上层的类加载器加载，而某限定名的类一旦被加载过了，被动情况下，就不会再加载相同限定名的类。这样，就能有效避免混乱。</p><p>基于双亲委派模型规定的这种带有优先级的层次性关系，虚拟机运行程序时就能够避免类的重复加载。<br>当父类类加载器已经加载过类时，如果再有该类的加载请求传递到子类加载器，子类加载器执行loadClass方法，然后委托给父类加载器尝试加载该类，但是父类加载器执行 Class&lt;?&gt; c &#x3D; findLoadedClass(name)；检查该类是否已经被加载过这一阶段就会检查到该类已经被加载过，直接返回该类，而不会再次加载此类。</p><p>双亲委派模型能够避免核心类篡改。一般我们描述的核心类是 rt.jar、tools.jar 这些由启动类加载器加载的类，这些类库在日常开发中被广泛运用，如果被篡改，后果将不堪设想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们上一篇文章说了，类加载就是把一份被javac编译过的class文件通过加载生成某种结构的数据结构进入内存，程序可以调用这个数据结构来构造出object。&lt;/p&gt;
&lt;p&gt;那这里就产生了两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同类加载器，除了读取二进制流的动作不同和范围不一样</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="类加载" scheme="http://example.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode056合并区间</title>
    <link href="http://example.com/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>http://example.com/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2022-03-12T06:43:04.000Z</published>
    <updated>2022-03-12T11:02:37.907Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们来分析一道比较常规的题目，<a href="https://leetcode-cn.com/problems/merge-intervals/"> 合并区间</a>，这道题我几个月之前已经做过一次了，今天再来做一次，做的不是很快，其中遇到了很多小的问题。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>要解决这道题的第一步首先就是排序</p><p>如果我们按照区间的<strong>左端点排序</strong>，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的</p><img src="/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/image-20220312162042511.png" class><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针法过程如下</p><img src="/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/image-20220312163719399.png" class><p>我们分别定义两个节点head 和 tail</p><p>head表示当前区间，所能到达的最远的点，而tail则表示当前区间的起点，即最小的节点，我们想要扩大区间的范围就要让head扩大</p><p>由于我们刚才已经初始化过head和tail节点了，接下来我们要做的就是从第二个区间开始遍历</p><p><strong>情况1</strong></p><p>假如当前遍历的区间，记为记为intervals[i]，它的开始数字intervals[i] [0]&lt;&#x3D;head,此时我们要获取这两个集合能表示的最大范围，那head &#x3D; max(head, intervals[i] [1]).</p><p>比如上图遍历到（0，1）时,head&#x3D;5大于1,那就说明两个集合是相交的，这时候head&#x3D;max(5, 1).</p><p><strong>情况2</strong></p><p>假如intervals[i] [0]&lt;&#x3D;head,那就说明两个集合没有相交的区间，那就要把head到tail的区间放入结果中并且重新定义head和tail</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// System.out.println(Arrays.deepToString(intervals));</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], tail = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (head &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                head = Math.max(intervals[i][<span class="hljs-number">1</span>], head);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;tail, head&#125;);<br>                head = intervals[i][<span class="hljs-number">1</span>];<br>                tail = intervals[i][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;tail, head&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后强调一下</p><p>res.toArray(new int[res.size()][]);这个方法</p><p>这就是把答案返回成你想要的样子，这里返回一个二维数组，返回的类型要固定。</p><p>在这里初始化的时候 int数组为引用类型，是可以直接放入List的，但是像int这种普通类型不可以</p><p>List&lt;int[]&gt; res &#x3D; new ArrayList&lt;&gt;();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在我们来分析一道比较常规的题目，&lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/&quot;&gt; 合并区间&lt;/a&gt;，这道题我几个月之前已经做过一次了，今天再来做一次，做的不是很快，其中遇到了很多小的问题。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode234回文链表</title>
    <link href="http://example.com/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</id>
    <published>2022-03-12T04:07:36.000Z</published>
    <updated>2022-03-12T05:07:26.951Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来分享一道easy题目，这道题虽然是一道easy题目，但是要做好却并不easy。</p><p>二话不说我们直接分享题目：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>我相信看到这个题你一定认为很简单，我们直接就把整个链表的元素存在一个集合里面，然后用双指针的方法就得出来了嘛！</p><p>没错我刚开始也是这么想的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) != list.get(list.size() - i - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，此方法算法时间复杂度为O（n）,空间复杂度为O（n）.</p><p>我们是否有更加高效的方法？</p><p>答案是有的</p><h2 id="快慢指针-反转链表法"><a href="#快慢指针-反转链表法" class="headerlink" title="快慢指针+反转链表法"></a>快慢指针+反转链表法</h2><p>我们知道回文串就是从中间到两边每个元素都相同的串，那我们是否可以确定中间位置，然后从中间向两边逐步判断呢？</p><p>我们知道，链表的指向方向是唯一的</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312125005279.png" class><p>根据上图，我们如果从mid分别向head和tail方向同时不断探索，直到为空，如果是成功，那它就是一个回文子串</p><h3 id="确定mid位置"><a href="#确定mid位置" class="headerlink" title="确定mid位置"></a>确定mid位置</h3><p>确定mid位置可以用快慢指针的 方法，这个方法在链表里十分常用，简单来说就是定义一个fast和slow节点同时向前走，fast每次移动2步，slow每次移动一步，那啥时候停止呢？那就是fast不能移动的时候，即fast &#x3D;&#x3D; null || fast.next &#x3D;&#x3D; null</p><h3 id="确定了mid接下来就是反转链表了"><a href="#确定了mid接下来就是反转链表了" class="headerlink" title="确定了mid接下来就是反转链表了"></a>确定了mid接下来就是反转链表了</h3><p>这个过程其实可以在slow移动的时候同步进行，在这里我们不过多赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> slow.next;<br>            slow.next = pre;<br>            pre = slow;<br>            slow = next;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这就是反转和快慢指针的过程</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>我们要注意一个东西</p><p>链表的节点数可能是偶数也可能是奇数</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312125940584.png" class><p>假如三个节点 1-&gt;2-&gt;3，此时候节点数目为<strong>奇数</strong>，这个时候也一样fast指向3,slow指向2，pre指向1.这个时候我们就需要把slow再向后移位了，这个时候经过翻转那slow刚好处于中间，那它就需要向后再移动一位，才能继续链表的比较</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312130248017.png" class><p>假设此时两个节点 1-&gt; 2,这个时候pre就是1，fast指向空，slow指向2，pre指向1结果正合我意，我们不做任何处理，就让它继续比较</p><p>完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 快慢指针和翻转部分</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> slow.next;<br>            slow.next = pre;<br>            pre = slow;<br>            slow = next;<br>        &#125;<br>        <span class="hljs-comment">// 细节部分</span><br>        <span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">null</span>) slow = slow.next;<br>        <span class="hljs-comment">// 最后比较部分</span><br>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (slow.val != pre.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            slow = slow.next;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，关于本道题目的讲解全部结束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们来分享一道easy题目，这道题虽然是一道easy题目，但是要做好却并不easy。&lt;/p&gt;
&lt;p&gt;二话不说我们直接分享题目：&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list/&quot;&gt;回文链表&lt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载</title>
    <link href="http://example.com/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-03-11T12:51:23.000Z</published>
    <updated>2022-03-11T13:46:36.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java代码加载过程"><a href="#Java代码加载过程" class="headerlink" title="Java代码加载过程"></a>Java代码加载过程</h1><p>在详细讲解类加载之前我想我们要先知道我们编写的Java代码是如何被加载运行的</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311205528562.png" class><p>从上图可以看出，javac先把代码编译为字节码，然后由JVM去加载字节码，运行的时候<strong>解释器</strong>把字节码解释为机器指令。在程序运行期间，<strong>即时编译器</strong>能针对热点代码将该部分字节码编译为机器指令，从而获得更高的运行效率，在整个运行期间解释器和即时编译器相互配合，使得程序几乎能达到和编译型语言一样的执行速度。</p><p>对于我们来说，我们今天只讲解代码是如何编译为字节码的。</p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载流程的目的是什么？</p><p>简单来说就是把一份被javac编译过的class文件通过加载生成某种结构的数据结构进入内存，程序可以调用这个数据结构来构造出object</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311210813023.png" class><p>上图表示了一个类的生命周期，类加载只包括<strong>加载、连接和初始化</strong>三个阶段，加载只是类加载的第一个环节，解析部分是十分灵活的，它可以在初始化环节之前和之后进行，实现所谓的后期绑定。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311211403796.png" class><p>如图，加载是一个读取class文件，将其转化为某种数据结构放在方法区，并在堆中生成一个便于用户调用的java.lang.Class对象的过程，其中有几个重要点，这里的class不一定是本地class文件，也有可能是数据库或者网络，</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>虽然上面已经加载过了，但这不代表JVM完全接收这个类，如果程序想用这个类，那就必须进行连接。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接第一步就是进一步对这个类进行验证，它对在方法区的数据结构进行了以下验证</p><ul><li><p>元数据认证</p></li><li><p>字节码验证</p></li></ul><p>这两个就是对class静态结构进行语法分析，看看它会不会产生危害虚拟机的行为</p><p>这时候就会认为这个程序是安全的，但是这还没有完全结束</p><ul><li>对符号引用进行验证</li></ul><p>这一步是在解析阶段完成的，它可以发生在初始化阶段发生前和发生后，</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在验证通过后，就可以大概认为这个类是安全的，接下来就可以进入准备阶段，这个阶段就是为了该类型中定义的静态变量赋0值.这里仅仅是静态变量。</p><blockquote><p>在这里强调一下，虚拟机内存规范中定义了方法区这种抽象概念，Java虚拟机在JDK8之前使用了永久代这种具体实现方式来实现方法区，在JDK8以后启用了“永久代”这种实现方，而改用元空间这种直接内存来取代，所以我们常看到的JDK8以后用元空间取代了方法区这是错误的，因为元空间只是一种实现方式。</p></blockquote><p>在JDK8之前类的元信息、常量池、静态变量都存在永久代这种实现中，而JDK8以后常量池静态变量被移出了方法区，转移到了堆中，元信息依然放在方法区，但存储方式改为了元空间。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>接下来我们来讲一讲解析阶段</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311213420013.png" class><p>这个阶段就是将符号引用替换为直接引用，假如A对象中存在B对象，在A编译的时候是不知道B有没有被加载的，这个时候称它为符号引用，A不知道B的实际地址，在解析的时候A就会知道B的地址，这也就是为什么会出现多态这种东西，比如我们常写的</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>这就实现了动态绑定解析。</p><p>至此连接阶段已经全部完成，此时外部的Java类已经全部引入到了你的程序中</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段比较简单，简单来说就是判断此时代码中是否存在主动的资源初始化操作，如果有的话就执行，这里说的主动资源初始化不是指构造函数，而是class层面的，比如成员变量的赋值，静态变量赋值等。</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311214322003.png" class><p>至此，类加载过程就全部讲完了，</p><p>但是还没有完全结束，请期待下一集~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java代码加载过程&quot;&gt;&lt;a href=&quot;#Java代码加载过程&quot; class=&quot;headerlink&quot; title=&quot;Java代码加载过程&quot;&gt;&lt;/a&gt;Java代码加载过程&lt;/h1&gt;&lt;p&gt;在详细讲解类加载之前我想我们要先知道我们编写的Java代码是如何被加载运行的</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="类加载" scheme="http://example.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode347前K个高频元素</title>
    <link href="http://example.com/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2022-03-11T05:03:51.000Z</published>
    <updated>2022-03-11T05:05:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>今天做了一道题目：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>,一般来说不管是前k个改频元素还是第k大的数都可以用优先级队列的思想</p><p>在讲这道题之前我们先来看一看两种堆的结构，堆的本质就是二叉树，它分为大顶堆和小顶堆。</p><p>大顶堆中每个父节点大于子节点，小顶堆每个父节点小于子节点</p><img src="/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/image-20220311111807467.png" class><p><strong>topK大构建一个小顶堆</strong></p><p>为什么呢？</p><p>我们知道，小顶堆树的根节点一定是这个堆里面所有元素的最小值，而所有树节点都比根节点大，因此我们构建一个K个节点的小顶堆，当来了一个节点时</p><ul><li>如果堆节点数小于K</li></ul><p>直接把节点放入堆</p><ul><li>如果堆的节点上为k时</li></ul><p>先判断堆的首节点是否比新来的节点小，如果新来的节点比较小就不做处理，否则就把根的头节点换了，重新构建整个堆</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 把所有元素放进hashmap</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 创建一个小顶堆，根据map中出现的频率进行排序</span><br>        <span class="hljs-comment">// 注意这里queue里存储的还是元素，而不是出现的频率</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; map.get(a) - map.get(b));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>                queue.add(key);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(queue.peek()) &lt; map.get(key))&#123;<br>                queue.remove();<br>                queue.add(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) res[cnt++] = queue.remove();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的PriorityQueue就是一个优先级队列</p><p>remove就是移除最小的元素</p><p>在这里值得一提的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这句话在HashMap里很常用，map.getOrDefault(num, 0)表示尝试去获取num键所对应的值，否则返回0,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天做了一道题目：&lt;a href=&quot;https://leetcode-cn.com/problems/top-k-frequent-elements/&quot;&gt;347. 前 K 个高频元素&lt;/a&gt;,一般来说不管是前k个改频元素还是第k大的数都可以用优先级队列的思想&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://example.com/2022/03/10/JUC/CAS/"/>
    <id>http://example.com/2022/03/10/JUC/CAS/</id>
    <published>2022-03-10T15:39:59.000Z</published>
    <updated>2022-03-10T15:51:05.945Z</updated>
    
    <content type="html"><![CDATA[<p>建议看这篇文章之前先去看一下上一篇文章（Java锁机制）</p><p>假设我们现在有多个线程想去访问操作同一资源，很多人第一反应一定是互斥锁，但互斥锁是悲观的</p><ul><li>悲观锁</li></ul><p>简单来说，操作系统认为如果不严格管理线程调用，那一定会出现问题，那它就会把一个资源进行锁定，只让一个线程去调度。从而阻塞别的线程。</p><ul><li>乐观锁</li></ul><p>假设现在我们大部分操作都是读操作，那就没必要去每次操作就去锁定资源，那我们可不可以不锁定资源也能去同步线程呢？</p><p>这就要用到CAS（compare and swap）</p><img src="/2022/03/10/JUC/CAS/image-20220310232112615.png" class><p>假如现在资源状态值为0，多个线程同时访问到资源为0，记为OldValue，此时A,B,C同时想去修改这个状态值，假设A运气比较好，A它优先修改了资源状态为1，这时候B和C，在修改之前会拿资源状态值和刚才的OldValue进行比较，这时候B和C会发现不对劲，即资源状态值和刚才的OldValue不一样，那它们就会放弃修改，在实际操作中，我们一般不会让它直接放弃，而是让它去自旋</p><p><strong>CAS原子性</strong></p><p>我们都知道，CAS在更新前会进行判断，假如AB同时想去获取资源，在A像去把状态值改变的时候B抢先把值给修改了，这时候就会一个资源被两个资源占用，因此保证CAS原子性就十分重要。</p><p>现在CPU已经有了原子性的指令，直接调用即可。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger就是CAS的一种实现，</p><img src="/2022/03/10/JUC/CAS/image-20220310233457294.png" class><p>通过源码可以看到它通过Unsafe的cas操作来进行值的更新。这里的U就是unsafe对象。</p><img src="/2022/03/10/JUC/CAS/image-20220310233620519.png" class><p>它的getAndIncrement()即数值自增方法就是用Unsafe对象的getAndAddInt来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是getAndAddInt的源码，可以看到确实用到了CAS,这里的循环就是自旋<br>至此，我所了解的CAS内容全部讲解完毕~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;建议看这篇文章之前先去看一下上一篇文章（Java锁机制）&lt;/p&gt;
&lt;p&gt;假设我们现在有多个线程想去访问操作同一资源，很多人第一反应一定是互斥锁，但互斥锁是悲观的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;悲观锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，操作系统认为如果不严格管理线程调用，那一</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
    <category term="CAS" scheme="http://example.com/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Java锁机制</title>
    <link href="http://example.com/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-10T14:10:08.000Z</published>
    <updated>2022-03-10T15:09:23.054Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310221706087.png" class><p>在Java中每个Object，也就是每一个对象都有一把锁。这把锁放在对象头，锁中记录了当前对象被哪一个线程锁占用。如上图中，红色的为对象Object，头为蓝色的，绿色的就是锁。</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310222044664.png" class><p>如图，每个Java对象分为三块，分别为对象头、实例数据、填充字节</p><ul><li>对象头</li></ul><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310222625579.png" class><p>对象头包含两部分：mark word和class point，class point指向对象在当前对象类型所在方法区中的类型数据。mark word存储了很多和当前对象运行时的状态信息。比如hashcode、锁状态标志，指向记录的指针等。</p><p>所标志位的不同bit值代表锁的不同状态</p><p>sychronized关键字被用来同步线程，sychronized被编译后会生成monitorenter和monitorexit两个字节码来进行线程同步</p><p>在这里介绍一下monitor，它常被翻译为管程\监视器，关于moniter我们可以把它想象成一个房间，只能容纳一名客人。而线程就是客人，一个线程进入monitor，那其他线程只能等待，只要当线程退出，其他线程才有进入的机会。</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310223405307.png" class><p>看一下上面这张图，EntrySet聚集了一些像进入monitor的线程，正处于waiting状态，假如线程A成功进入monitor，那它就处于active状态，假如A线程执行过程中遇到了一个判断条件，那就让它暂时让出执行权，进入WaitSet，那它的状态就会变为waiting，假如另一个线程B进入monitor并且成功完成任务，那它就可以通过notify唤醒WaitSet中的线程。这样的线程调度十分耗费资源，所以Java6以后对sychronized进行了优化。</p><p>锁被分为了 无锁、偏向锁、轻量级锁、重量级锁。锁只能升级，不能降级</p><ul><li>无锁</li></ul><p>无锁就是对资源没有锁，所有线程都可以访问这个资源，这就可能出现两种情况：</p><ol><li>某个线程没有处在多线程情况下，或者线程间没有竞争，那就无需任何保护，让线程任意调度就可以</li><li>资源会被竞争，但是不进行资源锁定，可以通过CAS的方法来进行锁定，只有一个线程可以修改成功，其他修改失败的线程可以进行自旋，直到修改成功</li></ol><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310224809193.png" class><ul><li>偏向锁</li></ul><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310225134175.png" class><p>我们现在给对象加锁，不进行线程间切换，也不用进行资源，我们剋让一个锁只对应一个线程，只要是这个线程过来，就直接把锁交出去我们就认为这个对象偏爱这个锁，这就是偏向锁</p><p>这是如何实现的？</p><p>我们可以好好看看上面那个表，假如锁标志位是01，那就判断倒数第三个bit是否是1，如果是的话，那就说明它是偏向锁，否则就是无锁，如果是偏向锁，就去读取他的线程ID，如果线程ID和当前线程ID不同，那就说明存在锁竞争，那就会锁升级，升级为轻量级锁。</p><ul><li>轻量级锁</li></ul><p>假如线程访问锁时，如果发现那个锁标志位为00.那就说明这是一个轻量级锁</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310225954559.png" class><p>这时候就会在虚拟机栈开辟一个LockRecord的空间，存储对象markword副本以及对象指针，线程会尝试用CAS获取锁，如果获取成功，那就复制对象mark word副本到LockRecord并且将owner指针指向该对象。如果此时其他线程也尝试获取锁，那它就会进行自旋，这里的自旋经过优化为<strong>适应性自旋</strong>，自旋时间不再固定，而是根据上次自旋的时间以及锁的状态来综合评估，一旦自旋线程超过一个，那就会升级为重量级锁</p><ul><li>重量级锁</li></ul><p>这个时候就回到开始读根据monitor来判断锁，这个代价十分昂贵。</p><p><strong>总结</strong></p><p>我们讲解了Java对象的划分，锁的标志位，以及优化后锁升级的步骤、不同状态下如何保证线程安全。</p><p>说了什么算适应性自旋</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310221706087.png&quot; class&gt;

&lt;p&gt;在Java中每个Object，也就是每一个对象都有一把锁。这把锁放在对象头，锁中记录</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信方式</title>
    <link href="http://example.com/2022/03/10/JUC/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/03/10/JUC/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2022-03-10T12:30:59.000Z</published>
    <updated>2022-03-10T13:25:58.887Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讨论一个常见的面试题</p><p>线程间有哪些通信方式？</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do something....</span><br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do some other thing</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyObject object;<br><span class="hljs-comment">//省略构造方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>        object.methodA();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyObject object;<br><span class="hljs-comment">//省略构造方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>        object.methodB();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Run</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br><br>        <span class="hljs-comment">//线程A与线程B 持有的是同一个对象:object</span><br>        <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(object);<br>        <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(object);<br>        a.start();<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们对于两个方法methodA和methodB都进行了synchronized修饰，由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信。</p><h1 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        list.add(<span class="hljs-string">&quot;elements&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyList list;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(MyList list)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                list.add();<br>                System.out.println(<span class="hljs-string">&quot;添加了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyList list;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(MyList list)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">5</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;==5, 线程b准备退出了&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><span class="hljs-keyword">import</span> extthread.ThreadA;<br><span class="hljs-keyword">import</span> extthread.ThreadB;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyList</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyList</span>();<br><br>        <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(service);<br>        a.setName(<span class="hljs-string">&quot;A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(service);<br>        b.setName(<span class="hljs-string">&quot;B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MyList就是去new一个空的List然后提供两个方法，一个是返回它的size，一个是add方法添加元素；</p><p>ThreadA有一个MyList类生成的对象，它的run方法就是循环调用add方法，每次add后都sleep</p><p>ThreadB也有一个MyList类生成的对象，它会去判断list的size</p><p>在主函数里new一个List,同时传给线程A和线程B，然后让它们去开始执行</p><p>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。</p><p>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是：在干别的事情，当有电话来时，响铃通知TA电话来了。</p><h1 id="wait-x2F-notify机制"><a href="#wait-x2F-notify机制" class="headerlink" title="wait&#x2F;notify机制"></a><strong>wait&#x2F;notify机制</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        list.add(<span class="hljs-string">&quot;anyString&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Object lock)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span> (MyList.size() != <span class="hljs-number">5</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;wait begin &quot;</span><br>                            + System.currentTimeMillis());<br>                    lock.wait();<br>                    System.out.println(<span class="hljs-string">&quot;wait end  &quot;</span><br>                            + System.currentTimeMillis());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Object lock)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    MyList.add();<br>                    <span class="hljs-keyword">if</span> (MyList.size() == <span class="hljs-number">5</span>) &#123;<br>                        lock.notify();<br>                        System.out.println(<span class="hljs-string">&quot;已经发出了通知&quot;</span>);<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;添加了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素!&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Run</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>            <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(lock);<br>            a.start();<br><br>            Thread.sleep(<span class="hljs-number">50</span>);<br><br>            <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(lock);<br>            b.start();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解决上面B不断循环的情况，我们可以先去搞一个锁，线程A和B分别拿synchronized锁修饰，线程A要等待条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作。线程B则向list中添加元素，改变list 的size。</p><p>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</p><p>这里用到了Object类的 wait() 和 notify() 方法。</p><p>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait() 放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</p><p>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</p><p>这种方式的一个好处就是CPU的利用率提高了。</p><p>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：<strong>通知过早，会打乱程序的执行逻辑。</strong></p><h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><p>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们来讨论一个常见的面试题&lt;/p&gt;
&lt;p&gt;线程间有哪些通信方式？&lt;/p&gt;
&lt;h1 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h1&gt;&lt;p&gt;这里讲的同步是指多个线程通过synchronized关键</summary>
      
    
    
    
    <category term="JUC" scheme="http://example.com/categories/JUC/"/>
    
    
    <category term="JUC" scheme="http://example.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode236二叉树的最近公共祖先</title>
    <link href="http://example.com/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>http://example.com/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2022-03-10T05:13:34.000Z</published>
    <updated>2022-03-10T06:53:38.639Z</updated>
    
    <content type="html"><![CDATA[<p>今天继续一道关于二叉树的题目，</p><img src="/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220310143712044.png" class><p>这道题要求两个节点的公共祖先，那肯定是自下而上的方法，而在二叉树的遍历操作中，有一种天然的自下而上遍历的方法，那就是回溯的方法。</p><p>我们假设要找的节点为P和Q</p><p>如果当前节点是空节点或者是要寻找的两个节点中的一个，那二话不说直接返回当前节点</p><p>我们可以去先对它的左节点做递归操作，然后对右节点做递归操作，左右节点的递归都会去返回一个节点。分别记为resLeft和resRight.</p><p>然后在对于该节点的操作上，如果刚才得到的resLeft为空，那刚才的P和Q都不在左侧，那就返回resRight</p><p>反之如果resRight.为空，同理与上</p><p>假如都不为空，那说明该节点就是那个最近的根节点，直接返回这个点就可以了！</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，本题的思考过程全部结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天继续一道关于二叉树的题目，&lt;/p&gt;
&lt;img src=&quot;/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode530二叉搜索树的最小绝对差</title>
    <link href="http://example.com/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <id>http://example.com/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</id>
    <published>2022-03-09T15:06:21.000Z</published>
    <updated>2022-03-10T05:15:38.261Z</updated>
    
    <content type="html"><![CDATA[<p>我今天特别有针对性的就想去做一道二叉树遍历有关的题目，然后就遇到了<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a>这道题</p><p>这道题为easy，但我感觉它难度也不算小，这道题如果用一个数字，然后用中序遍历的方法存下有序的数组，最后贪心得出最终答案。</p><p>但我想说的并不是这种方法，而是用纯递归的方法去解决。这道题与常规题目不同的地方在于，它需要自己去创建两个个类属性：</p><ul><li>pre指针</li></ul><p>用于存储上次一遍历的值</p><ul><li>ans</li></ul><p>即最终答案，默认值为Integer.MAX_VALUE;</p><p>我们来分析一下，这道题肯定会用中序遍历的方法</p><img src="/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/image-20220309231520756.png" class><p>假如有这样一个二叉树，中序遍历结果为：1-&gt;2-&gt;3-&gt;4-&gt;6,可以看到这是顺序的，而对于一个节点而言，它的<strong>顺序为小-&gt;中-&gt;大</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">private</span> TreeNode pre;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        midfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">midfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        midfs(root.left);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            ans = Math.min(ans, root.val - pre.val);<br>        &#125;<br>        pre = root;<br>        midfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看这段代码，根据上面这个二叉树它首先回去访问1节点，此时pre节点为null，ans不会改变。这个时候把pre变为当前节点</p><p>第二次它会去访问2节点，此时pre为1，这个时候会进行一次最小值的替换，然后pre换为2，</p><p>接下来访问3节点。。。</p><p>相信大家都已经知道了，这样相较于直接把所有节点放在数组里十分类似，访问顺序都一样。</p><p>最后再提一句，这里的if (pre !&#x3D; null)为什么判断的是pre而不是root？</p><p>因为root上面已经判断过了，pre的判断只是为了防止第一次pre为空的情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我今天特别有针对性的就想去做一道二叉树遍历有关的题目，然后就遇到了&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/&quot;&gt;530. 二叉搜索树的最小绝对差&lt;/a&gt;这道题&lt;/</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
