<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Postgresql常用命令</title>
    <link href="/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/21/utils/Postgresql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> dbuser <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="查看所有用户"><a href="#查看所有用户" class="headerlink" title="查看所有用户"></a>查看所有用户</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \du</span><br></code></pre></td></tr></table></figure><h2 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \password dbuser</span><br>postgres=<span class="hljs-comment"># \q</span><br></code></pre></td></tr></table></figure><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">postgres=# <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">OWNER</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DATABASE</span> exampledb <span class="hljs-keyword">to</span> dbuser;<br>postgres=# \c exampledb;<br>postgres=# <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">OWNER</span> <span class="hljs-keyword">to</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">SEQUENCES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br>postgres=# <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SCHEMA</span> <span class="hljs-built_in">public</span> <span class="hljs-keyword">TO</span> dbuser;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo -u postgres createdb -O dbuser exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \l</span><br></code></pre></td></tr></table></figure><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \c exampledb</span><br></code></pre></td></tr></table></figure><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d</span><br></code></pre></td></tr></table></figure><p>查看表结构</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">postgres=<span class="hljs-comment"># \d user_tab1</span><br></code></pre></td></tr></table></figure><h2 id="常用控制台命令"><a href="#常用控制台命令" class="headerlink" title="常用控制台命令"></a>常用控制台命令</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\password</span>           设置密码。<br><span class="hljs-string">\q</span>                  退出。<br><span class="hljs-string">\h</span>                  查看SQL命令的解释，比如<span class="hljs-string">\h</span> select。<br><span class="hljs-string">\?</span>                  查看psql命令列表。<br><span class="hljs-string">\l</span>                  列出所有数据库。<br><span class="hljs-string">\c</span> [database_name]  连接其他数据库。<br><span class="hljs-string">\d</span>                  列出当前数据库的所有表格。<br><span class="hljs-string">\d</span> [table_name]     列出某一张表格的结构。<br><span class="hljs-string">\du</span>                 列出所有用户。<br><span class="hljs-string">\e</span>                  打开文本编辑器。<br><span class="hljs-string">\conninfo</span>           列出当前数据库和连接的信息。<br></code></pre></td></tr></table></figure><h2 id="基本的-SQL-语句"><a href="#基本的-SQL-语句" class="headerlink" title="基本的 SQL 语句"></a>基本的 SQL 语句</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 创建新表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_tbl(<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>), signup_date <span class="hljs-type">DATE</span>);<br><br># 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_tbl(<span class="hljs-type">name</span>, signup_date) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;2013-12-22&#x27;</span>);<br><br># 查询记录<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> user_tbl;<br><br># 更新数据<br><span class="hljs-keyword">UPDATE</span> user_tbl <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br># 删除记录<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> user_tbl <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;李四&#x27;</span> ;<br><br># 添加字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ADD</span> email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>);<br><br># 更改字段类型<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br><br># 设置字段默认值（注意字符串使用单引号）<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> email <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br><br># 去除字段默认值<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">ALTER</span> email <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br><br># 重命名字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">COLUMN</span> signup_date <span class="hljs-keyword">TO</span> signup;<br><br># 删除字段<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> email;<br><br># 表重命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> user_tbl <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> backup_tbl;<br><br># 删除表<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> backup_tbl;<br><br># 删除库<br>\c hello2;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> hello;<br></code></pre></td></tr></table></figure><p>从上面的命令可以看出基本的 SQL 语句跟 MySQL 是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>utils</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Portal代拨控制流程</title>
    <link href="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Portal-代拨控制流程"><a href="#Portal-代拨控制流程" class="headerlink" title="Portal 代拨控制流程"></a>Portal 代拨控制流程</h2><h3 id="ACCOUNTING-REQUEST"><a href="#ACCOUNTING-REQUEST" class="headerlink" title="ACCOUNTING_REQUEST"></a>ACCOUNTING_REQUEST</h3><p>首先在Linux向portal发送一个包,这里的IP不同命令略有不同，但都大差不差</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;Acct-Status-Type = &#x27;Start&#x27;\nUser-Name = &quot;15291416563&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nNAS-IP-Address = &quot;192.168.0.190&quot;\nAcct-Session-Id = &#x27;00000007202011011620040020d11d00101541&#x27;\nCalling-Station-Id=&#x27;dc-31-d1-4d-8f-8d&#x27; &#x27; | ./radclient -x 10.93.101.196 acct aaa<br></code></pre></td></tr></table></figure><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321135927451.png" class><p>我在这里打了一个断点，</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140128764.png" class><p>可以看到方法要进入handleAccountRequest</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140356314.png" class><p>接下来proxyExecutor调用handleAccountingRequest方法去处理请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321140659221.png" class><p>这是请求处理的过程。</p><p>它首先去获取用户状态，如果状态是开始状态，那就不去处理，如果是结束，那就会调用handleDisconnectRequest方法去结束计费</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141203832.png" class><p>这是大概过程，我都进行了标记</p><p>当handleAccountingRequest方法完成以后，就把response进行参数包装，设置为Code.ACCOUNTING_RESPONSE状态进行标记，Code是个枚举值，里面有很多状态，表示这个请求的类型</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321141451228.png" class><h3 id="ACCESS-REQUEST"><a href="#ACCESS-REQUEST" class="headerlink" title="ACCESS_REQUEST"></a>ACCESS_REQUEST</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &#x27;User-Name = &quot;user02&quot;\nUser-Password = &quot;IoBg5Z&quot;\nFramed-IP-Address = &#x27;192.168.48.20&#x27;\nCalling-Station-Id = &#x27;60F677024072&#x27;&#x27; | ./radclient -x 10.93.101.196 auth aa<br></code></pre></td></tr></table></figure><p>接下来发送一个ACCESS_REQUEST请求</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321142509558.png" class><p>如图断点停在了这里和刚才一样，同一个proxyExecutor的handleAccessRequest来对它进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证使用权请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">handleAccessRequest</span><span class="hljs-params">(RadiusRequest request)</span>&#123;<br>        <span class="hljs-comment">// 把接收到的参数全部保留到attrs</span><br>        List&lt;Attribute&gt; attrs = request.getAttributes();<br>        <span class="hljs-comment">// 提取用户名</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> Attributes.getAttributeValueAsString(attrs, AttributeType.USER_NAME);<br>        <span class="hljs-type">var</span> <span class="hljs-variable">framedIpAddress</span> <span class="hljs-operator">=</span>  Attributes.getInet4Address(Attributes.getFirst(attrs, AttributeType.FRAMED_IP_ADDRESS)).getHostAddress();<br>        logger.info(<span class="hljs-string">&quot;收到认证请求，开始进行绑定 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>        <span class="hljs-keyword">try</span>&#123;<br>            handleDisconnectRequest(request);<br>            <span class="hljs-comment">// 先去找到一个可用session，相当于new，但过程较为繁琐</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> onlineSessionService.findOneAvailableSession();<br>            logger.info(<span class="hljs-string">&quot;find one available session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>            <span class="hljs-comment">// 如果session可用</span><br>            <span class="hljs-keyword">if</span> (StringUtils.hasText(session.getExternalIp()))&#123;<br>                <span class="hljs-comment">// 添加用户内网IP绑定关系成功</span><br>                <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(<br>                    vppRepository.addIpMappings(framedIpAddress, session.getExternalIp()))) &#123;<br>                    <span class="hljs-comment">// 给session绑定数据</span><br>                    session.setEnable(<span class="hljs-literal">true</span>);<br>                    session.setWenetAccount(username);<br>                    session.setInneralIp(framedIpAddress);<br>                    session.setUpdateAt(OffsetDateTime.now());<br>                    <span class="hljs-comment">// 存储用户session</span><br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;用户上线成功, session = [&#123;&#125;] ---&gt; [&#123;&#125;]&quot;</span>, session, OffsetDateTime.now());<br>                    <span class="hljs-keyword">return</span> PROXY_SUCCESS;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 绑定失败</span><br>                    session.setEnable(<span class="hljs-literal">false</span>);<br>                    onlineSessionRepository.save(session);<br>                    logger.info(<span class="hljs-string">&quot;vpp nat 绑定失败 ----&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;Online session 无可用会话 ---&gt; [&#123;&#125;]&quot;</span>, OffsetDateTime.now());<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> PROXY_FAILURE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是处理过程，我都加了相应的注释</p><img src="/2022/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Portal%E4%BB%A3%E6%8B%A8%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/image-20220321143001394.png" class><p>当对请求处理完成以后会对response进行包装就结束了</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概念</title>
    <link href="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h3 id="操作系统的功能与目标"><a href="#操作系统的功能与目标" class="headerlink" title="操作系统的功能与目标"></a>操作系统的功能与目标</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220318093513660.png" class><p>操作系统作为一个系统资源的管理者，它主要包含</p><p><strong>处理器管理</strong></p><p><strong>存储器管理</strong></p><p><strong>设备管理</strong></p><p><strong>文件管理</strong></p><p><strong>用户接口</strong> </p><p><strong>网络与通信管理</strong> </p><p>以上六个部分</p><h3 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h3><p><strong>并发性：指两个或两个以上的事件或活动在同一时间间隔内发生 。并发性能够有效地改善系统资源的利用率，提高系统的效率。</strong> </p><p><strong>共享性：共同使用系统中的资源。</strong></p><p> （1）互斥使用方式（2）同时使用方式</p><p><strong>虚拟性：指将一个物理实体映射为多个逻辑实体。</strong> </p><p><strong>不确定性：程序运行次序的不确定性，程序多次运行所花费时间的不确定性</strong></p><p>总结下来就是并发、共享、虚拟、异步</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件在宏观上是同时发生的，但在微观上是交替发生的</p><p>并行：指多个事件在同一时刻内发生</p><p>比如说一个人要同时和两个人约会，但是现在有不同的约会方法</p><p>并行：同一时刻同时和一号二号一起约会</p><p>并发：宏观上看起来一天和两个人约会，但是它第一个小时和一号女友约会，第二个小时和二号女友约会，第三个小时又和一号女友约会，如此往复。在微观上看：他每个时刻只和一个人约会</p><p>操作系统的并发性指计算机系统中同时存在着多个运行的程序</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>一共有两者资源共享方式：互斥共享和同时共享</p><ul><li>互斥共享</li></ul><p>虽然可以提供给多个进程使用，但<strong>一个时间段只允许一个进程访问该资源</strong></p><p>比如视频聊天在同一时刻，摄像头只能给一个app</p><ul><li>同时共享</li></ul><p>系统中某些资源，允许一个时间段内由多个进程同时对它们进行访问，这里的“同时”在微观上可能是交替对资源进行访问的</p><p>使用QQ发送文件A，微信发送文件B。宏观上看，两边都在同时读取和发送文件，这说明两个进程都在访问硬盘资源，在微观上看，两个进程是在交替访问的 </p><h3 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h3><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320183708220.png" class><p>我们知道：有的用户输入的指令CPU是不可以去执行的，因为它可能操作了某些重要的内存，那CPU如何只能指令能不能执行？</p><p>处理器状态分为用户态（目态）和核心态（管态），管态可以执行任何指令，目态只能执行非特权指令</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320184206096.png" class><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>我们知道如果操作系统同一时刻只能执行一个任务，那它的利用率就会特别低，那如何实现并发执行呢？</p><p>CPU同一时刻只能执行一个任务，那当一个任务用了一定时间片以后，就让操作系统给CPU发出<strong>中断信号</strong>，切换为<strong>核心态</strong>，对中断进行处理</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320190323326.png" class><ol><li>中断发生时，CPU立刻进入核心态</li><li>中断发生时，当前进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>用户态到核心态的变化是通过<strong>中断</strong>来实现的，且中断是<strong>唯一</strong>途径。核心态到用户态是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统作为用户和计算机硬件之间的接口要向上面提供一些简单易用的服务。包括命令接口和程序接口，其中程序接口由一组<strong>系统调用</strong>组成。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320192458386.png" class><p>系统调用是操作系统给程序员使用的接口，是一种特殊的函数。系统中各种共享资源都由操作系统统一掌管，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统发出请求，由操作系统<strong>代为完成</strong>，这样就可以保证系统稳定性。</p><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193135322.png" class><img src="/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20220320193450621.png" class><p>至此有关操作系统的前置东西大概讲了讲，后面会进行每个部分的具体讲解</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP</title>
    <link href="/2022/03/19/Spring/SpringAOP/"/>
    <url>/2022/03/19/Spring/SpringAOP/</url>
    
    <content type="html"><![CDATA[<p>AOP即面向切编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分耦合度降低，提高程序的可重用性，提高开发效率</p><p>将日志记录、性能统计、安全控制、事务处理、异常处理从业务逻辑划分划分处理</p><p>这个可以体现软件设计的<strong>开闭原则</strong>（软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”[<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99#cite_note-1">1]</a>，这意味着一个实体是允许在不改变它的<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>的前提下变更它的行为。）即不修改源代码方式添加新的功能</p><h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><ol><li>AOP底层使用动态代理</li></ol><p>第一种 ：有接口的情况</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319230831202.png" class><p>创建接口实现类的方式实现代理对象</p><ol start="2"><li>没有接口的情况</li></ol><img src="/2022/03/19/Spring/SpringAOP/image-20220319231306571.png" class><p>创建当前类子类的代理对象</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ol><li>连接点</li></ol><p>类里有哪些方法可以被增强，这些方法就称为连接点</p><ol start="2"><li>切入点</li></ol><p>实际被增强的方法</p><ol start="3"><li>通知（增强）</li></ol><p>实际增强的逻辑部分被称为通知</p><ul><li>前置通知</li></ul><p>方法执行之前通知</p><ul><li>后置通知</li></ul><p>方法执行之后通知</p><ul><li>环绕通知</li></ul><p>执行前后头通知</p><ul><li>异常通知</li></ul><p>方法执行异常会通知</p><ul><li>最终通知</li></ul><p>不管有没有异常都会执行，相当于finally</p><ol start="4"><li>切面</li></ol><p>是动作，把通知应用到切入点的过程称为切面</p><p>spring基于aspectJ 实现AOP操作</p><img src="/2022/03/19/Spring/SpringAOP/image-20220319232745557.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233036476.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233155028.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233338050.png" class><img src="/2022/03/19/Spring/SpringAOP/image-20220319233409784.png" class><p>至此关于spring的使用过程已经讲解结束，其实我很早之前就使用过AOP，这里只是挑了自己感兴趣的地方看了看，如果浪费了大家的时间，希望大家理解</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode105从前序与中序遍历序列构造二叉树</title>
    <link href="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>今天分享一道mid的二叉树题目：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">从前序与中序遍历序列构造二叉树</a>，每次遇到二叉树题目的时候，一定一定一定要先想想递归的思想</p><p>什么是递归的思想，递归一般要考虑如何去分解问题，如何把分解的问题结果进行合并，由于我们只讲本道题目，所以递归的思想我就不过多赘述。</p><p>说实话，这道题目一直是我的梦魇，我看过这道题很多遍了，每次都手足无措，可能是因为我的心里就不想去做它，今天看了题解，可算是明白这道题怎么解了。不多说了，我们之间进入题解</p><p>前序遍历的结果是: [1,2,4,5,3,6,7]<br>中序遍历的结果是: [4,2,5,1,6,3,7]<br>前序遍历的特点是， 根节点 始终出现在数组的第一位，而中序遍历中 根节点 出现在数组的中间位置，这里的中间不是绝对中间，而是相对中间。</p><p>根据上面给出的两个数组，首先我们就可以拼出 <code>根节点</code>，它就是 <code>1</code>。在中序遍历数组里面，1的左侧就是左子树全部节点，1的右侧就是右子树的全部节点。</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232050939.png" class><p>如图，还有值得一提的是：两个数组的长度一定一定是相等的。</p><p>这道题是一个典型的<strong>分治</strong>算法</p><p>所以我们现在就去new一个节点，它的值为1，那它的左子树和右子树是什么呢？这就交给它的两个小弟吧（递归思想）。那现在问题应该如何去分解呢？</p><p>我们把两个数组分为以下四部分</p><img src="/2022/03/17/Algo/LeetCode105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220317232743037.png" class><p>in_left为中序遍历的左侧全部节点，in_right为中序遍历右侧全部节点</p><p>pre_left为前序遍历的左侧全部节点，pre_right为前序遍历右侧全部节点</p><p>然后我们现在当前树的根节点就是pre_order的第一个节点，它的左子树就交给buildTree(pre_left, in_left);右子树就交给buildTree(pre_right, in_right);</p><p>最后返回根节点就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-comment">// 这里两个数组应该是等长的</span><br>        <span class="hljs-keyword">if</span> (preorder.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[i] == preorder[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-type">int</span>[] pre_left = Arrays.copyOfRange(preorder, <span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>);<br>                <span class="hljs-type">int</span>[] pre_right = Arrays.copyOfRange(preorder, i+<span class="hljs-number">1</span>, preorder.length);<br>                <span class="hljs-type">int</span>[] in_left = Arrays.copyOfRange(inorder, <span class="hljs-number">0</span>, i);<br>                <span class="hljs-type">int</span>[] in_right = Arrays.copyOfRange(inorder, i+<span class="hljs-number">1</span>, inorder.length);<br>                node.left = buildTree(pre_left, in_left);<br>                node.right = buildTree(pre_right, in_right);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上完整的程序，值得一提的是Arrays.copyOfRange（arr, start, end）在复制数组的时候是[start : end)，也就是前闭后开的结果</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>二叉树</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode198打家劫舍</title>
    <link href="/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2022/03/17/Algo/LeetCode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<p>今天来分享一道简单的动态规划题目：<a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></p><p>动态规划有两大注意点：</p><ol><li>一个原问题是建立在子问题的基础之上，所以找出两者关系至关重要</li><li>用空间换时间，把子问题的答案用一个空间记录下来，在这样子原问题就不需要重复计算了</li></ol><p>对于这个问题我们假设：dp[i] 代表前 i 个房子在满足条件下的能偷窃到的最高金额。我们现在的目的是想找到的dp[n]最大，那让我们现在想想dp[n+1]与dp[n]的关系。</p><p>假设第 n 间没有被偷，那么此时 dp[n]&#x3D;dp[n−1] ，此时 dp[n+1] &#x3D; dp[n] + num &#x3D; dp[n-1] + num ，即两种情况可以 合并为一种情况 考虑；<br>假设第 n 间被偷，那么此时 dp[n+1]&#x3D;dp[n]+num 不可取 ，因为偷了第 n 间就不能偷第 n+1 间。</p><p>得到转移方程 dp[n+1] &#x3D; max(dp[n],dp[n-1]+num)</p><p>所以我们只需要用两个值分别记录dp[n-1]和dp[n]就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 注意这里pre为dp[n-1], cur为dp[n];</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> cur;<br>            cur = Math.max(pre + nums[i], cur);<br>            pre = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后可以看到其实解题过程十分简单，并不是所有的动态规划都需要去创建一个与原数组等长的数组</p><p>同时我们也可以得出来：要分析子问题和原问题的关系尤为重要</p><p>在这里多插一句：我们常认为动态规划和贪心算法有某种关联，其实贪心算法就像是一种特殊的动态规划算法，因为当可以贪心的时候，它一定被证明过有某种东西可贪，所以如果想使用贪心算法，那证明过程一定十分重要</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于radius的认证过程分析</title>
    <link href="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="预讲"><a href="#预讲" class="headerlink" title="预讲"></a>预讲</h2><p>在了解认证过程之前先了解一些基础的东西</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201426576.png" class><p>如图radius服务有三个部分</p><ul><li>Users：用于存储用户信息（如用户名、密码以及使用的协议、IP地址等配置信息）。</li><li>Clients：用于存储RADIUS客户端的信息（如共享密钥、IP地址等）。</li><li>Dictionary：用于存储RADIUS协议中的属性和属性值含义的信息。</li></ul><p>认证过程如图：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201529044.png" class><ol><li>当用户接入网络时，用户发起连接请求，向RADIUS客户端（即设备）发送用户名和密码。</li><li>RADIUS客户端向RADIUS服务器发送包含用户名和密码信息的认证请求报文。</li><li>RADIUS服务器对用户身份的合法性进行检验：<ul><li>如果用户身份合法，RADIUS服务器向RADIUS客户端返回认证接受报文，允许用户进行下一步动作。由于RADIUS协议合并了认证和授权的过程，因此认证接受报文中也包含了用户的授权信息。</li><li>如果用户身份不合法，RADIUS服务器向RADIUS客户端返回认证拒绝报文，拒绝用户访问接入网络。</li></ul></li><li>RADIUS客户端通知用户认证是否成功。</li><li>RADIUS客户端根据接收到的认证结果接入&#x2F;拒绝用户。如果允许用户接入，则RADIUS客户端向RADIUS服务器发送计费开始请求报文。</li><li>RADIUS服务器返回计费开始响应报文，并开始计费。</li><li>用户开始访问网络资源。</li><li>（可选）在使能实时计费功能的情况下，RADIUS客户端会定时向RADIUS服务器发送实时计费请求报文，以避免因付费用户异常下线导致的不合理计费。</li><li>（可选）RADIUS服务器返回实时计费响应报文，并实时计费。</li><li>用户发起下线请求，请求停止访问网络资源。</li><li>RADIUS客户端向RADIUS服务器提交计费结束请求报文。</li><li>RADIUS服务器返回计费结束响应报文，并停止计费。</li><li>RADIUS客户端通知用户访问结束，用户结束访问网络资源。</li></ol><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>下面开始分析过程:</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316201718841.png" class><p>上的抓包time 为相对时间，source 为源IP，destination 为目的IP protocol为数据包所对应的协议类型，info为包的大概行为 </p><p>如图为分析过程，下面需要先去定位三个东西：users-&gt;IP &#x2F; radius server-&gt;IP &#x2F; radius clients-&gt;IP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204705680.png" class><p>首先看第60个包这是一个access-reqest, 应该是用户请求上网数据包，我们先来看看包内容</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316204837737.png" class><p>里面包括用户名、密码等内容，大概可以确定userIP—61.174.80.81,client—-172.21.5.2，server—-172.30.5.255</p><p>ip.addr &#x3D;&#x3D; 61.174.80.81 </p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230353885.png" class><p>对IP过滤以后发现这个用户的请求被拒绝过，<strong>拒绝的具体过程应该在No.60~329</strong>之间</p><p>接下来继续过滤</p><p>(ip.dst &#x3D;&#x3D; 172.21.5.2 &amp;&amp; ip.src &#x3D;&#x3D; 172.30.5.225) || (ip.dst &#x3D;&#x3D; 172.30.5.225 &amp;&amp; ip.src &#x3D;&#x3D; 172.21.5.2)</p><p>我把包限制为只能在client和server之间传输</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316230522064.png" class><p>接下来继续看，刚才的那个用户61.174.80.81</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316214832327.png" class><p>可以看到他和client除了access类型还有accounting-request类型，accounting这应该是计费数据包，其中每个包都会有回复</p><p>接下来对流进行追踪</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231040036.png" class><p>我不知道为什么这个用户的验证会如此频繁，按道理只有登录请求一次就可以了，但是这个access-request却异常多，可能是在用户上网过程中，这个还在不断验证</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316222552133.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316231505350.png" class><p>除了 access-request还有account-request，这应该是计费请求，计费请求通常回复非常快，中间很少插有其他用户的包。</p><p>接下来对于包的内容进行分析</p><h2 id="包分析"><a href="#包分析" class="headerlink" title="包分析"></a>包分析</h2><p>一下均为让radius数据包，因为ICMP或TCP包数量极少且我在上一篇文章就有讲解过</p><h3 id="access-request"><a href="#access-request" class="headerlink" title="access-request"></a>access-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215313010.png" class><p>请求的内容还是比较多的，有用户名、CHAP(挑战握手协议)密码.NAS(<strong>网络附属存储</strong>)</p><p>端口、IP。服务类型。我觉得最重要的应该是acct-session-Id。用户session已经被存储在服务端了。</p><h3 id="access-reject"><a href="#access-reject" class="headerlink" title="access-reject"></a>access-reject</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316215749901.png" class><p>应该是拒绝策略</p><p>包括用户名、发送的类型，6应该表示拒绝，回复信息、身份信息验证信息</p><h3 id="access-accept"><a href="#access-accept" class="headerlink" title="access-accept"></a>access-accept</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220117502.png" class><p>可以看到一旦认证成功返回的信息还是比较多的。</p><p>返回信息包括用户名，服务类型（应该是校园网套餐类型），成帧协议，session过期时间，用户临时间隔下面还有一些设备型号，应该是设备供应商</p><h3 id="accounting-request"><a href="#accounting-request" class="headerlink" title="accounting-request"></a>accounting-request</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316220936712.png" class><p>可以看到内容还是比较多的，就讲讲Acct开头的吧，主要就是一些用户状态，延迟时间、输出输出八进制数、session id、session有效时间端口等待，和上面还是比较相似的。</p><h3 id="accounting-response"><a href="#accounting-response" class="headerlink" title="accounting-response"></a>accounting-response</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%85%B3%E4%BA%8Eradius%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/image-20220316223042147.png" class><p>这个回复的数据包信息还是比较少的，只有用户session-id和代理状态</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark抓包分析</title>
    <link href="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们讲了如何用wireshark抓包并且进行过滤，但是抓到包不会看这是没有用的，这节课我们讲如何对不同种类的包进行分析。</p><p>下面我将对不同种类的包进行讲解</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>我们知道，arp协议工作于数据链路层，是为了完成IP地址与mac地址的转化，即根据IP地址来找到mac地址</p><p>可以看到我筛选了arp种类的包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316164021419.png" class><p>Source为发送源，Info为具体的这个包功能的介绍，翻译为：谁有xxxip,我是xxxIP</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170122119.png" class><p>这是包的具体内容，我们依次展开进行讲解</p><h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170208880.png" class><h3 id="Linux-cooked"><a href="#Linux-cooked" class="headerlink" title="Linux cooked"></a>Linux cooked</h3><p>这里记载了包的发送或接收时间、包的id号、种类等等</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316170504076.png" class><p>这里记载了包的源地址的网络类型（address type），这里是指以太网、源地址长度(adress length)、源（source）</p><h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316171056031.png" class><p>hardware type : 网络类型，这里指以太网</p><p>protocol type : 表示arp包所映射地址的协议类型，这里是IP v4</p><p>opcode：包的类型，这是一个请求报文</p><p>send mac Adress: 发送方的mac地址，</p><p>send ip Adress: 发送方IP</p><p>target mac Adress: 接收方mac地址，这里还不知道，所以全部为0</p><p>target IP adress: 接收方IP地址</p><p>下面我们找一个回复报文的例子</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172158040.png" class><p>可以看到，其实基本一致，就是内容略有不同</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP工作于网络层，它负责传递一些错误消息的报文和一些需要传递的东西，比如说：哥们儿，包丢了xxx。我们常见的ping命令。就是icmp报文。</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316172534725.png" class><p>接下来我们筛选一批ICMP包</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173129471.png" class><h4 id="Internet-Portocol"><a href="#Internet-Portocol" class="headerlink" title="Internet Portocol"></a>Internet Portocol</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173509875.png" class><p>这里和arp基本相似，就是一些源IP，目的IP之类的。</p><h3 id="Internet-Control"><a href="#Internet-Control" class="headerlink" title="Internet Control"></a>Internet Control</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173804613.png" class><p>这里就是一些校验码之类的</p><h4 id="User-Datagram"><a href="#User-Datagram" class="headerlink" title="User Datagram"></a>User Datagram</h4><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174024218.png" class><p>这里是源端口与目的端口</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316173924969.png" class><p>这里就是十六进制信息</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS是域名解析协议，就是把具体的url转化为IP，接下来我们抓包试试看</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316174642420.png" class><p>可以看到，这里有很多包，info里有详细的内容，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175152003.png" class><p>可以看到UDP的端口默认53，打到DNS服务器51132端口</p><h3 id="Domain-Name"><a href="#Domain-Name" class="headerlink" title="Domain Name"></a>Domain Name</h3><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316175935998.png" class><p>这里的Question是问题是指问题数目，有时候会访问多个IP</p><p>RRS: 回答数</p><p>authority RRS： 授权记录 </p><p>ADDITIONAL RRS: 附加记录</p><p>下面我们看看query和answears</p><p>这个分别是查询和回复报文</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180135125.png" class><p>&#x2F;</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180054451.png" class><p>可以看到：这个查询和回复十分明了，我们就不进行讲解了</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>如下图，为一些TCP的报文段</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180523773.png" class><p>可以看到，TCP请求种类繁多</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316180734368.png" class><p>我们可以右键一个包，然后点击追踪stream流，就可以把和它相关的包都给找出来</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181039224.png" class><p>如下：</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181128838.png" class><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316181954063.png" class><p>可以看到：这里记录了源端口与目的端口，</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182202815.png" class><p>如图为三次握手的具体过程</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182359117.png" class><p>可以看到，这里对上图进行了完美诠释从请求号到请求报文段都是如此</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182655126.png" class><p>如图对HTTP报文进行分析</p><img src="/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90/image-20220316182753793.png" class><p>这里就是一些很常规的请求行、请求头、请求尾的内容。这里不同的同学可以去看看HTTP协议</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark抓包基础</title>
    <link href="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>这是<a href="https://www.wireshark.org/#download">下载路径</a>，这里不作讲解，我们直接打开软件如图：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162610586.png" class><p>可以看到可选项非常多，我们重点关注</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162702297.png" class><p>选择WLAN就可以，表示无线网连接</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315162954778.png" class><p>双击后如图，可以看到现在有非常多的数据包正在进行传输，</p><p>点击左侧的那个蓝色小按钮可以看到如下内容：</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163150380.png" class><p>点击管理显示过滤器</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315163804075.png" class><p>如图，左侧为自定义的名称，右侧为一些过滤条件，关于过滤条件我会细讲</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>表达式组合</p><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315164228353.png" class><h3 id="针对ip"><a href="#针对ip" class="headerlink" title="针对ip"></a>针对ip</h3><ul><li>对源ip地址过滤</li></ul><p>ip.src &#x3D;&#x3D; 192.168.0.1</p><ul><li>对目的地址过滤</li></ul><p>ip.dst &#x3D;&#x3D; 192.168.0.1</p><ul><li>对源地址或者目的地址进行过滤</li></ul><p>ip.addr &#x3D;&#x3D; 192.168.0.1</p><ul><li>如果想排除以上的数据包，只需要将其用括号囊括，然后使用 “!” 即可</li></ul><p>!(ip.addr &#x3D;&#x3D; 192.168.0.1)</p><h3 id="针对协议"><a href="#针对协议" class="headerlink" title="针对协议"></a>针对协议</h3><p><strong>注意！！！！！</strong>这里的协议都是小写，不要用大写</p><ul><li>获某种协议的数据包，表达式很简单仅仅需要把协议的名字输入即可</li></ul><p>http</p><ul><li>捕获多种协议的数据包</li></ul><p>http or telnet</p><ul><li>排除某种协议的数据包</li></ul><p>not arp   或者   !tcp</p><h3 id="针对端口"><a href="#针对端口" class="headerlink" title="针对端口"></a>针对端口</h3><ul><li>捕获某一端口的数据包（以tcp协议为例）</li></ul><p>tcp.port &#x3D;&#x3D; 80</p><ul><li>捕获多端口的数据包，可以使用and来连接，下面是捕获高于某端口的表达式（以udp协议为例）</li></ul><p>udp.port &gt;&#x3D; 2048</p><h3 id="针对长度和内容的过滤"><a href="#针对长度和内容的过滤" class="headerlink" title="针对长度和内容的过滤"></a>针对长度和内容的过滤</h3><p>针对长度的过虑（这里的长度指定的是数据段的长度）</p><p>udp.length &lt; 20</p><p>http.content_length &lt;&#x3D;30</p><h3 id="针对url的过滤"><a href="#针对url的过滤" class="headerlink" title="针对url的过滤"></a>针对url的过滤</h3><p>http.request.uri matches “user” (请求的uri中包含“user”关键字的)</p><h3 id="针对http请求的一些过滤实例"><a href="#针对http请求的一些过滤实例" class="headerlink" title="针对http请求的一些过滤实例"></a>针对http请求的一些过滤实例</h3><ul><li>过滤出请求地址中包含“user”的请求，不包括域名；</li></ul><p>http.request.uri contains “User”</p><ul><li>精确过滤域名</li></ul><p>http.host&#x3D;&#x3D;baidu.com</p><ul><li>模糊过滤域名</li></ul><p>http.host contains “baidu”</p><ul><li>过滤请求的content_type类型</li></ul><p>http.content_type &#x3D;&#x3D;”text&#x2F;html”</p><ul><li>过滤http请求方法</li></ul><p>http.request.method&#x3D;&#x3D;”POST”</p><ul><li>过滤tcp端口</li></ul><p>http &amp;&amp; tcp.port&#x3D;&#x3D;80 or tcp.port&#x3D;&#x3D;5566</p><ul><li>过滤http响应状态码</li></ul><p>http.response.code&#x3D;&#x3D;302</p><ul><li>过滤含有指定cookie的http数据包</li></ul><p>http.cookie contains “userid”</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><img src="/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Wireshark%E6%8A%93%E5%8C%85%E5%9F%BA%E7%A1%80/image-20220315173626612.png" class><p>遇到问题了…</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础使用</title>
    <link href="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文章主要讲解docker的安装、基础命令以及容器数据卷配置等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>环境：Ubuntu 20.04</p></blockquote><p>**注意:**所有安装过程最好在root权限下进行</p><p>首先，更新软件包索引，并且安装必要的依赖软件，来添加一个新的 HTTPS 软件源：</p><figure class="highlight cmd"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cmd">sudo apt update<br>sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br></code></pre></td></tr></table></figure><p>使用下面的 <code>curl</code> 导入源仓库的 GPG key：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -fsSL https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/u</span>buntu/gpg | sudo apt-key add -<br></code></pre></td></tr></table></figure><p>将 Docker APT 软件源添加到你的系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br></code></pre></td></tr></table></figure><p>现在，Docker 软件源被启用了，你可以安装软件源中任何可用的 Docker 版本。</p><p><strong>注意</strong></p><p>如果在 <code>/etc/docker</code>目录下没有 <code>daemon.json</code>就去自行创建</p><p>先运行命令</p><p><code>touch daemon.json</code></p><p>然后填写以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;192.168.2.2:8080&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;oom-score-adjust&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1000</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;exec-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://ucjisdvf.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;overlay2&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;storage-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>     <span class="hljs-attr">&quot;max-size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100m&quot;</span><span class="hljs-punctuation">,</span> <br>     <span class="hljs-attr">&quot;max-file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span> <br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;data-root&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/docker&quot;</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我这里安装了最新的Docker版本，如果有想安装指定版本的的可以自行查看</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt <span class="hljs-keyword">update</span><br>sudo apt install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>使用以下命令开启docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service docker <span class="hljs-literal">start</span> <br></code></pre></td></tr></table></figure><p>一旦Docker 服务将会自动启动。你可以输入下面的命令，验证它：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl status docker</span><br></code></pre></td></tr></table></figure><p>输出将会类似下面这样：</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315134519801.png" class><p>如果你想阻止 Docker 自动更新，锁住它的版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo apt-mark hold docker-ce<br></code></pre></td></tr></table></figure><h3 id="非root用户执行docker"><a href="#非root用户执行docker" class="headerlink" title="非root用户执行docker"></a>非root用户执行docker</h3><p>默认情况下，只有 root 或者 有 sudo 权限的用户可以执行 Docker 命令。</p><p>想要以非 root 用户执行 Docker 命令，你需要将你的用户添加到 Docker 用户组，该用户组在 Docker CE 软件包安装过程中被创建。想要这么做，输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p><code>$USER</code>是一个环境变量，代表当前用户名。</p><p>登出，并且重新登录，以便用户组会员信息刷新。</p><h3 id="验证安装过程"><a href="#验证安装过程" class="headerlink" title="验证安装过程"></a>验证安装过程</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker container <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>如果本地没有该镜像，这个命令将会下载测试镜像，在容器中运行它，打印出 “Hello from Docker”，并且退出。</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135323553.png" class><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315135918749.png" class><h3 id="daemon-操作docker服务"><a href="#daemon-操作docker服务" class="headerlink" title="daemon(操作docker服务)"></a>daemon(操作docker服务)</h3><p>启动</p><p>service docker start </p><p>关闭</p><p>service docker start </p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140243394.png" class><p>查看状态</p><p>service docker status</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140357355.png" class><p>重启</p><p>service docker restart</p><p>开机自启动</p><p>sudo systemctl enable docker</p><h3 id="image-操作镜像"><a href="#image-操作镜像" class="headerlink" title="image(操作镜像)"></a>image(操作镜像)</h3><p>docker image 查看本地镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315140919401.png" class><p>可以看到我这里啥都没有，不用担心啊</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>docker searck xxx</p><p>xxx为要搜索的镜像</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141121723.png" class><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>docker pull pro:ver</p><p>pro为要下载的东西;ver即version即版本号，默认为最高版本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315141515632.png" class><p>如图redis已经下载好了</p><p>可以在<a href="https://hub.docker.com/%E6%90%9C%E7%B4%A2%E9%9C%80%E8%A6%81%E7%9A%84%E7%89%88%E6%9C%AC">https://hub.docker.com/搜索需要的版本</a></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>与下载类似</p><p>docker rmi pro:ver</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315142128410.png" class><p>docker rmi IMAGE ID</p><p>即加上IMAGE ID 也可以</p><h3 id="container-操作容器"><a href="#container-操作容器" class="headerlink" title="*container(操作容器)"></a>*container(操作容器)</h3><p>我们上节已经看过如何创建镜像了，把多个镜像放在一个容器里面就是我们想要的环境了，所以说能操作容器至关重要</p><p>docker run -i -t –name&#x3D;springboot2.3 redis &#x2F;bin&#x2F;bash</p><p>-i表示一直运行容器</p><p>-t是为了让我们去接受后续的命令</p><p>– name 是起名字</p><p>redis表示当前需要加载的东西，在这里我加了redis，可以在:后面加版本，比如redis:5.0</p><p>&#x2F;bin&#x2F;bash表示打开运行脚本</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315143743403.png" class><p>可以看到这里的前缀已经改变了，这表示此时我们已经进入容器内部</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144108011.png" class><p>这里可以看到，docker内部其实与Linux十分相似</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144203061.png" class><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>docker ps -a</p><p>-a表示展示也历史容器，如果不加a就只展示当前容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144337598.png" class><h4 id="创建（守护式–推荐）"><a href="#创建（守护式–推荐）" class="headerlink" title="创建（守护式–推荐）"></a>创建（守护式–推荐）</h4><p>docker run -i -d –name&#x3D;springboot2.3 </p><p>这里把-t改成了-d,表示后台打开docker,这样docker会一直运行，不会因为我们exit容器就消失了</p><p>这里可以使用docker ps -a查看</p><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>docker exec -it springboot2.3 &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315144916932.png" class><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>docker start name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145341070.png" class><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p>docker stop name</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315145217330.png" class><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p>docker rm name</p><p>这里的删除不能删除正在运行的容器，最好先把它停止后再运行</p><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>我们来思想一个问题</p><ul><li>docker删除后，数据是否还在？</li></ul><p>我们知道，一旦docker部署，数据都存储再容器里，此时数据就会消失，这太糟糕了</p><ul><li>docker和外部机器可以直接交换文件嘛？（docker和Linux主机）</li></ul><p>不可以</p><ul><li>容器之间直接数据交互可以吗</li></ul><p>不可以</p><p>以上三个问题引出了很多问题，比如一旦docker用不了，那数据就没了，数据不能相互交互。。。那该怎么完成呢？</p><p><strong>容器数据卷</strong></p><p>数据卷是宿主机中的一个目录或文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315150325837.png" class><p>相当于容器和数据卷的数据相互同步，这样上面三个问题就迎刃而解，一个数据卷可以被多个容器挂在，一个容器可以被挂载多个数据卷</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>docker run …  -v 宿主机目录（文件）：容器内目录（文件）</p><ul><li>目录必须是绝对路径</li><li>目录不存在就会自动创建</li><li>可挂载多个数据卷</li></ul><p>docker run -it –name&#x3D;c1 -v &#x2F;root&#x2F;data:&#x2F;root&#x2F;data_container redis &#x2F;bin&#x2F;bash</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151047744.png" class><p>查看容器内文件</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151255297.png" class><p>挂载多个容器</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315151729896.png" class><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><ul><li>多个容器进行数据交换</li></ul><p>可以让多个容器挂载一个数据卷，实现间接共享，但这样十分麻烦，我们一般不用，推荐使用容器数据卷</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152209873.png" class><p>如图：c3就为数据卷容器</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ol><li>先配置c3</li></ol><p>docker run -it –name&#x3D;c3 -v &#x2F;volume redis</p><img src="/2022/03/15/Docker/Docker%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/image-20220315152649165.png" class><ol start="2"><li>创建c1 &amp; c2,</li></ol><p>docker run -it –name&#x3D;c1 –volumes-from c3 redis </p><p>docker run -it –name&#x3D;c2 –volumes-from c3 redis </p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode225+232栈与队列</title>
    <link href="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <url>/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>今天有点累，我想给自己放个假，就只分享两道题目吧。<br>这两道题有很大的相似性，关于栈与队列的相互转化，我就把他们放在一起了</p><h4 id="用栈实现队列-amp-用队列实现栈"><a href="#用栈实现队列-amp-用队列实现栈" class="headerlink" title=" 用栈实现队列&amp; 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/"> 用栈实现队列</a>&amp;<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/"> 用队列实现栈</a></h4><p>首先我们要先明白栈与队列有什么区别</p><h2 id="栈的特性"><a href="#栈的特性" class="headerlink" title="栈的特性"></a>栈的特性</h2><p><strong>先入后出，后入先出</strong></p><p>我相信大家都知道手枪的弹夹是什么样子</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314232350372.png" class><p>如图我们把它理解为一个弹夹,按顺序压入 1-&gt;2-&gt;3-&gt;4 一共四个子弹</p><p>那现在我们打出子弹的顺序是什么样子呢？那肯定是4-&gt;3-&gt;2-&gt;1啦，你这么聪明肯定知道哈哈😄</p><p>这就是栈，先入后出啦</p><h2 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h2><p><strong>先入先出，后入后出（FIFO）</strong></p><p>现在我们设想一下我们平时在餐厅买饭的场景，1-&gt;2-&gt;3-&gt;4排队按顺序进入餐厅前台点餐，如下图：</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315001104611.png" class><p>现在点餐完成后依次出去，这样出去的顺序就是1-&gt;2-&gt;3-&gt;4,与进来的顺序一致，这就是队列的特性了，你一定可以理解！</p><p>接下来我们先来讲如何用两个栈实现一个队列</p><h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><p>如图我们先给其中一个栈压入四个元素</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314233455839.png" class><p>现在我们想让两个栈相互配合，弹出最先进来的元素，怎么做呢？</p><p>首先，按照实现队列的先入先出思想，我们应该弹出的应该是1，那怎么弹出1呢？</p><p>直接把stack1的元素全部放入stack2里，然后弹出1就可以啦！</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314233925963.png" class><p>如上图所示为弹出过程</p><p>接下来我们再压入元素，和以前一样，我们直接压入stack1就可以啦，假如我们压入了5和6.</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314234112759.png" class><p>如果现在我们再想弹出元素该怎么弹出呢？</p><p>结果很明显，直接弹出stack2的元素就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>接下来我们总结一下思想：</p><p>只要是压入元素，我们之间压入stack1就可以</p><p>如果要弹出元素，我们先看看stack2是否为空</p><ul><li>如果不为空</li></ul><p>直接弹出stack2的最上面元素</p><ul><li>如果不为空</li></ul><p>把stack1的所有元素全部压入stack2，然后弹出stack2的最上面元素</p><p>至此，本道题的讲解已经全部结束</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackOne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackTwo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stackOne.push(x);<br>    &#125;<br>    <span class="hljs-comment">// 判断stack2是否为空，如果为空就把stack1的元素全部压入stack2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">judge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stackTwo.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!stackOne.isEmpty()) &#123;<br>                stackTwo.push(stackOne.pop());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        judge();<br>        <span class="hljs-keyword">return</span> stackTwo.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        judge();<br>        <span class="hljs-keyword">return</span> stackTwo.peek();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stackOne.isEmpty() &amp;&amp; stackTwo.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue obj = new MyQueue();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.peek();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>代码如上</p><h2 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h2><p>如图所示我们向一个队列放入了四个元素 1-&gt;2-&gt;3-&gt;4</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314235125651.png" class><p>现在我们想模仿栈，让两个队列去配合弹出一个元素</p><p><strong>注意：</strong>队列是先入先出的，也就是说只能先让1从队列出去</p><p>而按照栈的思想，我们想让它出去的元素应是4</p><p>那我们应该怎么做呢？</p><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220314235639721.png" class><p>如图，我们让前三个元素排队进入Queue1，然后让4从Queue1消失就可以了</p><p>假如现在我们继续压入2个元素5和6，现在问题来了，我们应该压入哪个队列呢？</p><ul><li>继续压入Queue1</li></ul><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315000031882.png" class><p>可以看到，这个时候假如我们想弹出一个元素，也就是弹出6，应该怎么做呢?</p><p>首先，在程序的角度，我们是不知道6在哪个队列的，因为我们只能查到Queue1的首元素5和Queue2的首元素1</p><p><strong>所以这个方法是行不通的！！！</strong></p><ul><li>压入<strong>已经有元素</strong>的Queue2</li></ul><img src="/2022/03/14/Algo/LeetCode225-232%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/image-20220315000609644.png" class><p>如图，我们压入了5和6，现在想要弹出元素应该弹出6，我们就可以根据开始的方法，把一个队列的前N-1个元素压入另一个队列，删除最后一个元素就可以了</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>始终保持一个队列为空，</p><p>如果有元素要进来，直接压入不为空的那个队列</p><p>如果要删除元素，前N-1个元素压入为空的那个队列，然后删除剩下的最后一个元素</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queueOne = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queueTwo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 保持一个队列一直为空</span><br>    <span class="hljs-comment">// 如果需要删除元素，就把其中一个队列的所有元素投入另一个队列</span><br>    <span class="hljs-keyword">public</span> Queue&lt;Integer&gt; <span class="hljs-title function_">getNotNullQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queueOne.isEmpty() ? queueTwo : queueOne;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        getNotNullQueue().add(x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (getNotNullQueue() == queueOne) &#123;<br>            <span class="hljs-keyword">while</span> (queueOne.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                queueTwo.add(queueOne.remove());<br>            &#125;<br>            <span class="hljs-keyword">return</span> queueOne.remove();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (queueTwo.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                queueOne.add(queueTwo.remove());<br>            &#125;<br>            <span class="hljs-keyword">return</span> queueTwo.remove();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pop();<br>        push(i);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queueOne.isEmpty() &amp;&amp; queueTwo.isEmpty();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>至此，关于栈与队列的相互转化都已经完成了，感谢大家的观看！</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务隔离级别</title>
    <link href="/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>本文所说的 MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。</p><p>我们都知道MySQL事务有四大特性ACID，没有看过的可以去看以前的文章。</p><p>要实现这四大特性就必须要克服一些问题</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a><strong>脏读</strong></h3><p>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a><strong>不可重复读</strong></h3><p>对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据<strong>更新（UPDATE）</strong>操作。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a><strong>幻读</strong></h3><p>幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><strong>事务隔离级别</strong></h2><img src="/2022/03/13/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20220313142716984.png" class><p>QL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读已提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ol><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。</p><p>启动两个事务，分别为事务A和事务B，在事务A中使用 update 语句，修改 age 的值为10，初始是1 ，在执行完 update 语句之后，在事务B中查询 user 表，会看到 age 的值已经是 10 了，这时候事务A还没有提交，而此时事务B有可能拿着已经修改过的 age&#x3D;10 去进行其他操作了。在事务B进行操作的过程中，很有可能事务A由于某些原因，进行了事务回滚操作，那其实事务B得到的就是脏数据了，拿着脏数据去进行其他的计算，那结果肯定也是有问题的。</p><p>读未提交，<strong>其实就是可以读到其他事务未提交的数据</strong>，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题，读未提交没办法解决脏数据问题。更别提可重复读和幻读了，想都不要想。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>读已提交就是<strong>一个事务只能读到其他事务已经提交过的数据</strong>，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。</p><p>同样开启事务A和事务B两个事务，在事务A中使用 update 语句将 id&#x3D;1 的记录行 age 字段改为 10。此时，在事务B中使用 select 语句进行查询，我们发现在事务A提交之前，事务B中查询到的记录 age 一直是1，直到事务A提交，此时在事务B中 select 查询，发现 age 的值已经是 10 了。</p><p>这就出现了一个问题，在同一事务中(本例中的事务B)，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果，这就是不可重复读，也就是读提交隔离级别。</p><p>读提交解决了脏读的问题，但是无法做到可重复读，也没办法解决幻读。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。</p><p>这里就提到了MVCC的问题，因为可重复读时，read view是以事务为单位的，每次读取的数据以第一次的数据为准。</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引失效</title>
    <link href="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/"/>
    <url>/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，MySQL的索引的数据结构是B+树，它相较于AVL树来说层数更低查找更快，相较于B树来说可以实现范围查找更快，关于这里不懂的同学可以在网上自行百度，今天我们主要讲讲索引为什么会失效。</p><h2 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h2><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313125531687.png" class><p>假如联合索引为(a, b),可以看到，索引的排序是先以a为基准进行排序的，也就是左边为（1， 1， 2）；右边为（2， 3， 3），而b字段是无序的。那也就是说只有a相等的情况下b才会有序。</p><p>这里是重点，如果这里看不懂，那后面就不用看了</p><p>这时候我们如果select * from table where a &#x3D; xx and b &#x3D; xx;</p><p>那它一定是走索引的</p><p>而select * from table where b &#x3D; xx;</p><p>它一定是不走索引的，因为没有a的情况下b一定无序</p><h2 id="x3D-或-lt-gt-导致索引失效"><a href="#x3D-或-lt-gt-导致索引失效" class="headerlink" title="!&#x3D; 或 &lt;&gt;导致索引失效"></a>!&#x3D; 或 &lt;&gt;导致索引失效</h2><p>假如我们select * from table where  a &gt; 1 and b &#x3D; 1;</p><p>那这样的话根据a&gt;1查到a很容易，但是b都是无序的，假如a&gt;1有很多数据，而要查到b&#x3D;1的数据，而此时是先按照a来排序，再按照b来排序，那此时b就相当于无序，所以此时索引就会失效</p><h2 id="like-导致索引失效"><a href="#like-导致索引失效" class="headerlink" title="like%导致索引失效"></a>like%导致索引失效</h2><p>我们都知道，无论是 %like还是%like%，此时索引都会失效，这是为什么呢？</p><blockquote><p>%代表任意数量的任意符号</p></blockquote><p>这个很好理解啊，字符串再索引里的排序也是按字母大小进行排序，和左前缀法则一样，当第一个字母相同的时候，它才会去匹配第二个，而当%代替了前面的任意字段以后，它如果根据后面查它就是无序的，</p><h2 id="OR导致索引失效"><a href="#OR导致索引失效" class="headerlink" title="OR导致索引失效"></a>OR导致索引失效</h2><p>OR连接的如果不是相同字段，那就会产生不符合最左前缀法则的东西，那它一定会失效，但是如果连接的是相同字段，那就无所谓了。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>聚簇索引就是把数据和索引放在了一起，索引叶子节点存储了行数据。这也是<strong>Innodb</strong>的默认索引，一般为主键索引</p><p>像普通索引、复合索引、唯一索引都是辅助索引，它存储了数据的id值而不是数据本身，他会先查找到id&#x3D;20的主键，然后通过真实的主键索引去查找到相应的数据</p><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313132747042.png" class><p>非聚簇索引的数据和索引分开存储</p><img src="/2022/03/13/MySQL/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/image-20220313132545786.png" class><p>它的叶子节点存储的是数据的地址</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACID</title>
    <link href="/2022/03/12/MySQL/ACID/"/>
    <url>/2022/03/12/MySQL/ACID/</url>
    
    <content type="html"><![CDATA[<p>我们知道，MySQL的事务有四大特性：持久性、原子性、一致性、隔离性。这就是ACID，那这究竟是怎么实现的呢？</p><img src="/2022/03/12/MySQL/ACID/image-20220312231113528.png" class><p>事务是访问数据库的程序执行单元，它可能包含一个或多个SQL语句，SQL要么都执行，要么都不执行。事务执行基于存储引擎，比如我们常见的Innodb,Myisam,Myisam不支持事务，所以我们只讲Innodb.</p><p>执行数据包含三个部分：开启事务-&gt;执行SQL-&gt;提交事务。默认是自动提交，</p><h2 id="原子性-Atomicty"><a href="#原子性-Atomicty" class="headerlink" title="原子性(Atomicty)"></a>原子性(Atomicty)</h2><p>一个事务是一个操作单位，这些东西要不全部执行，要不全部不执行，假如执行过程中一个SQL执行出错，那已经执行的SQL就要回滚</p><p><strong>undo log</strong></p><p>当事务对数据库进行操作的时候，innodb会生成undo log记录SQL执行的相关信息，一旦执行出错，那innodb就会根据undo log去进行相反的操作。</p><h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h2><p>指事务执行以后，数据库的完整性约束没有被破坏，事务执行前后都是合法的数据状态，比如主键要唯一，大小要符合规范，外键约束要符合，</p><h2 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h2><img src="/2022/03/12/MySQL/ACID/image-20220312233607667.png" class><p>隔离性分为两种情况</p><ul><li>写写操作</li></ul><p>通过锁实现，在事务执行之前，事务要先获取锁，获取以后才可以操作数据，没有锁只能等待，当锁被释放以后，其他线程就会去争抢，</p><ul><li>写读操作</li></ul><p>通过MVCC实现，想了解可以看我的上一篇文章。</p><h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>持久性指一个事务一旦提交，它对数据库的改变就是永久性的，我们知道MySQL数据存储于磁盘，直接读取磁盘是很慢的，所以innodb提供了一个buffer，包含了磁盘部分数据页的一个映射，作为访问数据库的一个缓存。</p><p>在访问数据库的时候我们会先访问buffer，buffer没有才访问磁盘，这就类似于CPU和内存之间的Cache</p><p>当写入数据的时候也会先写入buffer中，然后定期将buffer中数据写入磁盘，这就产生了数据丢失的风险，假如buffer中数据还没有写入磁盘，这个时候数据库宕机，那buffer数据就会丢失，这就产生了<strong>redo log</strong>。</p><p>当数据库数据进行新增或修改的时候，除了修改buffer数据，还会把操作写入redo log，redo log是一个预写式的日志，也就是先把操作写入redo log,接下来才会写入buffer，这就保证了数据不会出现数据丢失。</p><p>在事务提交的时候将缓冲区中的redo日志同步写入磁盘，保证写入一定成功</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>ACID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVCC</title>
    <link href="/2022/03/12/MySQL/MVCC/"/>
    <url>/2022/03/12/MySQL/MVCC/</url>
    
    <content type="html"><![CDATA[<p>MVCC全称Multi-Version Concurrency Control，即多版本并发控制。主要是为了提高数据库的读写性能。让数据库读写的时候不用加锁，MVCC主要是处理快照读，这个读指的是快照读而不是当前读。</p><blockquote><p>快照读指普通的 select 读</p><p>当前读为悲观锁读 即update insert delete等</p></blockquote><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><img src="/2022/03/12/MySQL/MVCC/image-20220312220616131.png" class><p>我们以这张图为例，张三、李四、王五、赵六对应的id都为1，第一次插入张三，后面用update进行更新，更新了若干次，最后一次更新结果为赵六。</p><p>历史数据就存储到了undo log日志里面，可以看到每条数据除了数据本身以外还有个roll_pointer和tx_id，tx_id为事务id，自增，roll_pointer是一个回滚指针，用来回滚到上一个版本。</p><h2 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h2><p>我们可以看到一个id有多条数据，那readview就来记录我们在查询的时候要在版本链里的要选择的数据。</p><img src="/2022/03/12/MySQL/MVCC/image-20220312221840189.png" class><p>read view里有多个参数，</p><ul><li>m_ids</li></ul><p>表示生成read view时当前系统活跃的读写事务的id列表，活跃是指没有commit。</p><ul><li>min_trx_id</li></ul><p>表示m_ids里最小的值</p><ul><li>max_trx_id</li></ul><p>它表示系统应该分配给下一个事务的id</p><ul><li>creator_trx_id</li></ul><p>生成readview的事务的事务id，表示是谁生成了这个read view</p><h3 id="read-view如何判断版本链哪个id可用？"><a href="#read-view如何判断版本链哪个id可用？" class="headerlink" title="read view如何判断版本链哪个id可用？"></a>read view如何判断版本链哪个id可用？</h3><img src="/2022/03/12/MySQL/MVCC/image-20220312222452263.png" class><ul><li>trx_id &#x3D;&#x3D; creator_trx_id</li></ul><p>trx_id为刚才链表里的事务id，这时候就代表这条记录是事物本身的记录，这肯定是可以的。</p><ul><li>trx_id &lt; min_trx_id</li></ul><p>这就说明这个id已经commit了，而提交的事务id是可以被访问的。</p><ul><li>trx_id &gt; max_trx_id</li></ul><p>我们知道，读取事务的时候只能读取版本链里面的数据，如果满足trx_id &gt; min_trx_id，那就说明这个数据没有在版本链里，因为max_trx_id都没有被分配过，而trx_id还是自增的。</p><ul><li>min_trx_id&lt;trx_id &lt; max_trx_id</li></ul><p>如果trx_id在m_ids里面，那就不可以，因为里的事务都是活跃的，还没有commit,而我们是不可以访问没有commit的数据的。</p><p>如果trx_id不在m_ids里面，那就说明它已经不活跃，即已经提交了，那它一定可以访问</p><h2 id="MVCC如何实现读已提交-RC-和可重复读-RR"><a href="#MVCC如何实现读已提交-RC-和可重复读-RR" class="headerlink" title="MVCC如何实现读已提交(RC)和可重复读(RR)"></a>MVCC如何实现读已提交(RC)和可重复读(RR)</h2><img src="/2022/03/12/MySQL/MVCC/image-20220312223743798.png" class><p>假如，某张表现在有一条数据，现在我们执行以下两个事务：20和60</p><img src="/2022/03/12/MySQL/MVCC/image-20220312223850569.png" class><p>20事务执行了两条update</p><img src="/2022/03/12/MySQL/MVCC/image-20220312223939428.png" class><p>执行之后它的版本链就如图所示，王五为最新数据</p><img src="/2022/03/12/MySQL/MVCC/image-20220312224034702.png" class><p>这就是它的read view，刚才我们的20和60没有commit，所以m_ids为[20, 60],最小事务min_trx_id为20，下次要分配max_trx_id的就是61，creator_trx_id默认为0.</p><img src="/2022/03/12/MySQL/MVCC/image-20220312224435581.png" class><p>这就是每个版本的情况，最小活跃事务id为20，张三的id为10，10&lt;20,因此条件满足，这就实现了读已提交。</p><p><strong>RC与RR区别</strong></p><p>读已提交和可重复读生成的read view时机不同</p><ul><li>读已提交</li></ul><p>每次执行select查询的时候就生成了read view，也就是说<strong>一个事务</strong>的两次的select就会生成两个read view</p><p>假如我们现在在更新最后一条数据王五的时候还没有提交，这时候事务1的select进行了第一次查询生成一个read view，然后事务2的update操作提交以后以后事务1select又进行了第二次查询又生成一个read view，它这个时候读取到了王五的最新数据，这个时候一个事务查到的两条数据不同，那就违背了可重复读。</p><p>最终原因还是因为每一次select都会生成一个read view</p><ul><li>可重复读</li></ul><p>可重复读生成read view是以事务为单位</p><p>假如我们现在在更新最后一条数据王五的时候还没有提交，这时候事务1的select进行了第一次查询生成一个read view，然后事务2的update操作提交以后以后事务1select又进行了第二次查询它就会去使用上一次的read view，不会生成新的read view，一个事务只生成一个read view，那它两次查询到的数据都是李四而不是王五。这就实现了可重复读</p><p>同时这也解决了幻读的问题，因为它每次只有一个read view，即使是insert以后，它查询的还是第一次生成的。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CountDownLatch</title>
    <link href="/2022/03/12/JUC/CountDownLatch/"/>
    <url>/2022/03/12/JUC/CountDownLatch/</url>
    
    <content type="html"><![CDATA[<p>今天我们一起来讲讲CountDownLatch</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">A synchronization aid that allows <span class="hljs-literal">one</span> <span class="hljs-keyword">or</span> more threads <span class="hljs-built_in">to</span> <span class="hljs-built_in">wait</span> <span class="hljs-keyword">until</span><br><span class="hljs-keyword">a</span> <span class="hljs-built_in">set</span> <span class="hljs-keyword">of</span> operations being performed <span class="hljs-keyword">in</span> other threads completes.<br></code></pre></td></tr></table></figure><p>这是CountDownLatch源码中的解释：CountDownLatch这个同步工具允许一条或多条线程等待其他线程中的一组操作完成后，再继续执行。</p><p>我们都看过复仇者联盟，这里的灭霸需要集齐所有的原石就可以超神。我们现在假设它可以派出多个小弟去分别寻找原石，灭霸只进行合成就可以。但是每个小弟找到的时间是不一样的，那灭霸怎么知道所有的小弟都把这个东西找到了呢？</p><p>这就是CountDownLatch的用武之地了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>这一句话就是新建一个CountDownLatch对象，构造函数中的数字为灭霸需要的原石的数目，也就是5个任务，每当一个任务完成，那latch就会调用countDown（）方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4982264981922014374L</span>;<br><br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br></code></pre></td></tr></table></figure><p>CountDownLatch有一个子属性为Sync，可以看到Sync继承了AQS，它重写了AQS中的tryReleaseShared等方法，可以看出来它想做到共享模式，我们在以前的AQS讲解中只讲了独占模式，其实差距不大，我们知道，在独占模式下，只有将要出队的节点中的线程被唤醒，共享模式下，除了要把要出队的节点唤醒外，还会去唤醒后续处于挂起状态的节点。</p><p>这里的tryAcquireShared就是获取AQS内部state，之后判断如果该值为0，表示锁空闲，那就返回1，否则返回-1</p><p>tryReleaseShared每次通过一个自旋的CAS操作来将AQS内部的state-1，如果不需要释放锁，或未完全释放，就返回false，否则返回true。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br></code></pre></td></tr></table></figure><p>await用于等待子任务结束，unit为等待时间，不填默认一直等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>countDown用于子任务告诉当前线程任务完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.getCount();<br>&#125;<br></code></pre></td></tr></table></figure><p>获取还未完成的任务数</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>CountDownLatch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM双亲委派</title>
    <link href="/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/"/>
    <url>/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<p>我们上一篇文章说了，类加载就是把一份被javac编译过的class文件通过加载生成某种结构的数据结构进入内存，程序可以调用这个数据结构来构造出object。</p><p>那这里就产生了两个问题</p><ol><li>不同类加载器，除了读取二进制流的动作不同和范围不一样，那后续的加载逻辑是否一样？</li><li>遇到限定名一样的类，那么多类加载器会不会产生混乱？</li></ol><p>每个类加载器都有属于自己的命名空间，一个类如果被不同的类加载器所加载就会产生混乱。</p><img src="/2022/03/12/JVM/JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/image-20220312182445758.png" class><p>我们希望：在默认情况下，一个限定名的类只会被一个类加载器加载并解析使用，这样在程序中，它就是不唯一的，不会产生歧义。</p><p>这就要提到双亲委派模型了，当一个类加载器收到加载请求，它不会自己去加载，而是先传递给父系加载器，这样所有的类都会被传递到Bootstrap ClassLoader,如果父加载器没有办法加载了，那么儿子加载器才会去加载</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>        <span class="hljs-comment">// First, check if the class has already been loaded</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                c = findClass(name);<br><br>                <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                sun.misc.PerfCounter.getFindClasses().increment();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是Java类加载的源码</p><p>它首先通过Class&lt;?&gt; c &#x3D; findLoadedClass(name);判断类有没有被加载，如果没有，它就开启加载流程，如果有就加载缓存。</p><p>parent代表当前类的父加载器，注意：<strong>这里的父亲不是继承关系，只是父亲的意思</strong>，当parent为null的时候，它需要的类加载器就是BootstrapClassLoader，如果它不为null，那就要让它根据它的限定名去尝试加载该类了，并且返回class对象，如果返回为null，那就说明该类加载器没有能力去加载这个类，那就调用findClass，</p><p>if (c &#x3D;&#x3D; null) {<br>                &#x2F;&#x2F; If still not found, then invoke findClass in order<br>                &#x2F;&#x2F; to find the class.<br>                long t1 &#x3D; System.nanoTime();<br>                c &#x3D; findClass(name);</p><p>​    … …</p><p>就是这里，这就表示这个时候各个类加载器自己去寻找实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,<br>                                     ProtectionDomain protectionDomain)<br>    <span class="hljs-keyword">throws</span> ClassFormatError<br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> b.remaining();<br><br>    <span class="hljs-comment">// Use byte[] if not a direct ByteBufer:</span><br>    <span class="hljs-keyword">if</span> (!b.isDirect()) &#123;<br>        <span class="hljs-keyword">if</span> (b.hasArray()) &#123;<br>            <span class="hljs-keyword">return</span> defineClass(name, b.array(),<br>                               b.position() + b.arrayOffset(), len,<br>                               protectionDomain);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// no array, or read-only array</span><br>            <span class="hljs-type">byte</span>[] tb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>            b.get(tb);  <span class="hljs-comment">// get bytes out of byte buffer.</span><br>            <span class="hljs-keyword">return</span> defineClass(name, tb, <span class="hljs-number">0</span>, len, protectionDomain);<br>        &#125;<br>    &#125;<br><br>    protectionDomain = preDefineClass(name, protectionDomain);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> defineClassSourceLocation(protectionDomain);<br>    Class&lt;?&gt; c = defineClass2(name, b, b.position(), len, protectionDomain, source);<br>    postDefineClass(c, protectionDomain);<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是它的加载过程，final修饰，这就严重我们以前提到了Java类加载的加载部分只能让JVM自己完成，而不能自己来</p><ol><li>不同类加载器，除了读取二进制流的动作不同和范围不一样，那后续的加载逻辑是否一样？</li></ol><p>除了BootstrapClassLoader，所有非BootstrapClassLoader都继承了Java.lang.ClassLoader,都由这个类的defineClass进行后续处理。</p><ol start="2"><li>遇到限定名一样的类，那么多类加载器会不会产生混乱？</li></ol><p>越核心的类库被越上层的类加载器加载，而某限定名的类一旦被加载过了，被动情况下，就不会再加载相同限定名的类。这样，就能有效避免混乱。</p><p>基于双亲委派模型规定的这种带有优先级的层次性关系，虚拟机运行程序时就能够避免类的重复加载。<br>当父类类加载器已经加载过类时，如果再有该类的加载请求传递到子类加载器，子类加载器执行loadClass方法，然后委托给父类加载器尝试加载该类，但是父类加载器执行 Class&lt;?&gt; c &#x3D; findLoadedClass(name)；检查该类是否已经被加载过这一阶段就会检查到该类已经被加载过，直接返回该类，而不会再次加载此类。</p><p>双亲委派模型能够避免核心类篡改。一般我们描述的核心类是 rt.jar、tools.jar 这些由启动类加载器加载的类，这些类库在日常开发中被广泛运用，如果被篡改，后果将不堪设想。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode056合并区间</title>
    <link href="/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>现在我们来分析一道比较常规的题目，<a href="https://leetcode-cn.com/problems/merge-intervals/"> 合并区间</a>，这道题我几个月之前已经做过一次了，今天再来做一次，做的不是很快，其中遇到了很多小的问题。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>要解决这道题的第一步首先就是排序</p><p>如果我们按照区间的<strong>左端点排序</strong>，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的</p><img src="/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/image-20220312162042511.png" class><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>双指针法过程如下</p><img src="/2022/03/12/Algo/LeetCode056%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/image-20220312163719399.png" class><p>我们分别定义两个节点head 和 tail</p><p>head表示当前区间，所能到达的最远的点，而tail则表示当前区间的起点，即最小的节点，我们想要扩大区间的范围就要让head扩大</p><p>由于我们刚才已经初始化过head和tail节点了，接下来我们要做的就是从第二个区间开始遍历</p><p><strong>情况1</strong></p><p>假如当前遍历的区间，记为记为intervals[i]，它的开始数字intervals[i] [0]&lt;&#x3D;head,此时我们要获取这两个集合能表示的最大范围，那head &#x3D; max(head, intervals[i] [1]).</p><p>比如上图遍历到（0，1）时,head&#x3D;5大于1,那就说明两个集合是相交的，这时候head&#x3D;max(5, 1).</p><p><strong>情况2</strong></p><p>假如intervals[i] [0]&lt;&#x3D;head,那就说明两个集合没有相交的区间，那就要把head到tail的区间放入结果中并且重新定义head和tail</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, (o1, o2) -&gt; o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// System.out.println(Arrays.deepToString(intervals));</span><br>        List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], tail = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (head &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                head = Math.max(intervals[i][<span class="hljs-number">1</span>], head);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;tail, head&#125;);<br>                head = intervals[i][<span class="hljs-number">1</span>];<br>                tail = intervals[i][<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;tail, head&#125;);<br>        <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后强调一下</p><p>res.toArray(new int[res.size()][]);这个方法</p><p>这就是把答案返回成你想要的样子，这里返回一个二维数组，返回的类型要固定。</p><p>在这里初始化的时候 int数组为引用类型，是可以直接放入List的，但是像int这种普通类型不可以</p><p>List&lt;int[]&gt; res &#x3D; new ArrayList&lt;&gt;();</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode234回文链表</title>
    <link href="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>今天我们来分享一道easy题目，这道题虽然是一道easy题目，但是要做好却并不easy。</p><p>二话不说我们直接分享题目：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>我相信看到这个题你一定认为很简单，我们直接就把整个链表的元素存在一个集合里面，然后用双指针的方法就得出来了嘛！</p><p>没错我刚开始也是这么想的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            list.add(head.val);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (list.get(i) != list.get(list.size() - i - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，此方法算法时间复杂度为O（n）,空间复杂度为O（n）.</p><p>我们是否有更加高效的方法？</p><p>答案是有的</p><h2 id="快慢指针-反转链表法"><a href="#快慢指针-反转链表法" class="headerlink" title="快慢指针+反转链表法"></a>快慢指针+反转链表法</h2><p>我们知道回文串就是从中间到两边每个元素都相同的串，那我们是否可以确定中间位置，然后从中间向两边逐步判断呢？</p><p>我们知道，链表的指向方向是唯一的</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312125005279.png" class><p>根据上图，我们如果从mid分别向head和tail方向同时不断探索，直到为空，如果是成功，那它就是一个回文子串</p><h3 id="确定mid位置"><a href="#确定mid位置" class="headerlink" title="确定mid位置"></a>确定mid位置</h3><p>确定mid位置可以用快慢指针的 方法，这个方法在链表里十分常用，简单来说就是定义一个fast和slow节点同时向前走，fast每次移动2步，slow每次移动一步，那啥时候停止呢？那就是fast不能移动的时候，即fast &#x3D;&#x3D; null || fast.next &#x3D;&#x3D; null</p><h3 id="确定了mid接下来就是反转链表了"><a href="#确定了mid接下来就是反转链表了" class="headerlink" title="确定了mid接下来就是反转链表了"></a>确定了mid接下来就是反转链表了</h3><p>这个过程其实可以在slow移动的时候同步进行，在这里我们不过多赘述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> slow.next;<br>            slow.next = pre;<br>            pre = slow;<br>            slow = next;<br>        &#125;<br></code></pre></td></tr></table></figure><p>这就是反转和快慢指针的过程</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p>我们要注意一个东西</p><p>链表的节点数可能是偶数也可能是奇数</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312125940584.png" class><p>假如三个节点 1-&gt;2-&gt;3，此时候节点数目为<strong>奇数</strong>，这个时候也一样fast指向3,slow指向2，pre指向1.这个时候我们就需要把slow再向后移位了，这个时候经过翻转那slow刚好处于中间，那它就需要向后再移动一位，才能继续链表的比较</p><img src="/2022/03/12/Algo/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220312130248017.png" class><p>假设此时两个节点 1-&gt; 2,这个时候pre就是1，fast指向空，slow指向2，pre指向1结果正合我意，我们不做任何处理，就让它继续比较</p><p>完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, pre = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 快慢指针和翻转部分</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> slow.next;<br>            slow.next = pre;<br>            pre = slow;<br>            slow = next;<br>        &#125;<br>        <span class="hljs-comment">// 细节部分</span><br>        <span class="hljs-keyword">if</span> (fast != <span class="hljs-literal">null</span>) slow = slow.next;<br>        <span class="hljs-comment">// 最后比较部分</span><br>        <span class="hljs-keyword">while</span> (slow != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (slow.val != pre.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            slow = slow.next;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，关于本道题目的讲解全部结束</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM类加载</title>
    <link href="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代码加载过程"><a href="#Java代码加载过程" class="headerlink" title="Java代码加载过程"></a>Java代码加载过程</h1><p>在详细讲解类加载之前我想我们要先知道我们编写的Java代码是如何被加载运行的</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311205528562.png" class><p>从上图可以看出，javac先把代码编译为字节码，然后由JVM去加载字节码，运行的时候<strong>解释器</strong>把字节码解释为机器指令。在程序运行期间，<strong>即时编译器</strong>能针对热点代码将该部分字节码编译为机器指令，从而获得更高的运行效率，在整个运行期间解释器和即时编译器相互配合，使得程序几乎能达到和编译型语言一样的执行速度。</p><p>对于我们来说，我们今天只讲解代码是如何编译为字节码的。</p><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载流程的目的是什么？</p><p>简单来说就是把一份被javac编译过的class文件通过加载生成某种结构的数据结构进入内存，程序可以调用这个数据结构来构造出object</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311210813023.png" class><p>上图表示了一个类的生命周期，类加载只包括<strong>加载、连接和初始化</strong>三个阶段，加载只是类加载的第一个环节，解析部分是十分灵活的，它可以在初始化环节之前和之后进行，实现所谓的后期绑定。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311211403796.png" class><p>如图，加载是一个读取class文件，将其转化为某种数据结构放在方法区，并在堆中生成一个便于用户调用的java.lang.Class对象的过程，其中有几个重要点，这里的class不一定是本地class文件，也有可能是数据库或者网络，</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>虽然上面已经加载过了，但这不代表JVM完全接收这个类，如果程序想用这个类，那就必须进行连接。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接第一步就是进一步对这个类进行验证，它对在方法区的数据结构进行了以下验证</p><ul><li><p>元数据认证</p></li><li><p>字节码验证</p></li></ul><p>这两个就是对class静态结构进行语法分析，看看它会不会产生危害虚拟机的行为</p><p>这时候就会认为这个程序是安全的，但是这还没有完全结束</p><ul><li>对符号引用进行验证</li></ul><p>这一步是在解析阶段完成的，它可以发生在初始化阶段发生前和发生后，</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在验证通过后，就可以大概认为这个类是安全的，接下来就可以进入准备阶段，这个阶段就是为了该类型中定义的静态变量赋0值.这里仅仅是静态变量。</p><blockquote><p>在这里强调一下，虚拟机内存规范中定义了方法区这种抽象概念，Java虚拟机在JDK8之前使用了永久代这种具体实现方式来实现方法区，在JDK8以后启用了“永久代”这种实现方，而改用元空间这种直接内存来取代，所以我们常看到的JDK8以后用元空间取代了方法区这是错误的，因为元空间只是一种实现方式。</p></blockquote><p>在JDK8之前类的元信息、常量池、静态变量都存在永久代这种实现中，而JDK8以后常量池静态变量被移出了方法区，转移到了堆中，元信息依然放在方法区，但存储方式改为了元空间。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>接下来我们来讲一讲解析阶段</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311213420013.png" class><p>这个阶段就是将符号引用替换为直接引用，假如A对象中存在B对象，在A编译的时候是不知道B有没有被加载的，这个时候称它为符号引用，A不知道B的实际地址，在解析的时候A就会知道B的地址，这也就是为什么会出现多态这种东西，比如我们常写的</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>这就实现了动态绑定解析。</p><p>至此连接阶段已经全部完成，此时外部的Java类已经全部引入到了你的程序中</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段比较简单，简单来说就是判断此时代码中是否存在主动的资源初始化操作，如果有的话就执行，这里说的主动资源初始化不是指构造函数，而是class层面的，比如成员变量的赋值，静态变量赋值等。</p><img src="/2022/03/11/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20220311214322003.png" class><p>至此，类加载过程就全部讲完了，</p><p>但是还没有完全结束，请期待下一集~</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode347前K个高频元素</title>
    <link href="/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <url>/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p>今天做了一道题目：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>,一般来说不管是前k个改频元素还是第k大的数都可以用优先级队列的思想</p><p>在讲这道题之前我们先来看一看两种堆的结构，堆的本质就是二叉树，它分为大顶堆和小顶堆。</p><p>大顶堆中每个父节点大于子节点，小顶堆每个父节点小于子节点</p><img src="/2022/03/11/Algo/LeetCode347%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/image-20220311111807467.png" class><p><strong>topK大构建一个小顶堆</strong></p><p>为什么呢？</p><p>我们知道，小顶堆树的根节点一定是这个堆里面所有元素的最小值，而所有树节点都比根节点大，因此我们构建一个K个节点的小顶堆，当来了一个节点时</p><ul><li>如果堆节点数小于K</li></ul><p>直接把节点放入堆</p><ul><li>如果堆的节点上为k时</li></ul><p>先判断堆的首节点是否比新来的节点小，如果新来的节点比较小就不做处理，否则就把根的头节点换了，重新构建整个堆</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-comment">// 把所有元素放进hashmap</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 创建一个小顶堆，根据map中出现的频率进行排序</span><br>        <span class="hljs-comment">// 注意这里queue里存储的还是元素，而不是出现的频率</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; map.get(a) - map.get(b));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key : map.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (queue.size() &lt; k) &#123;<br>                queue.add(key);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(queue.peek()) &lt; map.get(key))&#123;<br>                queue.remove();<br>                queue.add(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) res[cnt++] = queue.remove();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的PriorityQueue就是一个优先级队列</p><p>remove就是移除最小的元素</p><p>在这里值得一提的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这句话在HashMap里很常用，map.getOrDefault(num, 0)表示尝试去获取num键所对应的值，否则返回0,</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2022/03/10/JUC/CAS/"/>
    <url>/2022/03/10/JUC/CAS/</url>
    
    <content type="html"><![CDATA[<p>建议看这篇文章之前先去看一下上一篇文章（Java锁机制）</p><p>假设我们现在有多个线程想去访问操作同一资源，很多人第一反应一定是互斥锁，但互斥锁是悲观的</p><ul><li>悲观锁</li></ul><p>简单来说，操作系统认为如果不严格管理线程调用，那一定会出现问题，那它就会把一个资源进行锁定，只让一个线程去调度。从而阻塞别的线程。</p><ul><li>乐观锁</li></ul><p>假设现在我们大部分操作都是读操作，那就没必要去每次操作就去锁定资源，那我们可不可以不锁定资源也能去同步线程呢？</p><p>这就要用到CAS（compare and swap）</p><img src="/2022/03/10/JUC/CAS/image-20220310232112615.png" class><p>假如现在资源状态值为0，多个线程同时访问到资源为0，记为OldValue，此时A,B,C同时想去修改这个状态值，假设A运气比较好，A它优先修改了资源状态为1，这时候B和C，在修改之前会拿资源状态值和刚才的OldValue进行比较，这时候B和C会发现不对劲，即资源状态值和刚才的OldValue不一样，那它们就会放弃修改，在实际操作中，我们一般不会让它直接放弃，而是让它去自旋</p><p><strong>CAS原子性</strong></p><p>我们都知道，CAS在更新前会进行判断，假如AB同时想去获取资源，在A像去把状态值改变的时候B抢先把值给修改了，这时候就会一个资源被两个资源占用，因此保证CAS原子性就十分重要。</p><p>现在CPU已经有了原子性的指令，直接调用即可。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger就是CAS的一种实现，</p><img src="/2022/03/10/JUC/CAS/image-20220310233457294.png" class><p>通过源码可以看到它通过Unsafe的cas操作来进行值的更新。这里的U就是unsafe对象。</p><img src="/2022/03/10/JUC/CAS/image-20220310233620519.png" class><p>它的getAndIncrement()即数值自增方法就是用Unsafe对象的getAndAddInt来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是getAndAddInt的源码，可以看到确实用到了CAS,这里的循环就是自旋<br>至此，我所了解的CAS内容全部讲解完毕~</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java锁机制</title>
    <link href="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310221706087.png" class><p>在Java中每个Object，也就是每一个对象都有一把锁。这把锁放在对象头，锁中记录了当前对象被哪一个线程锁占用。如上图中，红色的为对象Object，头为蓝色的，绿色的就是锁。</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310222044664.png" class><p>如图，每个Java对象分为三块，分别为对象头、实例数据、填充字节</p><ul><li>对象头</li></ul><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310222625579.png" class><p>对象头包含两部分：mark word和class point，class point指向对象在当前对象类型所在方法区中的类型数据。mark word存储了很多和当前对象运行时的状态信息。比如hashcode、锁状态标志，指向记录的指针等。</p><p>所标志位的不同bit值代表锁的不同状态</p><p>sychronized关键字被用来同步线程，sychronized被编译后会生成monitorenter和monitorexit两个字节码来进行线程同步</p><p>在这里介绍一下monitor，它常被翻译为管程\监视器，关于moniter我们可以把它想象成一个房间，只能容纳一名客人。而线程就是客人，一个线程进入monitor，那其他线程只能等待，只要当线程退出，其他线程才有进入的机会。</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310223405307.png" class><p>看一下上面这张图，EntrySet聚集了一些像进入monitor的线程，正处于waiting状态，假如线程A成功进入monitor，那它就处于active状态，假如A线程执行过程中遇到了一个判断条件，那就让它暂时让出执行权，进入WaitSet，那它的状态就会变为waiting，假如另一个线程B进入monitor并且成功完成任务，那它就可以通过notify唤醒WaitSet中的线程。这样的线程调度十分耗费资源，所以Java6以后对sychronized进行了优化。</p><p>锁被分为了 无锁、偏向锁、轻量级锁、重量级锁。锁只能升级，不能降级</p><ul><li>无锁</li></ul><p>无锁就是对资源没有锁，所有线程都可以访问这个资源，这就可能出现两种情况：</p><ol><li>某个线程没有处在多线程情况下，或者线程间没有竞争，那就无需任何保护，让线程任意调度就可以</li><li>资源会被竞争，但是不进行资源锁定，可以通过CAS的方法来进行锁定，只有一个线程可以修改成功，其他修改失败的线程可以进行自旋，直到修改成功</li></ol><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310224809193.png" class><ul><li>偏向锁</li></ul><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310225134175.png" class><p>我们现在给对象加锁，不进行线程间切换，也不用进行资源，我们剋让一个锁只对应一个线程，只要是这个线程过来，就直接把锁交出去我们就认为这个对象偏爱这个锁，这就是偏向锁</p><p>这是如何实现的？</p><p>我们可以好好看看上面那个表，假如锁标志位是01，那就判断倒数第三个bit是否是1，如果是的话，那就说明它是偏向锁，否则就是无锁，如果是偏向锁，就去读取他的线程ID，如果线程ID和当前线程ID不同，那就说明存在锁竞争，那就会锁升级，升级为轻量级锁。</p><ul><li>轻量级锁</li></ul><p>假如线程访问锁时，如果发现那个锁标志位为00.那就说明这是一个轻量级锁</p><img src="/2022/03/10/JUC/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20220310225954559.png" class><p>这时候就会在虚拟机栈开辟一个LockRecord的空间，存储对象markword副本以及对象指针，线程会尝试用CAS获取锁，如果获取成功，那就复制对象mark word副本到LockRecord并且将owner指针指向该对象。如果此时其他线程也尝试获取锁，那它就会进行自旋，这里的自旋经过优化为<strong>适应性自旋</strong>，自旋时间不再固定，而是根据上次自旋的时间以及锁的状态来综合评估，一旦自旋线程超过一个，那就会升级为重量级锁</p><ul><li>重量级锁</li></ul><p>这个时候就回到开始读根据monitor来判断锁，这个代价十分昂贵。</p><p><strong>总结</strong></p><p>我们讲解了Java对象的划分，锁的标志位，以及优化后锁升级的步骤、不同状态下如何保证线程安全。</p><p>说了什么算适应性自旋</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程间通信方式</title>
    <link href="/2022/03/10/JUC/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/03/10/JUC/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>今天我们来讨论一个常见的面试题</p><p>线程间有哪些通信方式？</p><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do something....</span><br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//do some other thing</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyObject object;<br><span class="hljs-comment">//省略构造方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>        object.methodA();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyObject object;<br><span class="hljs-comment">//省略构造方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>        object.methodB();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Run</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br><br>        <span class="hljs-comment">//线程A与线程B 持有的是同一个对象:object</span><br>        <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(object);<br>        <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(object);<br>        a.start();<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们对于两个方法methodA和methodB都进行了synchronized修饰，由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信。</p><h1 id="while轮询的方式"><a href="#while轮询的方式" class="headerlink" title="while轮询的方式"></a>while轮询的方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        list.add(<span class="hljs-string">&quot;elements&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyList list;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(MyList list)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                list.add();<br>                System.out.println(<span class="hljs-string">&quot;添加了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MyList list;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(MyList list)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">5</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;==5, 线程b准备退出了&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> mylist.MyList;<br><span class="hljs-keyword">import</span> extthread.ThreadA;<br><span class="hljs-keyword">import</span> extthread.ThreadB;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyList</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyList</span>();<br><br>        <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(service);<br>        a.setName(<span class="hljs-string">&quot;A&quot;</span>);<br>        a.start();<br><br>        <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(service);<br>        b.setName(<span class="hljs-string">&quot;B&quot;</span>);<br>        b.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MyList就是去new一个空的List然后提供两个方法，一个是返回它的size，一个是add方法添加元素；</p><p>ThreadA有一个MyList类生成的对象，它的run方法就是循环调用add方法，每次add后都sleep</p><p>ThreadB也有一个MyList类生成的对象，它会去判断list的size</p><p>在主函数里new一个List,同时传给线程A和线程B，然后让它们去开始执行</p><p>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()&#x3D;&#x3D;5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。</p><p>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是：在干别的事情，当有电话来时，响铃通知TA电话来了。</p><h1 id="wait-x2F-notify机制"><a href="#wait-x2F-notify机制" class="headerlink" title="wait&#x2F;notify机制"></a><strong>wait&#x2F;notify机制</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        list.add(<span class="hljs-string">&quot;anyString&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> list.size();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadA</span><span class="hljs-params">(Object lock)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">if</span> (MyList.size() != <span class="hljs-number">5</span>) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;wait begin &quot;</span><br>                            + System.currentTimeMillis());<br>                    lock.wait();<br>                    System.out.println(<span class="hljs-string">&quot;wait end  &quot;</span><br>                            + System.currentTimeMillis());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadB</span><span class="hljs-params">(Object lock)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    MyList.add();<br>                    <span class="hljs-keyword">if</span> (MyList.size() == <span class="hljs-number">5</span>) &#123;<br>                        lock.notify();<br>                        System.out.println(<span class="hljs-string">&quot;已经发出了通知&quot;</span>);<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;添加了&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素!&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Run</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>            <span class="hljs-type">ThreadA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>(lock);<br>            a.start();<br><br>            Thread.sleep(<span class="hljs-number">50</span>);<br><br>            <span class="hljs-type">ThreadB</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadB</span>(lock);<br>            b.start();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解决上面B不断循环的情况，我们可以先去搞一个锁，线程A和B分别拿synchronized锁修饰，线程A要等待条件满足时(list.size()&#x3D;&#x3D;5)，才执行操作。线程B则向list中添加元素，改变list 的size。</p><p>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</p><p>这里用到了Object类的 wait() 和 notify() 方法。</p><p>当条件未满足时(list.size() !&#x3D;5)，线程A调用wait() 放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</p><p>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</p><p>这种方式的一个好处就是CPU的利用率提高了。</p><p>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：<strong>通知过早，会打乱程序的执行逻辑。</strong></p><h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><p>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode236二叉树的最近公共祖先</title>
    <link href="/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p>今天继续一道关于二叉树的题目，</p><img src="/2022/03/10/Algo/LeetCode236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/image-20220310143712044.png" class><p>这道题要求两个节点的公共祖先，那肯定是自下而上的方法，而在二叉树的遍历操作中，有一种天然的自下而上遍历的方法，那就是回溯的方法。</p><p>我们假设要找的节点为P和Q</p><p>如果当前节点是空节点或者是要寻找的两个节点中的一个，那二话不说直接返回当前节点</p><p>我们可以去先对它的左节点做递归操作，然后对右节点做递归操作，左右节点的递归都会去返回一个节点。分别记为resLeft和resRight.</p><p>然后在对于该节点的操作上，如果刚才得到的resLeft为空，那刚才的P和Q都不在左侧，那就返回resRight</p><p>反之如果resRight.为空，同理与上</p><p>假如都不为空，那说明该节点就是那个最近的根节点，直接返回这个点就可以了！</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，本题的思考过程全部结束。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode530二叉搜索树的最小绝对差</title>
    <link href="/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
    <url>/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    
    <content type="html"><![CDATA[<p>我今天特别有针对性的就想去做一道二叉树遍历有关的题目，然后就遇到了<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a>这道题</p><p>这道题为easy，但我感觉它难度也不算小，这道题如果用一个数字，然后用中序遍历的方法存下有序的数组，最后贪心得出最终答案。</p><p>但我想说的并不是这种方法，而是用纯递归的方法去解决。这道题与常规题目不同的地方在于，它需要自己去创建两个个类属性：</p><ul><li>pre指针</li></ul><p>用于存储上次一遍历的值</p><ul><li>ans</li></ul><p>即最终答案，默认值为Integer.MAX_VALUE;</p><p>我们来分析一下，这道题肯定会用中序遍历的方法</p><img src="/2022/03/09/Algo/LeetCode530%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/image-20220309231520756.png" class><p>假如有这样一个二叉树，中序遍历结果为：1-&gt;2-&gt;3-&gt;4-&gt;6,可以看到这是顺序的，而对于一个节点而言，它的<strong>顺序为小-&gt;中-&gt;大</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">private</span> TreeNode pre;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        midfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">midfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        midfs(root.left);<br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">null</span>) &#123;<br>            ans = Math.min(ans, root.val - pre.val);<br>        &#125;<br>        pre = root;<br>        midfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看这段代码，根据上面这个二叉树它首先回去访问1节点，此时pre节点为null，ans不会改变。这个时候把pre变为当前节点</p><p>第二次它会去访问2节点，此时pre为1，这个时候会进行一次最小值的替换，然后pre换为2，</p><p>接下来访问3节点。。。</p><p>相信大家都已经知道了，这样相较于直接把所有节点放在数组里十分类似，访问顺序都一样。</p><p>最后再提一句，这里的if (pre !&#x3D; null)为什么判断的是pre而不是root？</p><p>因为root上面已经判断过了，pre的判断只是为了防止第一次pre为空的情况</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode200岛屿数量</title>
    <link href="/2022/03/09/Algo/LeetCode200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2022/03/09/Algo/LeetCode200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>今天我们来分享这道题：<a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>,这是有关图的递归遍历的题目。这道题我第一次见到的时候十分束手无策，这道题难度为mid，其实理解以后真实难度也就easy，主要是考了图的深度遍历。</p><p>首先先明确题意，它说的是<strong>上下左右</strong>为’0’的地方为水，然后求岛屿的数量，那我们就可以先搞一个二层遍历，遍历二维数组的每一个元素，如果它为’1’,那它一定是一个岛屿。然后我们下来要做的事情就是用递归的方法把周围相关的岛屿全部遍历一遍并且改一下状态(可以理解为只要遇见一个岛的一块地方，就把这个岛屿相关的地方全部变成水)。这里递归的结束条件就是当要访问的下标越界或者访问到’0’.</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    dfs(grid, i, j);<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &gt;=grid[<span class="hljs-number">0</span>].length || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        dfs(grid, i + <span class="hljs-number">1</span>, j);<br>        dfs(grid, i, j + <span class="hljs-number">1</span>);<br>        dfs(grid, i - <span class="hljs-number">1</span>, j);<br>        dfs(grid, i, j - <span class="hljs-number">1</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此本次要分享的思路全部结束</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock深度剖析</title>
    <link href="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
    <url>/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>在开始之前我们先来大概将一讲啥是ReentrantLock</p><p>ReentrantLock基于<strong>AQS</strong>，对于AQS不了解的可以看<a href="https://andersonlee09.github.io/2022/03/05/JUC/AQS%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">这里</a>。在并发编程中它可以实现<strong>公平锁</strong>和<strong>非公平锁</strong>来对共享资源进行同步，同时，它与synchronizd一样，ReentrantLock支持<strong>可重入</strong>，除此之外，ReentrantLock在<strong>调度</strong>上更加灵活，支持更多丰富的功能。</p><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308221113973.png" class><p>接下来我们根据以上思维导图来进行讲解。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308221251242.png" class><p>可以看到ReentrantLock实现了Lock接口，那什么 是Lock呢？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">&#123;@code Lock&#125; implementations provide more <span class="hljs-keyword">extensive </span>locking operations than can <span class="hljs-keyword">be </span>obtained using &#123;@code <span class="hljs-keyword">synchronized&#125; </span>methods <span class="hljs-keyword">and </span>statements.  They allow more flexible structuring, may have quite <span class="hljs-keyword">different </span>properties, <span class="hljs-keyword">and </span>may support <span class="hljs-keyword">multiple </span>associated &#123;@link Condition &#125; objects.<br></code></pre></td></tr></table></figure><p>这是Lock接口最开头的一段内容，它的意思是说：</p><p>{@code Lock} 实现了区别于 {@code synchronized} 的另一种具有更多广泛操作的同步方式，它允许更灵活的结构，可能有完全不同的属性，并且可能支持多个关联的 {@link Condition} 对象。</p><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308222000247.png" class><p>Lock方法有六个方法</p><p>lock方法用于获取锁，加入当前锁被其他线程，那它就会去等待，直到获取锁</p><p>lockInterruptibly类似于lock，但区别在于假如当前线程在等待过程中被中断，那它就会退出等待，并且抛出异常</p><p>tryLock无参方法尝试获取锁，返回为bool类型代表是否获得锁</p><p>tryLock有参数方法，在一段时间内尝试获取锁，假如等待过程中被中断，就会抛出异常</p><p>unlock释放锁</p><p>newCondition方法新建一个绑定在当前Lock上的Condition对象，Condition对象有什么用？它表示一个等待状态，获得锁线程在某些时刻需要等待一些条件完成才能继续运行，那它通过await方法注册在condition对象上进行等待，通过condition对象的signal方法将其唤醒，这一点类似于Object的wait方法和notify方法。但不同的是一个Lock对象可以关联多个Condition。多个线程可以被绑定在不同的Condition对象实现分组功能。</p><h2 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h2><p>ReentrantLock只有一个属性：sync，它final修饰，一旦初始化，就不能被修改。</p><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308223528777.png" class><p>Sync继承AQS</p><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308223457935.png" class><p>Sync有两个子类，一个NonfairSync一个FairSync.</p><p>接下来我们看看Sync的nonfairTryAcquire方法，即不公平获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它首先获取state,这里的state与AQS中state一样，用于表示当前线程状态</p><p>它先判断 当state为0，表示锁是空闲的，便可以进行一次CAS来原子地更改state，如果获取成功，那就setExclusiveOwnerThread将当前线程设置为独占线程，并且返回true</p><p>当state不为0，它会去判断当前线程是否是独占线程，为什么要进一步判断呢？这就是对<strong>可重入</strong>的实现，这里判断的是独占锁的人是不是自己，如果不是，那就尝试获取失败，返回flase。如果正是自己，那就能够满足可重入性，但是这个时候需要累加state来记录重入的次数,因为它需要释放相同次数。</p><p>这里它判断了一次state&lt;0，这是为了防止重入的次数过多造成整数溢出，所以它重入最大次数为2^31-1，这里不得不感叹一句，设计框架的人对于细节的把握真的很到位。</p><blockquote><p> 可重入指的是：单个线程执行时，重新进入同一个子程序仍然是线程安全的，A在某上下文获得了某锁，当A想再次获得锁的时候，不会因为锁已经被自己占用，而需要先去等待锁的释放。A如果已经获得了锁，又去等待自己释放锁，就会造成死锁。简单的来说就是一个线程可以不用释放，获得一个锁N次。但是它需要释放N次。</p></blockquote><p>接下来我们看看Sync的tryRelease方法，即尝试释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@ReservedStackAccess</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的返回值指的是释放完全释放，而不是是否成功释放一次。</p><h2 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h2><p>公平锁：按锁的请求顺序进行排队，拥有稳定获取锁的机会，但性能比较低。AQS的FIFO队列就可以实现。</p><p>非公平锁：不一定按照锁的请求顺序进行分配，但是性能高。因为后请求锁的线程可能在前面休眠线程恢复前就拿到锁，这样可以提高性能。线程间的切换可能会造成延时。</p><h2 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7316153563782823691L</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它只是重写了tryAcquire方法，这里的nonfairTryAcquire我们在上面已经讲过，这里不进行赘述。</p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">     * recursive call or no waiters or is first.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ReservedStackAccess</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它只是重写了tryAcquire方法，但重写方式略有不同，逻辑如下：</p><p>如果锁是空闲的，且FIFO队列中没有排在当前线程之前的线程，那就允许当前线程去尝试获取锁。如果是当前线程正在使用锁那就state进行累加，否则直接返回false</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>可以看到，该实现的已经实现的差不多了，ReentrantLock直接调用FairSync、NonfairSync就可以了。</p><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308231815738.png" class><p>ReentrantLock实现了两个构造函数，无参为非公平模式，</p><h2 id="Java中断机制"><a href="#Java中断机制" class="headerlink" title="Java中断机制"></a>Java中断机制</h2><img src="/2022/03/08/JUC/ReentrantLock%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220308232322877.png" class><p>假如现在有一条线程正在运行中，你对它调用interrupt方法，那它会继续运行，并不会抛出中断异常。而是修改thread对象的一个中断状态boolean值，true代表被中断，false表示未被中断。isinterrupted会返回这个状态值，isinterrupted会返回这个状态值，并将其改为false。</p><p>如果需要观察某个线程在Runnable状态下中断状态，可以用isinterrupted方法。又假如现在有一条线程，它的状态时blocked或waiting也就是阻塞或者等待，如果此时对它进行interrupt，如果线程是调用sleep\wait\join方法进入的阻塞或者等待，那就会抛出中断异常，假如是通过LockSupport.park方法进入阻塞状态被interrupt时，那它不会发生异常，而时改变线程状态的值。</p><p>写这篇文章我大概用了两个小时，实属不易，如果大家有什么异议还请提出~</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>ReentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CopyOnWriteArrayList</title>
    <link href="/2022/03/08/Java%E9%9B%86%E5%90%88/CopyOnWriteArrayList/"/>
    <url>/2022/03/08/Java%E9%9B%86%E5%90%88/CopyOnWriteArrayList/</url>
    
    <content type="html"><![CDATA[<p>上次CVTE面试的时候，面试官问我ArrayList是线程安全的吗？</p><p>我回答：不是</p><p>他说假设我现在有一个场景需要用集合并且要线程安全，有什么方法</p><p>我回答：可以加synchronized锁，或者用CAS的方法</p><p>他问我有没有安全的容器</p><p>我想了想，确实我不知道，然后面试G了</p><p>后面我复盘了一下，发现安全的容器有vector和CopyOnWriteArrayList，vector我本来就知道，但是它几乎已经被弃用了，所以我没有说，今天我们来好好扒一扒这个CopyOnWriteArrayList</p><p>CopyOnWriteArrayList并发容器用于读多写少的并发场景。</p><ul><li>线程安全的ArrayList</li><li>写有锁，读无锁读写之间不阻塞，优于读写锁</li><li>写入时，先copy一个副本容器，再添加新元素，最后替换引用</li><li>使用方式与ArrayList无异</li></ul><p>下面我们先来分析一下add方法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        Object[] es = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>        es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>        es[len] = e;<br>        setArray(es);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它先用synchronized把容器锁住，然后先把原来的容器给复制一份，复制到es，然后把es的最后一个元素添加e,最后把原数组引用指向es，这样就🆗了</p><p>下面看一下get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> elementAt(getArray(), index);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个get方法非常朴素，没有任何锁，直接返回下标所在的值</p><p>所以相较于我们自己加的读写锁，它只有在写的时候加锁，这样效率会比较高一点</p><p>下面看一下remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        Object[] es = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementAt(es, index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> len - index - <span class="hljs-number">1</span>;<br>        Object[] newElements;<br>        <span class="hljs-keyword">if</span> (numMoved == <span class="hljs-number">0</span>)<br>            newElements = Arrays.copyOf(es, len - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            newElements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[len - <span class="hljs-number">1</span>];<br>            System.arraycopy(es, <span class="hljs-number">0</span>, newElements, <span class="hljs-number">0</span>, index);<br>            System.arraycopy(es, index + <span class="hljs-number">1</span>, newElements, index,<br>                             numMoved);<br>        &#125;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它的remove方法类似，它这里非常细节，如果numMoved &#x3D;&#x3D; 0即删除的元素为最后一个，那就直接复制一次就可以了，否则就从删除处分割一下，复制两次。</p><p><strong>总结</strong></p><p>CopyOnWriteArrayList写操作是在锁的保护下进行的，这样可以避免在高并发add的时候，复制多个副本出来，把数据搞乱，导致最终数据不是我们期望的</p><p>由于所有锁操作都是在写的时候进行，分以下几种情况</p><ul><li>写操作未完成</li></ul><p>直接读取原数据</p><ul><li>写操作已经完成，但是还没有指向新的数组</li></ul><p>那也是读取原数组</p><ul><li>写操作已经完成且指向新数组</li></ul><p>那就从新数组中读取数据</p><p>最后总结一下CopyOnWriteArrayList的思想</p><ol><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ol><p>最后顺带提一句，我在写这个文章之前看过很多解析，都说什么读写分离，还图文并茂，但都不如我直接看源码来的清晰，所以我非常鼓励大家去读源码。</p>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java集合</tag>
      
      <tag>CopyOnWriteArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="连接redis遇到的问题"><a href="#连接redis遇到的问题" class="headerlink" title="连接redis遇到的问题"></a>连接redis遇到的问题</h3><p><a href="https://www.cnblogs.com/invban/p/14187524.html">https://www.cnblogs.com/invban/p/14187524.html</a></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String类型的三种格式：</p><ul><li><p>字符串</p></li><li><p>int</p></li><li><p>float</p></li></ul><p>lSET：添加或者修改已经存在的一个String类型的键值对</p><p>lGET：根据key获取String类型的value</p><p>lMSET：批量添加多个String类型的键值对</p><p>lMGET：根据多个key获取多个String类型的value</p><p>DEL : 删除键值对</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308161749004.png" class><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308162117682.png" class><p>lHSET key field value：添加或者修改hash类型key的field的值</p><p>lHGET key field：获取一个hash类型key的field的值</p><p>lHMSET：批量添加多个hash类型key的field的值</p><p>lHMGET：批量获取多个hash类型key的field的值</p><p>lHGETALL：获取一个hash类型的key中的所有的field和value</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308162358308.png" class><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li><p>有序</p></li><li><p>元素可以重复</p></li><li><p>插入和删除快</p></li><li><p>查询速度一般</p></li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>lLPUSH key element … ：向列表左侧插入一个或多个元素</p><p>lLPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</p><p>lRPUSH key element … ：向列表右侧插入一个或多个元素</p><p>lRPOP key：移除并返回列表右侧的第一个元素</p><p>lLRANGE key star end：返回一段角标范围内的所有元素</p><p>lBLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308162613985.png" class><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>lSADD key member … ：向set中添加一个或多个元素</p><p>lSREM key member … : 移除set中的指定元素</p><p>lSCARD key： 返回set中元素的个数</p><p>lSISMEMBER key member：判断一个元素是否存在于set中</p><p>lSMEMBERS：获取set中的所有元素</p><p>lSINTER key1 key2 … ：求key1与key2的交集</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308162926178.png" class><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308164338195.png" class><h2 id="Java连接Redis"><a href="#Java连接Redis" class="headerlink" title="Java连接Redis"></a>Java连接Redis</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConnection</span> &#123;<br>    <span class="hljs-keyword">private</span> Jedis jedis;<br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 建立连接</span><br>        jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.23.131&quot;</span>, <span class="hljs-number">6379</span>);<br>        System.out.println(jedis.ping());<br>        <span class="hljs-comment">// 设置密码</span><br><span class="hljs-comment">//        jedis.auth(&quot;xxxx&quot;);</span><br>        <span class="hljs-comment">// 选择库</span><br>        jedis.select(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestConnection</span> <span class="hljs-variable">testConnection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestConnection</span>();<br>        testConnection.setUp();<br>        testConnection.testString();<br>        testConnection.tearDown();<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;ander&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;res = &quot;</span> + res);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-Boot-整合Redis"><a href="#Spring-Boot-整合Redis" class="headerlink" title="Spring Boot 整合Redis"></a>Spring Boot 整合Redis</h2><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308185546271.png" class><p>pom.xml里加入这个</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--      连接池依赖--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.23</span><span class="hljs-number">.131</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <span class="hljs-comment"># 最大连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>  <span class="hljs-comment"># 最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># 最小空闲连接</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">100</span>  <span class="hljs-comment"># 连接等待时间</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickStart</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name= &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义RedisTemplate"><a href="#自定义RedisTemplate" class="headerlink" title="自定义RedisTemplate"></a>自定义RedisTemplate</h3><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308192222115.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span>        <span class="hljs-keyword">throws</span> UnknownHostException &#123;    <span class="hljs-comment">// 创建Template</span><br>    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();    <span class="hljs-comment">// 设置连接工厂</span><br>    redisTemplate.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-comment">// 设置序列化工具</span><br>    <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>    <span class="hljs-comment">// key和 hashKey采用 string序列化</span><br>    redisTemplate.setKeySerializer(RedisSerializer.string()); <br>    redisTemplate.setHashKeySerializer(RedisSerializer.string());<br>    <span class="hljs-comment">// value和 hashValue采用 JSON序列化</span><br>    redisTemplate.setValueSerializer(jsonRedisSerializer);<br>    redisTemplate.setHashValueSerializer(jsonRedisSerializer);<br>    <br>    <span class="hljs-keyword">return</span> redisTemplate;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308193212205.png" class><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><h3 id="手动使用StringRedisTemplate（推荐）"><a href="#手动使用StringRedisTemplate（推荐）" class="headerlink" title="手动使用StringRedisTemplate（推荐）"></a>手动使用StringRedisTemplate（推荐）</h3><p>写入Redis时，手动把对象序列化为JSON</p><p>读取Redis时，手动把读取到的JSON反序列化为对象</p><p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308193323552.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON工具</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testStringTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 准备对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;虎哥&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入一条数据到redis</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>, json);<br>    <span class="hljs-comment">// 读取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);<br>    <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(val, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br></code></pre></td></tr></table></figure><p>切记：此时这个类必须要<strong>添加无参的构造函数</strong>。否则会报错！</p><img src="/2022/03/08/Redis/Redis%E5%9F%BA%E7%A1%80/image-20220308195026207.png" class><p>可以看到反序列化后的对象正常输出</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode082删除排序链表中的重复元素II</title>
    <link href="/2022/03/07/Algo/LeetCode082%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <url>/2022/03/07/Algo/LeetCode082%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    
    <content type="html"><![CDATA[<p>有两个周没有刷算法题了，今天在剑指offer找到了这道题：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a>，当时觉得很简单，但是看到第二道题的时候我本来以为很简单，但是做了一会儿却觉得无从下手。两道题区别为：简单版本是把重复元素删除到剩下一个，而复杂版本是把重复的元素全部删除。</p><p>其实看到这种题目第一步肯定是创建一个dummyHead，因为当第一个节点就是重复节点的时候，有了一个假的头节点会比较好处理，即最后可以返回dummyHead.next。</p><h4 id="删除排序链表中的重复元素-II"><a href="#删除排序链表中的重复元素-II" class="headerlink" title="删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></h4><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>注意这里是一个排序链表，<strong>所以它相同的值的节点都是连续的</strong>，这对于我们解题至关重要</p><p>我们可以先创建一个prev节点，然后根据prev节点后面的不同状况来做出不同的处理</p><p>假设有一个链表如图所示：</p><ul><li>情况一</li></ul><img src="/2022/03/07/Algo/LeetCode082%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/image-20220307230111383.png" class><p>我们现在假设prev节点为1，head节点为2，此时让head一直向next移动，直到移到不为2的节点，其实就是它本身哈哈。这个时候很简单，我们直接让prev和head向后移动就可以了</p><ul><li>情况二</li></ul><img src="/2022/03/07/Algo/LeetCode082%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/image-20220307231356886.png" class><p>我们现在假设prev节点为2，head节点为3，此时让head一直向next移动，直到移到不为3的节点，即移动到红色的3节点处，这个时候直接让prev的next &#x3D; 红色节点的next，然后head后移就可以了</p><p>代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> dummyHead;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;  <span class="hljs-comment">// node 临时存储head</span><br>            <span class="hljs-keyword">while</span> (head.next != <span class="hljs-literal">null</span> &amp;&amp; head.val == head.next.val) head = head.next;<br>            <span class="hljs-keyword">if</span> (head == node) &#123;  <span class="hljs-comment">// 没有重复</span><br>                prev = prev.next;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 有重复</span><br>                prev.next = head.next;<br>            &#125;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此本道题解析结束,在这里多提一句，写这种算法题的解析感觉真的很比平时写别的文章麻烦很多啊，但我相信多多沉淀总是好的</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS源码剖析</title>
    <link href="/2022/03/05/JUC/AQS%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2022/03/05/JUC/AQS%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS源码剖析"><a href="#AQS源码剖析" class="headerlink" title="AQS源码剖析"></a>AQS源码剖析</h1><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>AQS (AbstractQueuedSynchronizer)是一个锁框架，它定义了锁的机制，开放出了可以拓展的地方，AQS开放出来state字段，让子类可以根据state字段决定是否可以获取锁，对于获取不到的会进行自动管理，子类无需担心。接下来我会在源码上带大家一起了解一下AQS</p><blockquote><p>在看的时候我十分希望你也点进源码里去看一看，你会发现不一样的世界。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Head of the wait queue, lazily initialized.  Except for</span><br><span class="hljs-comment"> * initialization, it is modified only via method setHead.  Note:</span><br><span class="hljs-comment"> * If head exists, its waitStatus is guaranteed not to be</span><br><span class="hljs-comment"> * CANCELLED.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 等待队列的头部，延迟初始化。 除了</span><br><span class="hljs-comment">  * 初始化，只能通过setHead方法修改。 </span><br><span class="hljs-comment">  笔记：</span><br><span class="hljs-comment">  * 如果head存在，则保证其waitStatus不能被取消</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span><br><span class="hljs-comment"> * method enq to add new wait node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 等待队列的尾部，延迟初始化。 仅通过修改</span><br><span class="hljs-comment">  * 方法 enq 添加新的等待节点。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The synchronization state.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 同步状态。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure><p>这是AQS源码里的三个成员属性</p><p>state用于判断共享资源是否被正在占用的标记位，volatile保证线程可见性，</p><p>资源占用有两种模式，独占（自己占用别人就不能占用），共享（自己占用，其他共享线程也能占用）</p><p>因此共享模式下可能会有多个线程正在共享资源，而int 类型则能表示共享线程数目。</p><p>如果一个线程在当前时刻没有获取到共享资源，那它就可以排队，而AQS是一个FIFO(先进先出)的双向链表，head 和 tail分别为头和尾。</p><p>Node源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/** waitStatus value to indicate thread has cancelled. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment"> * unconditionally propagate.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><span class="hljs-comment">// 等待状态</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><span class="hljs-comment">// 前指针</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><span class="hljs-comment">// 后指针</span><br><span class="hljs-keyword">volatile</span> Node next;<br><span class="hljs-comment">// 线程对象</span><br><span class="hljs-keyword">volatile</span> Thread thread;<br></code></pre></td></tr></table></figure><p>上面四个为枚举值，用来表示线程的状态</p><h2 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h2><p>接下来我们介绍acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法为final方法，不允许子类进行重写</p><p>如果acquireQueued尝试获得锁成功那就会直接跳出判断不再执行后面</p><p>如果获得失败那就会acquireQueued进入等待队列</p><p>下面我们详细分析acquireQueued和addWaiter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(mode);<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">oldTail</span> <span class="hljs-operator">=</span> tail;<br>            <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-literal">null</span>) &#123;<br>                node.setPrevRelaxed(oldTail);<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                    oldTail.next = node;<br>                    <span class="hljs-keyword">return</span> node;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                initializeSyncQueue();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是addWaiter源码，作用是将当前线程封装为一个node，插入等待队列，最后返回尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))<br>                interrupted |= parkAndCheckInterrupt();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">if</span> (interrupted)<br>            selfInterrupt();<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前节点是头节点的前一个节点，而且当前线程尝试获取锁成功了，那就直接返回当前节点。在这里强调一下，头节点是一个<strong>虚节点</strong>，意思是，头节点并不是当前需要去拿锁的节点，它只是一个占位摆设，而第二个节点才是真正要拿锁的节点，当它拿到锁以后，它就会变成头节点，头节点就会出队，所以在AQS源码经常会看到判断前置节点是否为头节点的代码。</p><p>if (shouldParkAfterFailedAcquire(p, node))线程如果获取锁失败后，那就要判断线程是否需要挂起了，为什么不自旋？因为自旋是一个很耗费CPU的操作，如果大量线程自旋，那会很耗费CPU，而挂起，在合适的适合叫醒，那就会很好缓解这个问题。</p><p>什么时候需要挂起呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This node has already set status asking a release</span><br><span class="hljs-comment">         * to signal it, so it can safely park.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">         * indicate retry.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">         */</span><br>        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前节点前置节点状态为SIGNAL，即前置节点也在等待锁，那就当前节点肯定拿不到锁，当前线程就是可以直接挂起的。</p><p>如果它状态大于0，那状态只能是CANCEL，就把它从队列删除，如果是其他状态，既然当前节点已经加入了，那它的前置节点就应该做好等待获取锁，通过CAS的方法将前置节点修改为SIGNAL，这两种情况返回的是false。</p><img src="/2022/03/05/JUC/AQS%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20220305222310019.png" class><blockquote><p>注：这里提示一下，以前看到这张图的时候，我以为所有node公用一个state,其实每个node都有一个state</p></blockquote><p>通过分析acquire方法，如果当前线程所在节点处于头节点的后面一个，那就会不断尝试进行拿锁，直到成功，否则就会进行挂起，如何判断是否需要挂起呢？那就是当前节点之前除了head还有别的节点，且状态为SINGLE那当前节点就需要被挂起，这样就能让head后只能有一个节点来获取锁，这样就能避免自旋消耗CPU，</p><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>release是用来释放锁的，加入尝试释放锁成功，那下一步就要去等待其他的节点，这里来分析一下unparkSuccessor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">     * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">     * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">     * non-cancelled successor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">          * unpark 的线程由后继保持，这很正常</span><br><span class="hljs-comment">          * 如果只唤醒下一个节点。 但如果取消或明显为空，</span><br><span class="hljs-comment">          * 从尾部向后遍历找到实际的</span><br><span class="hljs-comment">          * 未取消的继任者。</span><br><span class="hljs-comment">          */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != node &amp;&amp; p != <span class="hljs-literal">null</span>; p = p.prev)<br>            <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = p;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的参数node是acquireQueued的幸运儿，它早就获得了锁，它是链表的头节点，它首先通过CAS的方法把ws变为了0，这样就不会影响其他函数的判断。然后不停的向后找，找一个除了head外最靠前的节点，且waitStatus&lt;&#x3D;0的节点，然后对其LockSupport.unpark(s.thread);就是唤醒它，让它去争抢锁，被唤醒的线程会去执行acquire尝试自旋获取，这就形成了一个循环，还有值得一提的是这里的唤醒是从尾部向前唤醒获取的，请看注释！</p><h2 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这很简单，就是让子类去继承的一个方法，参数int表示对state的修改，返回值是bool表示是否获取锁，这就是让子类去重写这个方法否则就抛出不支持该操作的异常。拿这就给了上层很大的施展空间。</p><h2 id="tryRelase"><a href="#tryRelase" class="headerlink" title="tryRelase"></a>tryRelase</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法与tryAcquire类似，这里不进行讲解</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AQS</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>最近我去了一家公司实习，遇到驰哥（我的小leader），驰哥人非常Nice,大概大我两岁哈哈。讲了很多我以后可能会遇到的困难，我进去就问他了线程池的相关内容，他也仔细为我讲解了一番，接下来我写一篇文章详细记录一下。</p><p>刚开始我以为线程池很难，但是深入了解以后发现也就那样吧~</p><p>下面开始正文</p><p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305172101024.png" class><p>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p><p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p><p>就像是你开了一个饭馆（运行的程序），有一群人过来吃饭（多个任务），每一个人都需要一个服务员（需要多线程），你现在每次过来一个人就招聘一个服务员然后用完后将服务员辞退，这样就会消耗大量资源。</p><p>但是我们可以换一种方式，我们给餐馆里先放几个服务员，当服务员服务完以后就让它服务下一个或者休息，这样就能减少招聘和辞退的时间开销了</p><h2 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h2><h3 id="ThreadPoolExecutor的构造方法源码"><a href="#ThreadPoolExecutor的构造方法源码" class="headerlink" title="ThreadPoolExecutor的构造方法源码"></a><strong>ThreadPoolExecutor的构造方法源码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new &#123;<span class="hljs-doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span><br><span class="hljs-comment">     * parameters, the default thread factory and the default rejected</span><br><span class="hljs-comment">     * execution handler.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;It may be more convenient to use one of the &#123;<span class="hljs-doctag">@link</span> Executors&#125;</span><br><span class="hljs-comment">     * factory methods instead of this general purpose constructor.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><br><span class="hljs-comment">     *        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><br><span class="hljs-comment">     *        pool</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><br><span class="hljs-comment">     *        the core, this is the maximum time that excess idle threads</span><br><span class="hljs-comment">     *        will wait for new tasks before terminating.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><br><span class="hljs-comment">     *        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><br><span class="hljs-comment">     *        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="hljs-comment">     *         &#123;<span class="hljs-doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">     *         &#123;<span class="hljs-doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">     *         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="hljs-comment">     *         &#123;<span class="hljs-doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> workQueue&#125; is null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>             Executors.defaultThreadFactory(), defaultHandler);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到上面有七个参数</p><p><strong>核心线程数：corePoolSize</strong></p><p>线程池中活跃的线程数，即使它们是空闲的，除非设置了allowCoreThreadTimeOut为true。allowCoreThreadTimeOut的值是控制核心线程数是否在没有任务时是否停止活跃的线程，当它的值为true时，在线程池没有任务时，所有的工作线程都会停止。</p><p><strong>最大线程数：maximumPoolSize</strong></p><p>线程池所允许存在的最大线程数。</p><p>非核心线程数量&#x3D;maximumPoolSize-corePoolSize</p><p><strong>多余线程存活时长：keepAliveTime</strong></p><p>线程池中除核心线程数之外的线程（多余线程）的最大存活时间，如果在这个时间范围内，多余线程没有任务需要执行，则多余线程就会停止。(注意：多余线程数 &#x3D; 最大线程数 - 核心线程数)</p><p><strong>时间单位：unit</strong></p><p>多余线程存活时间的单位，可以是分钟、秒、毫秒等。</p><p><strong>任务队列：workQueue</strong></p><p>ArrayBlockingQueue,LinkBlockingQueue</p><p>线程池的任务队列，使用线程池执行任务时，任务会先提交到这个队列中，然后工作线程取出任务进行执行，当这个队列满了，线程池就会执行拒绝策略。</p><p><strong>线程工厂：threadFactory</strong></p><p>创建线程池的工厂，线程池将使用这个工厂来创建线程池，自定义线程工厂需要实现ThreadFactory接口。</p><p><strong>拒绝执行处理器（也称拒绝策略）：handler</strong></p><ul><li>AbortPolicy：线程任务丢弃报错（默认）</li><li>DiscardPolicy：线程任务丢弃不报错 </li><li>DiscardOldestPolicy：将worlQueue队首任务丢弃，将最新的线程任务加入到线程队列</li><li>CallerRunsPolicy：线程池外的线程直接调用run方法执行</li></ul><p>当线程池无空闲线程，并且任务队列已满，此时将线程池将使用这个处理器来处理新提交的任务。</p><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305174918009.png" class><ol><li>线程池执行execute&#x2F;submit方法向线程池添加任务，当线程数小于corePoolSize的时候，线程池就可以创建新的线程</li><li>当任务大于核心线程数时，就向队列添加任务</li><li>如果队列满了，就要通过比较maxinumPolSize，如果当前线程数小于maxinumPolSize在线程池创建新的线程，否则就会执行饱和策略</li></ol><p>在这里举个驰哥给我讲的例子：假如现在有银行就是我们的线程池，现在银行有5个业务员（corePoolSize），50个座位（workQueue），还有5个办公座位但是他们都去休假了（maximumPoolSize-corePoolSize），现在有50个人去办理业务，刚开始5个营业员全部上阵，即corePoolSize全部挂起，但是人实在是太多了，用户就不得不坐到座位上去排队，多余的进入阻塞队列workQueue，但是这个时候座位也不够用了，行长会立刻把其他的5个休假的员工全部叫回来工作，然后让此时还没有坐下或者办理业务的直接回家，同时银行关门（AbortPolicy），或者然后让此时还没有坐下或者办理业务的直接回家，但是银行不关门（AbortPolicy），或者让正在办理的直接停止办理，让其他还没坐下的进行办理（AbortPolicy）。当办理的差不多的时候，银行还在休假却被迫叫回来工作的人当闲置超过一定时间(keepAliveTime)后,行长就会叫他们回去休息。</p><h2 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h2><p>当大家看到这些线程池类型的时候不要害怕，其实就是提前把一些核心线程规定死了，Executors类中存储了各种类型参数，接下来我会在源码层面来剖析下面的几种线程</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                      threadFactory);<br>    &#125;<br></code></pre></td></tr></table></figure><p>看一下上面的构造方法</p><p>核心线程数，最大线程数为同一个值且自己指定</p><p>相比下面将要介绍的newCachedThreadPool，newFixedThreadPool 可控制线程最大并发数，当线程池中的线程数达到其设定大小时，其余新创建的线程会在LinkedBlockingQueue队列中等待。当线程池中的某个线程失败而终止时，新的线程会代替它执行剩下的任务。线程池中的线程只有在显式调用shutdown函数时才会退出线程池</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>核心线程数，最大线程数2^31-1,最大空闲时间60s</p><p>创建 <strong>可缓存</strong>线程池，当线程池中的线程空闲时间超过60s，便会终止该空闲线程并从缓存线程池中移除</p><p>该线程池<strong>可根据需要，创建新线程</strong>，从上面代码中可以看出，其线程数最大可为Integer.MAX_VALUE，如果控制不好，使用该线程池可能导致线程创建过多，反而影响性能。因此，可以注意一下该线程池的使用场景：对于<strong>大量短暂异步任务</strong>的程序来说，使用该线程池能够<strong>大大提高性能</strong> </p><p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>创建<strong>单线程</strong>的线程池 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                threadFactory));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到构造函数里只允许一个线程</p><p>该单线程在shutdown之前由于失败而终止时，将会有新的线程来代替它执行剩下任务。加入到该线程池里的线程会按顺序执行，一个时刻保证 <strong>只有一个线程</strong>在运行</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>创建 <strong>固定大小</strong>且能够执行 <strong>定时或周期性</strong>任务的线程池 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里指定了corePoolSize 和工厂类型</p><h2 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>是一个基于数组结构的<strong>有界</strong>阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305193326775.png" class><ul><li>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。</li><li>队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。</li><li>按照先进先出（FIFO）原则对元素进行排序。</li><li>默认不保证线程公平的访问队列。</li><li>公平访问队列：按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。</li><li>非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格。有可能先阻塞的线程最后才访问访问队列。</li><li>公平性会降低吞吐量。</li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>一个基于链表结构的阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列。（newFixedThreadPool 用于创建固定线程数）</p><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305193501103.png" class><ul><li>LinkedBlockingQueue具有单链表和<strong>无界</strong>阻塞队列的功能。</li><li>队列慢时插入操作被阻塞，队列空时，移除操作被阻塞。</li><li>默认和最大长度为Integer.MAX_VALUE，相当于无界(值非常大：2^31-1)。</li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用这个队列。（newCachedThreadPool 用于根据需要创建新线程）</p><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305194503741.png" class><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>一个具有优先级的无限阻塞队列。</p><h2 id="如何合理配置线程池参数"><a href="#如何合理配置线程池参数" class="headerlink" title="如何合理配置线程池参数"></a>如何合理配置线程池参数</h2><p>自定义线程池需要配置maxinumPoolSize</p><h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>CPU密集型意思是该任务需要大量的运算，没有阻塞，CPU一直全速运行，CPU密集型只有在多核CPU才可以加速，而单核CPU无论几个线程都不可能加速。</p><h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><p>即该任务需要大量IO，即大量的阻塞，单线程上运行IO密集型任务会导致大量CPU浪费在阻塞上，所以多线程可以使用IO密集型</p><p>IO密集型公式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CPU</span>核数*<span class="hljs-number">2</span><br><br><span class="hljs-attribute">CPU</span>核数/（<span class="hljs-number">1</span>-阻塞系数）阻塞系数通常在<span class="hljs-number">0</span>.<span class="hljs-number">8</span>~<span class="hljs-number">0</span>.<span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><h3 id="得到自己的CPU核数"><a href="#得到自己的CPU核数" class="headerlink" title="得到自己的CPU核数"></a>得到自己的CPU核数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCpuCoreNumber</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Runtime.getRuntime().availableProcessors());<br>    &#125;<br></code></pre></td></tr></table></figure><img src="/2022/03/05/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220305195451067.png" class><p>可以看到我的电脑为8核</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream</title>
    <link href="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/"/>
    <url>/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>速度更快</p><p><strong>lanbda表达式</strong></p><p><strong>强大的Stream API</strong></p><p>便于并行</p><p>最大化减少空指针异常 Optional</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>即一种匿名函数，可以将其理解为一段可以传递的到吗。可以用通过它写出更加简介灵活的代码。</p><figure class="highlight livescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型，参数名称)</span> -&gt;</span>&#123;代码体&#125;<br></code></pre></td></tr></table></figure><p><strong>格式说明</strong></p><ul><li>(参数类型，参数名称)： 参数列表</li><li>{代码体}：方法体</li><li>-&gt;分割参数和代码</li></ul><h2 id="lambda常用方法举例"><a href="#lambda常用方法举例" class="headerlink" title="lambda常用方法举例"></a>lambda常用方法举例</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadTest2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 准备一个集合，按照年龄进行排序</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">persons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">3</span>));<br>    persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">2</span>));<br>    persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">3</span>));<br>    persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">4</span>));<br>    Collections.sort(persons, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o2.getAge() - o1.getAge();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// lambda方法</span><br>    Collections.sort(persons, ((Person o1, Person o2) -&gt; o1.getAge() - o2.getAge()));<br>    <span class="hljs-comment">// Comparator方法</span><br>    Collections.sort(persons, (Comparator.comparingInt(Person::getAge)));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;run.&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>&#125;<br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadTest1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; System.out.println(<span class="hljs-string">&quot;run...&quot;</span>)).start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><img src="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/image-20220304142440618.png" class><p>stream流式思想类似于<strong>生产流水线</strong>，Stream流不是一种数据结构，不保存数据，而是对数据进行加工 处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。</p><p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和归约。</p><h3 id="获取stream流两种方式"><a href="#获取stream流两种方式" class="headerlink" title="获取stream流两种方式"></a>获取stream流两种方式</h3><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 集合获取流</span><br><span class="hljs-comment">// Collection接口中的方法: default Stream&lt;E&gt; stream() 获取流</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>Stream&lt;String&gt; stream1 = list.stream();<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>Stream&lt;String&gt; stream2 = set.stream();<br>Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>Stream&lt;String&gt; stream3 = vector.stream();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>java.util.Map</code> 接口不是 Collection 的子接口，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// Map获取流</span><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">// ...</span><br>Stream&lt;String&gt; keyStream = map.keySet().stream();<br>Stream&lt;String&gt; valueStream = map.values().stream();<br>Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();<br>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">// Map获取流 Map map = new HashMap&lt;&gt;(); // ... Stream keyStream = map.keySet().stream(); Stream valueStream = map.values().stream(); Stream&gt; entryStream = map.entrySet().stream(); &#125;</span><br></code></pre></td></tr></table></figure><h4 id="方式2-Stream中的静态方法of获取流"><a href="#方式2-Stream中的静态方法of获取流" class="headerlink" title="方式2 : Stream中的静态方法of获取流"></a>方式2 : Stream中的静态方法of获取流</h4><p>由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// Stream中的静态方法: static Stream of(T... values)</span><br>Stream&lt;String&gt; stream6 = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br>String[] arr = &#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>&#125;;<br>Stream&lt;String&gt; stream7 = Stream.of(arr);<br>Integer[] arr2 = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br>Stream&lt;Integer&gt; stream8 = Stream.of(arr2);<br><span class="hljs-comment">// 注意:基本数据类型的数组不行</span><br><span class="hljs-type">int</span>[] arr3 = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br>Stream&lt;<span class="hljs-type">int</span>[]&gt; stream9 = Stream.of(arr3);<br></code></pre></td></tr></table></figure><blockquote><p> 备注： of 方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h3 id="stream-常用方法"><a href="#stream-常用方法" class="headerlink" title="stream 常用方法"></a>stream 常用方法</h3><table><thead><tr><th>方法名</th><th>方法作用</th><th>返回值</th><th>方法种类</th></tr></thead><tbody><tr><td>forEach</td><td>逐一处理</td><td>void</td><td>终结</td></tr><tr><td>count</td><td>统计个数</td><td>long</td><td>终结</td></tr><tr><td>filter</td><td>过滤</td><td>Stream</td><td>函数拼接</td></tr><tr><td>limit</td><td>取用前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>skip</td><td>跳过前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>map</td><td>映射</td><td>Stream</td><td>函数拼接</td></tr><tr><td>concat</td><td>组合</td><td>Stream</td><td>函数拼接</td></tr></tbody></table><p>终结方法：返回值类型不再是 Stream 类型的方法，不再支持链式调用。本小节中，终结方法包括 count 和 forEach 方法。 </p><p>非终结方法：返回值类型仍然是 Stream 类型的方法，支持链式调用。（除了终结方法外，其余方法均为非终结 方法。）</p><h3 id="stream注意事项"><a href="#stream注意事项" class="headerlink" title="stream注意事项"></a>stream注意事项</h3><ol><li>Stream只能操作一次 </li><li>Stream方法返回的是新的流</li><li>不调用终结方法，中间的操作不会执行</li></ol><h3 id="高级集合的stream方法"><a href="#高级集合的stream方法" class="headerlink" title="高级集合的stream方法"></a>高级集合的stream方法</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach 用来遍历流中的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testForEach</span><span class="hljs-params">()</span> &#123;<br>        List&lt;String&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Collections.addAll(one, <span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>, <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>);<br>        one.stream().forEach((String s) -&gt; &#123;<br>            System.out.println(s);<br>        &#125;);<br>        <span class="hljs-comment">// 简写</span><br>        one.stream().forEach(s -&gt; System.out.println(s));<br>        one.stream().forEach(System.out::println);<br>        one.forEach(System.out::println);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">testCount</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">addAll</span>(one, <span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>, <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>);<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(one.<span class="hljs-title function_">stream</span>().<span class="hljs-title function_">count</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>可以通过 filter 方法将一个流转换成另一个子集流。方法声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; predicate)</span><br></code></pre></td></tr></table></figure><img src="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/image-20220304150606735.png" class><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p> Stream流中的 filter 方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFilter</span><span class="hljs-params">()</span> &#123;<br>List&lt;String&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(one, <span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>, <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>);<br>one.stream().filter(s -&gt; s.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 方法可以对流进行截取，只取用前n个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLimit</span><span class="hljs-params">()</span> &#123;<br>List&lt;String&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(one, <span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>, <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>);<br>one.stream().limit(<span class="hljs-number">3</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSkip</span><span class="hljs-params">()</span> &#123;<br>List&lt;String&gt; one = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(one, <span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-string">&quot;宋远桥&quot;</span>, <span class="hljs-string">&quot;苏星河&quot;</span>, <span class="hljs-string">&quot;老子&quot;</span>, <span class="hljs-string">&quot;庄子&quot;</span>, <span class="hljs-string">&quot;孙子&quot;</span>);<br>one.stream().skip(<span class="hljs-number">2</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stream流中的方法"><a href="#stream流中的方法" class="headerlink" title="stream流中的方法"></a>stream流中的方法</h3><h4 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h4><p>利用map方法用一个对另一个进行映射</p><img src="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/image-20220304152557456.png" class><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMap</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 转化为流式数据</span><br>       Stream&lt;String&gt; original = Stream.of(<span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-string">&quot;33&quot;</span>);<br>       <span class="hljs-comment">// 流式数据利用map进行映射</span><br>       Stream&lt;Integer&gt; result = original.map(Integer::parseInt);<br>       <span class="hljs-comment">// 进行遍历</span><br>       result.forEach(s -&gt; System.out.println(s + <span class="hljs-number">10</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="sorted方法"><a href="#sorted方法" class="headerlink" title="sorted方法"></a>sorted方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSorted</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// sorted(): 根据元素的自然顺序排序</span><br><span class="hljs-comment">// sorted(Comparator&lt;? super T&gt; comparator): 根据比较器指定的规则排序</span><br>Stream.of(<span class="hljs-number">33</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">55</span>)<br>.sorted()<br>.sorted((o1, o2) -&gt; o2 - o1)<br>.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>用来去除重复数据，自定义对象根据对象的hashCode和equals来去除重复元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDistinct</span><span class="hljs-params">()</span> &#123;<br>Stream.of(<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">33</span>)<br>.distinct()<br>.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>用于条件匹配，返回true或false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatch</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// .allMatch(e -&gt; e &gt; 0); // allMatch: 元素是否全部满足条件</span><br><span class="hljs-comment">// .anyMatch(e -&gt; e &gt; 5); // anyMatch: 元素是否任意有一个满足条件</span><br>.noneMatch(e -&gt; e &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// noneMatch: 元素是否全部不满足条件</span><br>System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure><p>find</p><p>如果需要找到某些数据，可以使用 find 相关方法。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFind</span><span class="hljs-params">()</span> &#123;<br>Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>).findFirst();<br>System.out.println(<span class="hljs-string">&quot;first = &quot;</span> + first.get());<br>Optional&lt;Integer&gt; any = Stream.of(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>).findAny();<br>System.out.println(<span class="hljs-string">&quot;any = &quot;</span> + any.get());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="max-or-min"><a href="#max-or-min" class="headerlink" title="max or min"></a>max or min</h4><img src="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/image-20220304155554435.png" class><p>如果需要获取最大和最小值，可以使用 max 和 min 方法。方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;T&gt; <span class="hljs-title function_">max</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span>;<br>Optional&lt;T&gt; <span class="hljs-title function_">min</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span>;<br></code></pre></td></tr></table></figure><p>基本使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMax_Min</span><span class="hljs-params">()</span> &#123;<br>Optional&lt;Integer&gt; max = Stream.of(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>).max((o1, o2) -&gt; o1 - o2);<br>System.out.println(<span class="hljs-string">&quot;first = &quot;</span> + max.get());<br>Optional&lt;Integer&gt; min = Stream.of(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>).min((o1, o2) -&gt; o1 - o2);<br>System.out.println(<span class="hljs-string">&quot;any = &quot;</span> + min.get());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReduce</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">reduce</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>)<br>            .reduce(<span class="hljs-number">0</span>, (a, b) -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b);<br>                <span class="hljs-keyword">return</span> a + b;<br>            &#125;);<br>    System.out.println(reduce);<br>&#125;<br><span class="hljs-comment">// reduce:</span><br><span class="hljs-comment">// 第一次将默认做赋值给x, 取出第一个元素赋值给y,进行操作</span><br><span class="hljs-comment">// 第二次,将第一次的结果赋值给x, 取出二个元素赋值给y,进行操作</span><br><span class="hljs-comment">// 第三次,将第二次的结果赋值给x, 取出三个元素赋值给y,进行操作</span><br><span class="hljs-comment">// 第四次,将第三次的结果赋值给x, 取出四个元素赋值给y,进行操作</span><br><span class="hljs-type">int</span> <span class="hljs-variable">reduce2</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>)<br>.reduce(<span class="hljs-number">0</span>, (x, y) -&gt; &#123;<br><span class="hljs-keyword">return</span> Integer.sum(x, y);<br>&#125;);<br><span class="hljs-type">int</span> <span class="hljs-variable">reduce3</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>).reduce(<span class="hljs-number">0</span>, Integer::sum);<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>)<br>.reduce(<span class="hljs-number">0</span>, (x, y) -&gt; &#123;<br><span class="hljs-keyword">return</span> x &gt; y ? x : y;<br>&#125;);<br>System.out.println(<span class="hljs-string">&quot;max = &quot;</span> + max);<br></code></pre></td></tr></table></figure><p>输出如下：</p><img src="/2022/03/04/Java%E5%9F%BA%E7%A1%80/Stream/image-20220304160309736.png" class><p>由此可见求出了总和</p><h4 id="map和reduce组合使用"><a href="#map和reduce组合使用" class="headerlink" title="map和reduce组合使用"></a>map和reduce组合使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMapReduce</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 求出所有年龄的总和</span><br><span class="hljs-type">int</span> <span class="hljs-variable">totalAge</span> <span class="hljs-operator">=</span> Stream.of(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">58</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张学友&quot;</span>, <span class="hljs-number">56</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;郭富城&quot;</span>, <span class="hljs-number">54</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;黎明&quot;</span>, <span class="hljs-number">52</span>))<br>.map((p) -&gt; p.getAge())<br>.reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x + y);<br>System.out.println(<span class="hljs-string">&quot;totalAge = &quot;</span> + totalAge);<br><span class="hljs-comment">// 找出最大年龄</span><br><span class="hljs-type">int</span> <span class="hljs-variable">maxAge</span> <span class="hljs-operator">=</span> Stream.of(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;刘德华&quot;</span>, <span class="hljs-number">58</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;张学友&quot;</span>, <span class="hljs-number">56</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;郭富城&quot;</span>, <span class="hljs-number">54</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;黎明&quot;</span>, <span class="hljs-number">52</span>))<br>.map((p) -&gt; p.getAge())<br>.reduce(<span class="hljs-number">0</span>, (x, y) -&gt; x &gt; y ? x : y);<br>System.out.println(<span class="hljs-string">&quot;maxAge = &quot;</span> + maxAge);<br><span class="hljs-comment">// 统计 数字2 出现的次数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>.map(i -&gt; &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;)<br>.reduce(<span class="hljs-number">0</span>, Integer::sum);<br>System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testContact</span><span class="hljs-params">()</span> &#123;<br>Stream&lt;String&gt; streamA = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>);<br>Stream&lt;String&gt; streamB = Stream.of(<span class="hljs-string">&quot;李四&quot;</span>);<br>Stream&lt;String&gt; result = Stream.concat(streamA, streamB);<br>result.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Stream流中的结果到集合中"><a href="#Stream流中的结果到集合中" class="headerlink" title="Stream流中的结果到集合中"></a>Stream流中的结果到集合中</h3><p>Stream流提供 collect 方法，其参数需要一个 java.util.stream.Collector 接口对象来指定收集到哪 种集合中。java.util.stream.Collectors 类提供一些方法，可以作为 Collector&#96;接口的实例：</p><p>public static  Collector&gt; toList() ：转换为 List 集合。</p><p>public static  Collector&gt; toSet() ：转换为 Set 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将流中数据收集到集合中</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStreamToCollection</span><span class="hljs-params">()</span> &#123;<br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br><span class="hljs-comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="hljs-comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br>ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="hljs-keyword">new</span>));<br>HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="hljs-keyword">new</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Stream流中的结果到数组中"><a href="#Stream流中的结果到数组中" class="headerlink" title="Stream流中的结果到数组中"></a>Stream流中的结果到数组中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStreamToArray</span><span class="hljs-params">()</span> &#123;<br>Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br><span class="hljs-comment">// Object[] objects = stream.toArray();</span><br><span class="hljs-comment">// for (Object obj : objects) &#123;</span><br><span class="hljs-comment">// System.out.println();</span><br><span class="hljs-comment">// &#125;</span><br>String[] strings = stream.toArray(String[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-keyword">for</span> (String str : strings) &#123;<br>System.out.println(str);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对流中数据进行聚合计算"><a href="#对流中数据进行聚合计算" class="headerlink" title="对流中数据进行聚合计算"></a>对流中数据进行聚合计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStreamToOther</span><span class="hljs-params">()</span> &#123;<br>Stream&lt;Student&gt; studentStream = Stream.of(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>, <span class="hljs-number">58</span>, <span class="hljs-number">95</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;杨颖&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">88</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;迪丽热巴&quot;</span>, <span class="hljs-number">56</span>, <span class="hljs-number">99</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;柳岩&quot;</span>, <span class="hljs-number">52</span>, <span class="hljs-number">77</span>));<br><span class="hljs-comment">// 获取最大值</span><br><span class="hljs-comment">// Optional&lt;Student&gt; collect = studentStream.collect(Collectors.maxBy((o1, o2) -&gt;</span><br>o1.getSocre() - o2.getSocre()));<br><span class="hljs-comment">// 获取最小值</span><br><span class="hljs-comment">// Optional&lt;Student&gt; collect = studentStream.collect(Collectors.minBy((o1, o2) -&gt;</span><br>o1.getSocre() - o2.getSocre()));<br><span class="hljs-comment">// System.out.println(collect.get());</span><br><span class="hljs-comment">// 求总和</span><br><span class="hljs-comment">// int sumAge = studentStream.collect(Collectors.summingInt(s -&gt; s.getAge()));</span><br><span class="hljs-comment">// System.out.println(&quot;sumAge = &quot; + sumAge);</span><br><span class="hljs-comment">// 平均值</span><br><span class="hljs-comment">// double avgScore = studentStream.collect(Collectors.averagingInt(s -&gt; s.getSocre()));</span><br><span class="hljs-comment">// System.out.println(&quot;avgScore = &quot; + avgScore);</span><br><span class="hljs-comment">// 统计数量</span><br><span class="hljs-comment">// Long count = studentStream.collect(Collectors.counting());</span><br><span class="hljs-comment">// System.out.println(&quot;count = &quot; + count);</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2022/03/04/utils/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2022/03/04/utils/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备<br>Ctrl + P 方法参数提示显示 （必备<br>Ctrl + J 插入自定义动态代码模板 （必备<br>Ctrl + P 方法参数提示显示 （必备<br>Ctrl + O 选择可重写的方法<br>Ctrl + I 选择可继承的方法<br>Ctrl + Delete 删除光标后面的单词或是中文句 （必备）<br>Ctrl +BackSpace 删除光标前面的单词或是中文句 （必备<br>Ctrl + 左方向键 光标跳转到当前单词 &#x2F; 中文句的左侧开头位置 （必备）<br>Ctrl + 右方向键 光标跳转到当前单词 &#x2F; 中文句的右侧开头位置 （必备）<br>Ctrl + 前方向键 等效于鼠标滚轮向前效果 （必备）<br>Ctrl + 后方向键 等效于鼠标滚轮向后效果 （必备）</p><p>Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等 （必备）！！！！！！！！！<br>Ctrl + Alt + V 快速引进变量<br>Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备<br>Ctrl + Shift + &#x2F; 代码块注释 （必备<br>Alt + Enter 导入方法<br>Ctrl + Alt +T环绕对象 可选择 try if while等<br>Alt + 7 项目结构图</p>]]></content>
    
    
    <categories>
      
      <category>utils</category>
      
    </categories>
    
    
    <tags>
      
      <tag>utils</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java:错误:不支持发行版5</title>
    <link href="/2022/03/04/error/java-%E9%94%99%E8%AF%AF-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%885/"/>
    <url>/2022/03/04/error/java-%E9%94%99%E8%AF%AF-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%885/</url>
    
    <content type="html"><![CDATA[<h1 id="java-错误-不支持发行版本-5"><a href="#java-错误-不支持发行版本-5" class="headerlink" title="java: 错误: 不支持发行版本 5"></a>java: 错误: 不支持发行版本 5</h1><p>在Intellij idea中新建了一个Maven项目，运行时报错如下：Error : java 不支持发行版本5</p><img src="/2022/03/04/error/java-%E9%94%99%E8%AF%AF-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%885/image-20220304104221601.png" class><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>文件-&gt;项目结构</li></ol><img src="/2022/03/04/error/java-%E9%94%99%E8%AF%AF-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%885/image-20220304104433592.png" class><p>查看两个JDK版本是否一致</p><ol start="2"><li>设置-&gt;构建、执行、部署-&gt;Java编译器</li></ol><img src="/2022/03/04/error/java-%E9%94%99%E8%AF%AF-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%8F%91%E8%A1%8C%E7%89%885/image-20220304105352604.png" class><p>修改这里的目标字节码为当前JDK版本</p><p>在pom.xml添加以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>至此，所有设置已经完成</p>]]></content>
    
    
    <categories>
      
      <category>Error</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Error</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JVN垃圾回收"><a href="#JVN垃圾回收" class="headerlink" title="JVN垃圾回收"></a>JVN垃圾回收</h1><p>JVM主要分为三大部分内容：内存模型，垃圾回收和类加载</p><p>今天讲解的垃圾回收主要分为两大部分，分别是：垃圾回收算法和垃圾回收器。其中也包括一些垃圾回收基础知识，比如minor gc 和 full gc的区别等等</p><h2 id="判断垃圾是否可以回收"><a href="#判断垃圾是否可以回收" class="headerlink" title="判断垃圾是否可以回收"></a>判断垃圾是否可以回收</h2><p>现在市面上的垃圾判断算法主要有两种，一种是引用计数法，这是python正在用的。一种是可达性分析法，这是Java正在用的，下面我们进行详细讲解。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>当有一个对象被引用时它的计数器就+1，但是这样可能会造成一个弊端，那就是当两个对象相互引用的时候，它们都不能被释放。</p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228231717227.png" class><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>这是Java正在使用的算法</p><ul><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li></ul><h2 id="GC-Root都有哪些"><a href="#GC-Root都有哪些" class="headerlink" title="GC Root都有哪些"></a>GC Root都有哪些</h2><p>可以作为GC Root的对象</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li></ul><p>　</p><p>如下代码所示，a 是栈帧中的本地变量，当 a &#x3D; null 时，由于此时 a 充当了 <strong>GC Root</strong> 的作用，a 与原来指向的实例 <strong>new Test()</strong> 断开了连接，所以对象会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java">publicclass Test &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>a = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法区中类静态属性引用的对象</li></ul><p>如下代码所示，当栈帧中的本地变量 a &#x3D; null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，<strong>s 在此时是类静态属性引用</strong>，充当了 GC Root 的作用，它指向的对象依然存活!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>a.s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>a = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法区中常量引用的对象</li></ul><p>如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Test</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    a = <span class="hljs-literal">null</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><p>这是简单给不清楚本地方法为何物的童鞋简单解释一下：所谓本地方法就是一个 java 调用非 java 代码的接口，该方法并非 Java 实现的，可能由 C 或 Python等其他语言实现的， Java 通过 JNI 来调用本地方法， 而本地方法是以库文件的形式存放的（在 WINDOWS 平台上是 DLL 文件形式，在 UNIX 机器上是 SO 文件形式）。</p><p>当调用 Java 方法时，虚拟机会创建一个栈桢并压入 Java 栈，而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305164427347.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">NIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title function_">Java_com_pecuyu_jnirefdemo_MainActivity_newStringNative</span><span class="hljs-params">(JNIEnv *env, jobject instance，jstring jmsg)</span> &#123;<br>...<br>   <span class="hljs-comment">// 缓存String的class</span><br>   <span class="hljs-type">jclass</span> <span class="hljs-variable">jc</span> <span class="hljs-operator">=</span> (*env)-&gt;FindClass(env, STRING_PATH);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，当 java 调用以上本地方法时，jc 会被本地方法栈压入栈中, jc 就是我们说的本地方法栈中 JNI 的对象引用，因此只会在此本地方法执行完成后才会被释放。</p><h2 id="五种引用类型"><a href="#五种引用类型" class="headerlink" title="五种引用类型"></a>五种引用类型</h2><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228231943521.png" class><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>一般来说我们new的对象都属于强引用</p><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4M</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span><br>ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br>List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4M]);<br><br><span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span><br>Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br><span class="hljs-keyword">while</span>(poll != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span><br>list.remove(poll);<br><span class="hljs-comment">//移动到引用队列中的下一个元素</span><br>poll = queue.poll();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>jvm有四种垃圾回收算法、我们将从效率和空间等方面来对比各个算法。</p><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228232550197.png" class><p>这个算法极为简单，总体分为两步</p><p>第一步：利用可达性去遍历内存，把垃圾对象进行标记；</p><p>第二步：再遍历一遍，把垃圾进行回收</p><p>特点：效率差，实现简单，但是会剩下很多碎片空间，可能会导致程序之后运行的时候有空间但没有连续的大空间而不得已进行GC。</p><h3 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h3><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228232734889.png" class><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228232826488.png" class><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h2 id="分带回收"><a href="#分带回收" class="headerlink" title="分带回收"></a>分带回收</h2><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220228232952024.png" class><p>此时Java内存会分为新生代和老年代，新创建的对象都被放在了新生代的伊甸园中。</p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220301234501199.png" class><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220301234516415.png" class><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220301234526373.png" class><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><p>吞吐量：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 &#x3D; 运行用户代码时间 &#x2F; ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li></ul><h2 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h2><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="*垃圾回收器"></a>*垃圾回收器</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS追求高吞吐量，基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>初始标记，主要是标记GC Root的下级对象，会STW，但是和GC Root相关联的对象不多，所以时间很短。</li><li>并发标记，根据上一步的结果，继续向下标识所有关联的对象被，直到尽头，这个过程是多线程的，没有STW。</li><li>重新标记，就是再标记一次，因为上一步可能有的线程在运行过程中会再产生垃圾。</li><li>并发清除，清除认为死亡的对象</li></ol><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><ol><li><strong>并发回收导致CPU资源紧张</strong>，它不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，降低吞吐量。</li><li><strong>无法清理浮动垃圾</strong>，在并发标记和清除阶段，用户程序还在继续运行，还会伴随有新的垃圾产生，这一部分垃圾出现在标记过程结束以后，CMS无法清除它们，只能留到下一次垃圾回收的时候进行清理。</li><li><strong>并发失败</strong>，由于回收阶段程序还在并发执行，所以要留足够的内存给用户使用，因此CMS不能像其他垃圾回收器一样等老年代满了的时候再进行垃圾回收，默认情况下92%时就会进行垃圾回收。</li></ol><p>这里有一个风险，就是当CMS运行期间预留内存无法满足程序分配新需要的时候，就会出现“并发失败”的情况。这时候就会STW，时间非常漫长</p><ol start="4"><li><strong>内存碎片</strong>，CMS基于标记清除法进行垃圾回收，因此当大对象过多的时候会带来很多麻烦，即使内存很多，但是却没有一块大的内存，不得不进行Full GC.</li></ol><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1是一款非常厉害的垃圾回收器，JDK 9以后默认使用，而且替代了CMS 收集器</p><p><strong>适用场景</strong></p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305160230556.png" class><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>G1垃圾回收阶段</strong></p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305160324463.png" class><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h4 id="分区算法region"><a href="#分区算法region" class="headerlink" title="分区算法region"></a><strong>分区算法region</strong></h4><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><ul><li>会STW</li></ul><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305160826717.png" class><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305160524775.png" class><h5 id="Young-Collection-CM（并发标记）"><a href="#Young-Collection-CM（并发标记）" class="headerlink" title="Young Collection + CM（并发标记）"></a>Young Collection + CM（并发标记）</h5><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305160937129.png" class><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305161211242.png" class><h4 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305161345437.png" class><ul><li>卡表与Remembered Set<ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过post-write barried + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>G1垃圾回收分为四个过程</p><ol><li>初始标记（会STW）：仅仅标记GC能直接关联到的对象，让下一阶段用户线程并发执行的时候，能正确的再可用Region这分配新的对象，这个过程时间非常短</li><li>并发标记：从GC Root进行可达性分析，找到要回收的对象，这个阶段耗时较长，但是会和用户程序并发执行，在对象图扫描完成以后，要重新处理在并发过程中有变动的引用对象</li><li>最终标记（会STW）：对用户线程做短暂暂停，处理并发阶段结束后仍然有引用变动的对象。</li><li>清理阶段（会STW） ：更新Regin的统计数据，对各个Region的回收价值进行成本排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多Region构成回收集，把决定回收的region复制到新的region，再清除掉原来的整个Region</li></ol><h3 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h3><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305161439176.png" class><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在<strong>处理过程结束之前</strong>A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305161626021.png" class><h3 id="空间分配担保原则"><a href="#空间分配担保原则" class="headerlink" title="空间分配担保原则"></a>空间分配担保原则</h3><img src="/2022/02/28/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220305163001997.png" class><p>至此我了解到的有关JVM内容皆如上，欢迎大家评论</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM内存结构</title>
    <link href="/2022/02/27/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2022/02/27/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><img src="/2022/02/27/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20220227232032763.png" class><p>如上图所示，JVM分为5大区域，程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中除了堆和方法区外全部线程私有。</p><ul><li>程序计数器</li></ul><p>线程私有，是一块很小的空间，是当前线程的指示器，记录下一条指令的地址。与计算机CPU内程序计数器作用类似。</p><ul><li>虚拟机栈</li></ul><p>线程私有，每个方法执行的时候就创建一个栈帧，用于存储局部变量，操作数、动态链接和方法返回等信息，当请求栈超过虚拟机允许的最大深度的时候，会有StackOverFlow</p><ul><li>本地方法栈</li></ul><p>线程私有，保存native方法信息，当一个JVM创建的线程调用native方法后，jvm不会在虚拟机中创建栈帧，而是简单的动态链接后直接调用<br>本地方法栈和虚拟机栈发挥的作用基本一样。区别是:本地方法栈执行的是Native方法服务,而虚拟机栈执行的是java方法。在HotSpot vm中本地方法栈和虚拟机栈合二为一。</p><img src="/2022/02/27/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/e9d511ea.png" class><ul><li>堆</li></ul><p>Java堆是所有线程共享的一块内存，几乎所有对象实例和数组都要在堆上分配内存，经常垃圾回收</p><ul><li>方法区</li></ul><p>存放类加载信息、常量、静态变量等等。即永久代，在JDK1.8后不存在方法区了，被元数据区所代替了，原方法区被划分成了两个部分： </p><ol><li>加载到类信息</li><li>运行时常量池</li></ol><p>加载的类信息被保存在了元数据区，运行时常量池保存在堆中。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap深度剖析</title>
    <link href="/2022/02/26/Java%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
    <url>/2022/02/26/Java%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap深度剖析"><a href="#ConcurrentHashMap深度剖析" class="headerlink" title="ConcurrentHashMap深度剖析"></a>ConcurrentHashMap深度剖析</h1><p>我在上一次面试被问到了为甚么ConcurrentHashMap可以实现线程安全，这里我没有答出来，在这里我打算好好带大家一起了解ConcurrentHashMap顺便让我复习一下。</p><h2 id="ConcurrentHashMap为什么可以实现线程安全"><a href="#ConcurrentHashMap为什么可以实现线程安全" class="headerlink" title="ConcurrentHashMap为什么可以实现线程安全"></a>ConcurrentHashMap为什么可以实现线程安全</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p><strong>数据结构</strong></p><img src="/2022/02/26/Java%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220226232104869.png" class><p>在1.7的时候ConcurrentHashMap由<code>segment</code>数组和<code>HashEntry</code>数组组成，ConcurrentHashMap把哈希桶分为segment小数组，每个小数组有n个HashEntry组成。segment继承RenntrantLock即可重入锁，hashEntry存储键值对。</p><p><strong>结果</strong></p><p>首先将数据分为一段一段存储，然后给每一段都配一把可重入锁，当一个线程占用锁访问其中一个段数据时，其他数据也能访问，真正能实现并发。</p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p><strong>数据结构</strong></p><img src="/2022/02/26/Java%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220226232838666.png" class><p>1.8采用了数组 + 链表 + 红黑树结构。在锁实现上抛弃了segmnet分段式锁，而是采用<code>CAS + synchronized</code>实现更加低粒度的锁。</p><p>锁的级别控制在了hash桶元素级别，也就是说只需要锁住链表头节点，即红黑树根节点，就不会影响其他哈希桶元素读写，大大提高并发度。</p><h2 id="ConcurrentHashMap-put方法"><a href="#ConcurrentHashMap-put方法" class="headerlink" title="ConcurrentHashMap put方法"></a>ConcurrentHashMap put方法</h2><h3 id="JDK1-7-1"><a href="#JDK1-7-1" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>首先尝试获取锁，如果没有获取到就进行自旋，如果自旋超过64次，改为阻塞获取锁。</p><p>获取到以后：</p><ol><li>将segment中的table通过key定位到HashEntry</li><li>遍历HashEntry，如果不为空就判断传入的key与当前遍历key是否相等，相等就覆盖</li><li>不为空就新建一个HashEntry并加入到segment，同时判断是否需要扩容</li><li>释放锁</li></ol><h3 id="JDK1-8-1"><a href="#JDK1-8-1" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><ol><li>根据key计算hash值</li><li>判断是否需要初始化</li><li>定位到node，拿到首节点f,</li></ol><ul><li>如果为null就使用cas进行添加</li><li>如果f.hash &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1,说明其他线程正在扩容，则参与一起扩容</li><li>都不满足就用synchronized锁住f，判断是链表还是红黑树，直接插入</li></ul><p>具体可以看这里<a href="https://mp.weixin.qq.com/s?__biz=MzkyMTI3Mjc2MQ==&mid=2247485909&idx=1&sn=d9c672eebb090866a72f99f3d8032e76&source=41#wechat_redirect">面试 ConcurrentHashMap ，看这一篇就够了！ (qq.com)</a></p><h2 id="ConcurrentHashMap-get方法是否需要加锁，为什么"><a href="#ConcurrentHashMap-get方法是否需要加锁，为什么" class="headerlink" title="ConcurrentHashMap get方法是否需要加锁，为什么"></a>ConcurrentHashMap get方法是否需要加锁，为什么</h2><p>不需要，因为Node元素的val和指针next是volatile修饰的，在多线程环境下线程A修改val或增加节点对线程B可见</p><img src="/2022/02/26/Java%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220226234644053.png" class><h2 id="ConcurrentHashMap不支持key或者value为null的原因"><a href="#ConcurrentHashMap不支持key或者value为null的原因" class="headerlink" title="ConcurrentHashMap不支持key或者value为null的原因"></a>ConcurrentHashMap不支持key或者value为null的原因</h2><h3 id="value不能为null原因"><a href="#value不能为null原因" class="headerlink" title="value不能为null原因"></a>value不能为null原因</h3><p>因为ConcurrentHashMap用于多线程，如果map.get(key)得到null，无法判断是得到的value为null还是没有找到key为null，而单线程hashmap可以使用containsKey方法去判断。</p><p>这样当在第一次执行时没有key，第二次有key但值为null，这样就具有二义性</p><h3 id="key不能为null"><a href="#key不能为null" class="headerlink" title="key不能为null"></a>key不能为null</h3><p>首先null不好计算哈希值，然后当多个线程同时放入null会出问题，</p><h2 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h2><h3 id="JDK1-7-2"><a href="#JDK1-7-2" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>并发度默认16，可以自己设置，默认是2的n次方，如果设置17，则真实为32.</p><h2 id="ConcurrentHashMap迭代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap迭代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap迭代器是强一致性还是弱一致性？"></a>ConcurrentHashMap迭代器是强一致性还是弱一致性？</h2><p>与hashmap不同，ConcurrentHashMap迭代器是弱一致性</p><p>ConcurrentHashMap迭代器创建以后，就会按哈希表结构遍历，但是在遍历的时候，内部元素可能会发生变化，如果变化发生在已经变化的部分，迭代器不会反映出来，如果发生在未遍历的部分，迭代器就会发现并反映出来。</p>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java集合</tag>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap深度剖析</title>
    <link href="/2022/02/25/Java%E9%9B%86%E5%90%88/HashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/"/>
    <url>/2022/02/25/Java%E9%9B%86%E5%90%88/HashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap深度剖析"><a href="#HashMap深度剖析" class="headerlink" title="HashMap深度剖析"></a>HashMap深度剖析</h1><p>最近开学了，在忙着准备考试和复习，所以有几天没有更新，今天我回来了！</p><p>今天带大家来学习一下HashMap的底层原理，顺便复习一下。</p><h2 id="Java集合继承"><a href="#Java集合继承" class="headerlink" title="Java集合继承"></a>Java集合继承</h2><p><img src="https://img.jbzj.com/file_images/article/201711/2017110209260219.gif" alt="2017110209260219.gif"></p><p>（图片来源于网络）</p><p>由上图可以看出List Set Queue三者都实现自Collection而Map则单独实现于Map.</p><p>List有序，这里是指插入顺序有序，可以插入重复内容和null。Set无序，里面内容各不相同，只能存在一个null，而HashMap是一种键值对，只能存在一个键为nulld键值对。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HashMap 维护了一个Entry数组，数组里存储的是键值对。</p><p>在JDK1.7中，由 数组+链表 组成，链表能解决hash冲突，这里使用头插法，会导致链表死循环。</p><p>在JDK1.8中，由 数组+链表+红黑树组成。</p><h3 id="Hash默认加载因子"><a href="#Hash默认加载因子" class="headerlink" title="Hash默认加载因子"></a>Hash默认加载因子</h3><img src="/2022/02/25/Java%E9%9B%86%E5%90%88/HashMap%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/image-20220225234015202.png" class><p>通过源码可以看出是0.75，</p><p>Node table的初始化长度为16，也就是说当超过12时会进行扩容，0.75是一个权衡后的值。较高时会降低空间开销，但会增加查找成本，反之则会浪费空间。</p><p>首先使用Hash算法计算它的hashcode,计算出来以后进行取模操作.</p><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为put方法源码</p><p>可以看到它第一步是看数组是否为空，如果为空就进行初始化</p><p>然后看是否会有冲突，如果没有就直接放入</p><p>如果冲突了且key已存在就直接覆盖这个值</p><p>如果冲突后是个数那就直接挂在树上</p><p>如果是个链表那就判断链表长度是否大于8且数组小于64，如果这样就进行扩容，如果链表长度大于8且数组大于64那就转化为红黑树，否则直接链表上用尾插法挂上</p><h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>在1.7就是使用一个容量更大的数组代替原来的数组，用transfer()方法将原有内容放在新的内容里</p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>进行了两处优化</p><h4 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h4><p>在计算位置的时候不用再计算hash，而是看原来的hash新增的bit是1还是0就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                            loTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-literal">null</span>;<br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br></code></pre></td></tr></table></figure><p>上面是resize方法的部分过程</p><p>hashmap长度为2的n次方，再长度变为二倍的时候，进制上就多一位，此时就是多了一个高参位参与数组下标确定。此时一个元素通过hash算法计算后恰好出现一个现象，最高位是0坐标不变，1则变为原长度+原坐标。</p><p>例如原位置为5，二进制0101，数组长度16</p><p>现在扩容为32，5和32-1进行&amp;运算后为10101，第一位变为1，所以新位置是5+16.</p><h4 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h4><p>采用尾插法</p><p>不会死循环</p><p>多线程put丢失，get put并发会get为null</p><h2 id="长度为2的n次方"><a href="#长度为2的n次方" class="headerlink" title="长度为2的n次方"></a>长度为2的n次方</h2><p>计算速度快</p><p>上面resize代码可以看到，计算hash值的时候进行的是&amp;操作，这个操作速度快于%</p>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java集合</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下Django离线部署</title>
    <link href="/2022/02/24/Django/Linux%E4%B8%8BDjango%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/02/24/Django/Linux%E4%B8%8BDjango%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux下Django离线部署"><a href="#Linux下Django离线部署" class="headerlink" title="Linux下Django离线部署"></a>Linux下Django离线部署</h1><p>在这里介绍一下Linux下Django离线部署的过程，大概分为以下三步</p><ol><li>首先就是python manage.py runserver</li><li>第二步就是 使用uwsgi进行代理</li><li>nginx反向代理，这一步可以降低服务器对于静态资源的应对能力，实现动静分离，增加效率。</li></ol><p>1.首先关闭防火墙</p><p><strong>systemctl disable firewalld</strong></p><p>chkconfig iptables off</p><p>2.关闭selinux</p><p>vi &#x2F;etc&#x2F;selinux&#x2F;config</p><img src="/2022/02/24/Django/Linux%E4%B8%8BDjango%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2/image-20220113142902248.png" class><p>3.ping <a href="http://www.baidu.com/">www.baidu.com</a></p><p>4.用yum安装包</p><p>yum -y install wget vim</p><p>wget <a href="https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tgz">https://www.python.org/ftp/python/3.7.6/Python-3.7.6.tgz</a></p><p>安装opt下</p><p>安装python依赖</p><p>yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</p><figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> libffi-devel<br></code></pre></td></tr></table></figure><p>解压python</p><p>tar -xzvf Python-3.7.6.tgz -C &#x2F;usr&#x2F;local&#x2F;src&#x2F;</p><p>cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;</p><p>cd Python-3.7.6&#x2F;</p><p>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3</p><p>make &amp;&amp; make install</p><p>添加环境变量</p><p>cd &#x2F;etc&#x2F;profile.d&#x2F;</p><p>vi python3.sh</p><p>添加export PATH&#x3D;”$PATH:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin”</p><p>重载环境变量 source ..&#x2F;profile</p><p>echo $PATH</p><p>############33</p><p>实际部署</p><p>cd &#x2F;opt</p><p>mkdir wxapp</p><p>cd wxapp</p><p>mkdir script</p><p>上传项目至wxapp</p><p>pip3 install –upgrade pip</p><p>pip freeze &gt;requirements.txt</p><p>pip3 download -d packages -r requirements.txt</p><p>修改ALLOW_HOST</p><p>pip3 install uwsgi</p><p>这一步一定是再在wweixinapp目录下</p><p>uwsgi –http 0.0.0.0:8000 –file weixinapp&#x2F;wsgi.py –static-map&#x3D;&#x2F;static&#x3D;static</p><p>cd ..&#x2F;script</p><p>vim uwsgi.ini</p><div class="code-wrapper"><pre><code class="hljs">[uwsgi]# 项目目录http=0.0.0.0:8000chdir=/opt/wxapp/weixinapp/# 启动uwsgi的用户名和用户组uid=rootgid=root# 指定项目的applicationmodule=weixinapp.wsgi:application# 指定sock的文件路径socket=/opt/wxapp/script/uwsgi.sock# 启用主进程master=true# 进程个数workers=5pidfile=/opt/wxapp/script/uwsgi.pid# 自动移除unix Socket和pid文件当服务停止的时候vacuum=true# 序列化接受的内容，如果可能的话thunder-lock=true# 启用线程enable-threads=true# 设置自中断时间harakiri=30# 设置缓冲post-buffering=4096# 设置日志目录daemonize=/opt/wxapp/script/uwsgi.log</code></pre></div><p>uwsgi –ini uwsgi.ini  # 启动uwsgi</p><p>uwsgi –stop uwsgi.pid</p><p>ps -ef | grep -i uwsgi</p><p>添加nginx配置文件</p><p>cd &#x2F;www&#x2F;server&#x2F;nginx&#x2F;conf&#x2F;</p><p>vim weixinapp.conf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini">server &#123;<br>                    listen 8000<span class="hljs-comment">;</span><br>                    server_name 121.4.192.22 <span class="hljs-comment">;</span><br>                    charset  utf-8<span class="hljs-comment">;</span><br>                    <span class="hljs-comment"># 指定项目路径uwsgi</span><br>                    location / &#123;<br>                        include uwsgi_params<span class="hljs-comment">;</span><br>                        uwsgi_connect_timeout 30<span class="hljs-comment">;</span><br>                        uwsgi_pass unix:/opt/wxapp/script/uwsgi.sock<span class="hljs-comment">;</span><br>                    &#125;<br>                    <span class="hljs-comment"># 指定静态文件路径</span><br>                    location /static/ &#123;<br>                        alias  /opt/wxapp/weixinapp/static/<span class="hljs-comment">;</span><br>                        index  index.html index.htm<span class="hljs-comment">;</span><br>                    &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;init.d&#x2F;nginx start</p><p>&#x2F;etc&#x2F;init.d&#x2F;nginx stop</p>]]></content>
    
    
    <categories>
      
      <category>Django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络攻击行为鉴赏</title>
    <link href="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/"/>
    <url>/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="网络攻击行为鉴赏"><a href="#网络攻击行为鉴赏" class="headerlink" title="网络攻击行为鉴赏"></a>网络攻击行为鉴赏</h1><p>我大概在半年前就在B站上看到了一个有关于网络安全的科普视频，当时还没有学习计算机网络，看的一知半解。当我学习的过程中又看了一遍，非常有趣。这个视频我已经看了不下五遍，但每一次观看都有新的收获，所以打算写一篇文章来记录一下。</p><p>视频<a href="https://www.bilibili.com/video/BV1KQ4y117nq">链接</a>在这里，希望大家一健三连！</p><h2 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217140001471.png" class><p>在最开始我先来介绍Dos(Denial of Service)攻击，即拒绝服务。就是占用网络资源让服务器应接不暇，从而拒绝正常业务流量的一种攻击方式。</p><h2 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217140230372.png" class><p>DDoS(Distributed denial of service), 分布式拒绝服务。即”群殴”。成千上万设备同时向服务器发送请求。</p><p>在详细讲解各类网络攻击方法之前我们先来看一看网络是如何运行的。</p><h2 id="网络原理"><a href="#网络原理" class="headerlink" title="网络原理"></a>网络原理</h2><h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><p>一次网络访问过程简化如下：</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217140559093.png" class><p>客户端通过网络线路向服务器发送请求，服务器查询或计算后向服务器返回结果。这类数据流转的行为和传统邮递十分相似。</p><h3 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h3><p>邮递依靠邮政系统，互联网则依靠TCP&#x2F;IP协议通信系统。</p><p>可简化为以下四层结构</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217141028712.png" class><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>在我们写信时常会遵循一些格式，如开始要写对方称呼、以及最后的署名和日期等。HTTP协议则做到了这一点，关于HTTP更多具体内容可查看<a href="https://andersonlee09.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/">这里</a>。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217141151773.png" class><p>在写完内容后我们可以给信加一个加急等标记，对方会根据标记决定如何回复，要不要加急或者确认对方身份等。传输层则完成了这个功能，规定了数据传输方式，比如这一层我们常见的TCP协议，为保证通信可靠性要先进性三次握手才会进行数据传输，过程可查看<a href="https://andersonlee09.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">这里</a>,我们的网络攻击方式很多也是根据TCP协议来进行。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217142223881.png" class><p>装新建的信封则类似于网络层，规定了通信双方地址的编码规则，这一层采用IP协议，所以我们常会听到“设备IP地址”。</p><h4 id="子网层"><a href="#子网层" class="headerlink" title="子网层"></a>子网层</h4><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217142406073.png" class><p>一封信的投递主要依靠的是邮局，邮局收到信之后根据地址将信件送到目的地，这就对应子网层，将数字信号转化为物理信号，比如卫星、以太网等。</p><p>数据根据不同协议进行不同打包，到达目的地之后又进行分层拆包最终被目标接收。</p><p>下面根据这些协议来欣赏不同的攻击技术。</p><h2 id="ICMP洪水"><a href="#ICMP洪水" class="headerlink" title="ICMP洪水"></a>ICMP洪水</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217142900737.png" class><p>向一台服务器不断发送IP协议数据包，就可以消耗对方网络带宽，从而达到攻击的目的。</p><p>例如我们常见的ping命令就可以发送ICMP协议包，这种攻击方式交ICMP洪水。这种攻击类似于我们不断给某个人投递信件，写什么不重要，重要的是让信件多的邮递员在对方门口排起长队，从而打断正常的信件收发，同样思路，我们可以发送传输层UDP协议包，发起UDP洪水，但这样会暴露攻击者IP地址，而被对方禁封。所以攻击者可以伪造一个虚假或者不存在的IP从而隐藏自己。</p><h2 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217143923150.png" class><p>既然可以伪造IP，那我们就将发件地址改为要攻击的目标的地址，收件地址为互联网第三方机器，这样回复的信件就会指向攻击目标，第三方机器成为“反射器”。</p><p>这就类似于把别人电话号码放在往上，然后机主被不明真相的推销员呼死。这样就很难查到幕后黑手。</p><h2 id="放大攻击"><a href="#放大攻击" class="headerlink" title="放大攻击"></a>放大攻击</h2><p>这更像是反射攻击的进化版。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217144258721.png" class><p>比如我们常见的DNS服务器，这是一种解析IP地址的服务器，比如我们向浏览器输入<a href="http://www.bilibili.com/">www.bilibili.com</a> , 浏览器会先向DNS服务器发送请求，将B站的IP发送给客户端，然后客户端会根据IP来访问B站服务器。在这里DNS服务器返回的数据远远大于请求数据，一般60个字节请求数据可返回3000字节返回数据，带宽放大因子(BAF)为50,即可产生50倍的放大效果。</p><p>这样攻击者就可以向DNS服务器发起请求，同时将自己IP伪造为被攻击者IP，这样就可以产生50倍的放大效果，可谓四两拨二十斤。</p><h2 id="TCP洪水"><a href="#TCP洪水" class="headerlink" title="TCP洪水"></a>TCP洪水</h2><p>除了占用被攻击者带宽，我们还有很多方式可以达到目的。比如攻击服务器连接资源</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217145113861.png" class><p>我们知道TCP三次握手后会与客户端建立连接，此时服务器会有一个连接表来记录正在连接的连接，而连接表大小有限，我们可以让攻击设备发起大量TCP连接，占满TCP连接表，让其不能完成后面的连接请求从而达到DDoS效果。但因为三次握手的存在，该攻击方式不能伪造IP。</p><h2 id="SYN洪水"><a href="#SYN洪水" class="headerlink" title="SYN洪水"></a>SYN洪水</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217145721104.png" class><p>看过三次握手的都知道，握手第一步是客户端向服务器发送SYN&#x3D;1的数据包，根据此，我们可以向服务器只发送SYN而不进行回答，由于TCP的重传机制，服务器会多次重传SYN+ACK直到超时，大约十次。此时请注意，攻击者要尽量伪造自己的IP，否则就会达到“杀敌一千，自损一万”的效果。如果IP不存在，受害者会拔剑四顾心茫然，如果存在，那就把祸水东引到了某个倒霉蛋身上。</p><h2 id="RST洪水攻击"><a href="#RST洪水攻击" class="headerlink" title="RST洪水攻击"></a>RST洪水攻击</h2><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217150426577.png" class><p>在TCP存在<a href="https://andersonlee09.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a>的过程结束连接，但为了防止出现异常，一方可以发送RST数据强制切断连接，这样我们就可以让攻击者尝试伪造各种IP地址，并发送RST数据进行“盲打”，一旦IP和某些配置和正常用户达成匹配，那就会切断正常用户和服务器之间的连接。</p><h2 id="HTTP洪水攻击"><a href="#HTTP洪水攻击" class="headerlink" title="HTTP洪水攻击"></a>HTTP洪水攻击</h2><p>每一次访问都是客户端通过网络线路向服务器发送请求，服务器查询或计算后向服务器返回结果。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217151106457.png" class><p>比如我们可以利用站点的搜索功能，不断生成大量关键词送入查询地址，服务器收到请求后会在数据库进行查询这样的IO操作，这样的攻击手法会对目标产生更大的消耗。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217151331507.png" class><p>但是该方法有个问题，那就是不能伪造IP，因为HTTP基于TCP协议，存在三次握手的过程，所以我们可以借助网络代理方式发起攻击</p><h2 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h2><p>看完上述攻击方法我们可以看出来，攻击方法大都需要伪造自己的IP地址</p><h3 id="网络设备过滤"><a href="#网络设备过滤" class="headerlink" title="网络设备过滤"></a>网络设备过滤</h3><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217155551573.png" class><p>解决伪造IP的方法并不复杂，用户设备通过路由器接入服务商，那就可以让路由设备检测IP，把原地址IP不属于本路由所在网段的数据都过滤掉</p><h3 id="分布式过滤"><a href="#分布式过滤" class="headerlink" title="分布式过滤"></a>分布式过滤</h3><p>一个设备IP可以造假，但是它经过的真实路径可不能造假。所以如果路由能根据其IP路径检测出矛盾，那就过滤这样的流量，该方法涉及网络设备提供商，服务商和监管部门等，所以很难被达成</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217155859088.png" class><h3 id="CDN技术"><a href="#CDN技术" class="headerlink" title="CDN技术"></a>CDN技术</h3><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217160244662.png" class><p>把一些静态资源作为缓存分发给各个CDN节点，用户请求的时候从最近的节点返回，就能缓解DDoS.</p><h3 id="流量清洗"><a href="#流量清洗" class="headerlink" title="流量清洗"></a>流量清洗</h3><p>我们在服务器前架设一套流量清洗设备，比如SYN洪水攻击，客户端发送SYN数据包，由清洗设备发送SYN+ACK回复</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217160648350.png" class><p>如果应答，那对方就是正常流量，清洗设备就把本次连接交给服务器正常通信。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217160708021.png" class><p>如果不应答那就断开连接。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217160744466.png" class><p>达到以上效果</p><p>又比如在面对HTTP洪水的时候，通过IP很难检测，那就把请求交给流量清洗平台，该平台会有一个IP信用库，对于一些臭名昭著的IP会直接过滤。</p><img src="/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E8%A1%8C%E4%B8%BA%E9%89%B4%E8%B5%8F/image-20220217160858625.png" class><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DDoS作为一种历史悠久的攻击技术，今日还不能被彻底解决，所以希望大家保持警惕，做好防护！</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层详解</title>
    <link href="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层详解"><a href="#应用层详解" class="headerlink" title="应用层详解"></a>应用层详解</h1><p>应用层主要协议为HTTP、HTTPS、FTP等协议，本文主要讲解HTTP协议内容</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220216160216081.png" class><h3 id="301和302区别"><a href="#301和302区别" class="headerlink" title="301和302区别"></a>301和302区别</h3><ul><li>共同点</li></ul><p>301和302都是重定向，即浏览器拿到这个返回值会重新进入一个URL，这个地址可以从响应location中获取。</p><ul><li>不同点</li></ul><p>301表示永久性重定向（该资源已经不可访问），搜索引擎在抓取新内容同时也将旧网址交换为重定向后网址。</p><p>302表示临时重定向(该资源仍然可以访问)，该重定向是临时从A转向B，搜索引擎会抓取新内容而保存旧的网址</p><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>GET\POST\PUT\DELETE\HEAD</p><h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><ul><li>GET使用URL 或COOKIE，而POST将数据放于body，所以post较为安全</li><li>GET参数有长度限制</li><li>本质区别：GET是幂等的，POST不是</li></ul><p>幂等是指一次和多次请求某一资源应该具有同样的副作用，即同一URL多个请求应有同一结果</p><h2 id="HTTP长连接和短连接"><a href="#HTTP长连接和短连接" class="headerlink" title="HTTP长连接和短连接"></a>HTTP长连接和短连接</h2><p>在HTTP&#x2F;1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs c">Connection:keep-alive<br></code></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h2 id="HTTP求请求报文格式"><a href="#HTTP求请求报文格式" class="headerlink" title="HTTP求请求报文格式"></a>HTTP求请求报文格式</h2><ol><li>请求行</li></ol><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。</p><p>比如 GET &#x2F;data&#x2F;info.html HTTP&#x2F;1.1</p><ol start="2"><li>请求头</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>： 浏览器可接受的MIME类型。<br><span class="hljs-attribute">Accept</span>-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少<span class="hljs-number">5</span>到<span class="hljs-number">10</span>倍的下载时间。<br><span class="hljs-attribute">Accept</span>-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。<br><span class="hljs-attribute">Host</span>： 客户机通过这个头告诉服务器，想访问的主机名。HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>请求必须包含主机头域，否则系统会以<span class="hljs-number">400</span>状态码返回。<br><span class="hljs-attribute">User</span>-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。<br><span class="hljs-attribute">Cookie</span>：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。<br><span class="hljs-attribute">Connection</span>：处理完这次请求后是否断开连接还是继续保持连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP <span class="hljs-number">1</span>.<span class="hljs-number">1</span>(HTTP <span class="hljs-number">1</span>.<span class="hljs-number">1</span>默认进行持久连接)，它就可以利用持久连接的优点，<br></code></pre></td></tr></table></figure><ol start="3"><li>请求体</li></ol><p>username&#x3D;xx&amp;pwd&#x3D;xx</p><h2 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie&amp;Session"></a>Cookie&amp;Session</h2><p><strong>1存储位置不同</strong></p><p>cookie的数据信息存放造客户端浏览器上</p><p>session的数据信息存放在服务器上</p><p><strong>2存储容量不同</strong></p><p>单个cookie保存的数据&lt;&#x3D;4kb,一个站点最多保存20个cookie</p><p>对于session来说并没有上限,但是出于对服务端的性能的考虑,session内不要存放过多的东西,</p><p>并且设置session删除机制</p><p><strong>3存储方式不同</strong></p><p>cookie中只能保管ASCII字符串,并需要通过编码方式存储为Unicode字符串或者二进制数据</p><p>session中能够存储任何类型的数据 包括但不限于string,integer,list,map等</p><p><strong>4隐私策略不同</strong></p><p>cookie对客户端是可见的,别有用心的人可以分析存放在本地的cookie并进行cookie欺骗,所以它是不安全的</p><p>session存储在服务器上,对客户端是透明的,不存在敏感信息泄露的风险</p><p><strong>5有效期上不同</strong></p><p>开发者可以通过设置cookie的属性,达到使cookie长期有效的效果</p><p>session依赖于名为JSESSIONID的cookie,而cookie JSESSIONID的过期时间默认为-1,只需要关闭窗口该session就会失效,因而session不能达到长期有戏的效果</p><p><strong>6服务器压力不同</strong></p><p>cookie保管在客户端,不占用服务器的资源,对于并发用户十分多的网站,cookie是很好的选择</p><p>session是保管在服务端的,每个用户都会产生一个session,假如并发访问的用户十分多,会产生十分多的session,耗费大量的内存</p><p><strong>7浏览器支持不同</strong></p><p>假如客户端浏览器不支持cookie</p><p>cookie是需要客户端浏览器支持的,假如客户端禁用了cookie,或者不支持cookie,则会话跟踪会失效,关于wap上的应用,常规的cookie就派不上用场了</p><p>运用session需要使用url地址重写的方式,一切用到session程序的url都要进行url地址重写,</p><p>否则session会话跟踪还会失效</p><p>假如客户端浏览器支持cookie</p><p>cookie既能够设为本浏览器窗口以及子窗口内有效,也能够设为一切窗口内有效</p><p>session只能在本窗口以及子窗口内有效</p><p><strong>8跨域支持上不同</strong></p><p>cookie支持跨域名访问</p><p>session不支持跨域名访问</p><h2 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP&amp;HTTPS"></a>HTTP&amp;HTTPS</h2><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220217133459104.png" class>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运输层详解</title>
    <link href="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="运输层详解"><a href="#运输层详解" class="headerlink" title="运输层详解"></a>运输层详解</h1><p>经历过面试的小伙伴应该明白：计算机网络是面试的重点，而TCP和UDP所在的运输层则是重中之重，下面我将讲解运输层功能，大概包括以下几点：运输层功能、TCP与UDP区别、流量控制、拥塞避免、三次握手、四次挥手</p><h2 id="运输层功能"><a href="#运输层功能" class="headerlink" title="运输层功能"></a>运输层功能</h2><p>直接为应用进程间逻辑通信提供服务</p><h2 id="应用层功能"><a href="#应用层功能" class="headerlink" title="应用层功能"></a>应用层功能</h2><p>为应用程序提供交互服务</p><h2 id="TCP标志位功能"><a href="#TCP标志位功能" class="headerlink" title="TCP标志位功能"></a>TCP标志位功能</h2><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20211112214123356.png" class><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><p>三次握手过程如下：</p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20211112215032515.png" class><p>一、客户端向服务器发送一个请求SYN&#x3D;1 同时发送自己序列号seq&#x3D;X ,</p><p>二、服务器回复一个确认报文 ACK&#x3D;1， 确认号为ACKnum &#x3D; X+1 为期望收到对方下一个报文段的数据第一个字节的序号，同时发送SYN&#x3D;1 表示这是一个连接接受的报文， 同时附带自己的序列号seq&#x3D;1.</p><p>三、客户端发送确认报文ACK&#x3D;1 ACKnum&#x3D;Y+1</p><h3 id="为什么是三次而不是两次"><a href="#为什么是三次而不是两次" class="headerlink" title="为什么是三次而不是两次"></a>为什么是三次而不是两次</h3><p>假如现在是两次握手就可以建立连接，客户端向服务器发送请求，然后服务器向客户端回复请求，连接立刻建立。</p><ul><li>防止已经失效的请求再次被建立连接</li></ul><p>假设当客户端向服务器发送连接1后，该连接因为路由中转的原因迟迟不能到达，客户端又向客户端发送了第二次连接请求2，且会话快速结束。此时请求连接1才姗姗来迟并再次与服务器发送连接，但是现在客户端已经关闭，服务端便会不停发送从而浪费资源</p><ul><li>不能确认双方接收和发送能力都良好</li></ul><p>第一次握手：客户端什么也不知道，服务器知道自己可以接收，对方可以发送</p><p>第二次握手：客户端知道自己可以发送和接收，对方可以接收和发送、服务端什么也不知道</p><p>第三次握手：服务器知道自己发送，对方可以接收</p><p>由此可见少了第三步，服务器不知道完整信息</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="挥手过程"><a href="#挥手过程" class="headerlink" title="挥手过程"></a>挥手过程</h3><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220216150617179.png" class><p>第一次握手：</p><ol><li>客户端连接释放报文，并且停止发送数据。其中FIN&#x3D;1，顺序号为seq&#x3D;m，此时，客户端Client进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li></ol><p>第二次握手：</p><ol start="2"><li><p>服务器Server收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;m+1，并且带上自己的顺序号seq&#x3D;n，此时，服务器Server就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端Client向服务器的方向就释放了，这时候处于半关闭状态，即客户端Client已经没有数据要发送了，但是服务器Server若发送数据，客户端Client依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p></li><li><p>客户端Client收到服务器Server的确认信息后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器Server发送连接释放报文（在这之前还需要接受服务器Server发送的最后的数据）。</p></li></ol><p>第三次握手：</p><ol start="4"><li>服务器Server将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;m+1，由于在半关闭状态，服务器Server很可能又发送了一些数据，假定此时的顺序号为seq&#x3D;p，此时，服务器Server就进入了LAST-ACK（最后确认）状态，等待客户端Client的确认。</li></ol><p>第四次握手：</p><ol start="5"><li>客户端Client收到服务器Server的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;p+1，而自己的顺序号是seq&#x3D;m+1，此时，客户端Client就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端Client撤销相应的TCB（保护程序）后，才进入CLOSED状态。</strong></li><li>服务器Server只要收到了客户端Client发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器Server结束TCP连接的时间要比客户端Client早一些。</li></ol><h3 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h3><p>按照前面所说，当四个报文全部发送完毕后，理论上就算是结束了。但是实际情况往往不会那么可靠，比如最后一条报文发出后丢失了，那么服务器端就不会接收到这一报文，每隔一段时间，服务器端会再次发出FIN报文，此时如果客户端已经断开了，那么就无法响应服务器的二次请求，这样服务器会继续发出FIN报文，从而变成了死循环。所以需要设置一个时间段，如果在这个时间段内接收到了服务器端的再次请求，则代表客户端发出的ACK报文没有接收成功。反之，则代表服务器端成功接收响应报文，客户端进入CLOSED状态，此次连接成功关闭。而这个时间，就规定为了2MSL，即客户端发出ACK报文到服务器端的最大时间 + 服务器没有接收到ACK报文再次发出FIN的最大时间 &#x3D; 2MSL</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>发送方维持一个拥塞窗口cwnd，取决于其网络拥塞程度，动态变化</p><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220216152258882.png" class><ul><li>慢开始</li></ul><p>不用一开始速度就很快，由小到大逐渐增大，且为指数增长1：1-&gt;2-&gt;4-&gt;8…</p><ul><li>拥塞避免</li></ul><p>当cwnd&lt;ssthresh(慢开始门限)，拥塞窗口缓慢增长，每次一个往返就+1, 16-&gt;17-&gt;18… </p><ul><li>快重传</li></ul><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220216153625395.png" class><p>剔除一些不必要的拥塞报文，在收到一个失序的报文段后就<strong>重复</strong>确认，而不是等到自己发送数据时捎带确认。</p><p>发送放只要连续收到三个确认，就应该立刻重传对方未收到的报文段，这样就不必设置重传计时器时间到期</p><ul><li>快恢复</li></ul><p>当快重传发生时，代表发送窗口过大，此时要把ssthresh(慢开始门限)减半，但并不进行慢开始算法，因为已经收到连续三个回复确认表示网络还行~</p><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><img src="/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E8%AF%A6%E8%A7%A3/image-20220216154131025.png" class>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础命令</title>
    <link href="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20210719144052490.png" class><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="创建用户组"><a href="#创建用户组" class="headerlink" title="创建用户组"></a>创建用户组</h4><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20210719144844491.png" class><h4 id="管理组内成员"><a href="#管理组内成员" class="headerlink" title="管理组内成员"></a>管理组内成员</h4><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20210719145010114.png" class><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20210719145324771.png" class><h3 id="日期管理"><a href="#日期管理" class="headerlink" title="日期管理"></a>日期管理</h3><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20210719145405647.png" class><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105131210111.png" class><p>chgrp andersonlee tmp</p><p>给tmp文件修改用户组为andersonlee</p><p>chown 文件所有者和用户组两个一起设置</p><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>提高当前用户权限来执行后面的语句</p><p>ps&amp;top查看进程信息</p><p>kill id 杀死进程</p><p>杀不死则使用  kill -9 id</p><p>shutdown -h now立刻关机</p><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>chmod 777 filename</p><p>chmod修改权限</p><p>user -&gt; u 属主权限</p><p>group -&gt; g 属组权限</p><p>others -&gt; o 其他权限</p><p>all -&gt;a  全部权限</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105133300795.png" class><p>R即为该目录下所有文件</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105133350825.png" class><p><strong>stat</strong> 查看文件属性</p><p>pwd 查看文件路径</p><h3 id="编辑文本"><a href="#编辑文本" class="headerlink" title="编辑文本"></a>编辑文本</h3><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>i -&gt; insert  当前字符插入</p><p>l -&gt; insert  首行插入</p><p>a -&gt; append   当前字符后添加</p><p>A -&gt; append  行末尾添加</p><p>o -&gt;  当前行后插一空行</p><p>O -&gt;  当前行前插入空行</p><p>写完ESC</p><p>:q  vim进入文件没有对文件做任何操作 可以按q</p><p>:q!  有操作但不想退出保存</p><p>:wq  正常退出保存</p><p>:wq!  强制保存退出</p><p>:set nu显示行</p><p>cat +文件名 查看文件内容</p><p>cat -n +文件名 查看文件内容 加行号</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105163119757.png" class><p>less  查看大文件 q退出</p><p>grep 查找内容</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105165025046.png" class><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105165121746.png" class><p>-n  显示行数</p><p>-i  不区分大小写</p><p>-v  不含有的</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105165451279.png" class><p>查看名字里有sshd的进程</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105165820814.png" class><p>定位到具体行数</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>ps</p><p>ps -ef 查看所有进程</p><h3 id="软连接（快捷方式）"><a href="#软连接（快捷方式）" class="headerlink" title="软连接（快捷方式）"></a>软连接（快捷方式）</h3><p>ln -s 原路径  新路径</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>find</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105180928459.png" class><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>gzip *   压缩</p><p>gunzip  filename   解压文件</p><p>zip</p><p>-q : 不显示执行过程   -r : 递归处理 对该目录下的子目录一起处理</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105182234465.png" class><p>unzip -l filename.zip 查看压缩文件内容</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105182338320.png" class><p>unzip -d ccc aaa.zip  解压</p><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><p>ifconfig  查看网络</p><p>ping <a href="http://www.baidu.com/">www.baidu.com</a>  向网址发送包</p><p>ping -c 2 <a href="http://www.baidu.com/">www.baidu.com</a>  只发生两次包</p><p>netstat  显示网络状态  -a 显示所有连线中的socket    -i显示网卡列表</p><h3 id="yum下载软件"><a href="#yum下载软件" class="headerlink" title="yum下载软件"></a>yum下载软件</h3><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105183711457.png" class><p>-y表示遇到选择就选yes</p><p>删除</p><img src="/2022/02/15/Linux/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/image-20211105183819413.png" class>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python自动化解决Hexo图片引用路径问题</title>
    <link href="/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Python自动化解决Hexo图片引用路径问题"><a href="#Python自动化解决Hexo图片引用路径问题" class="headerlink" title="Python自动化解决Hexo图片引用路径问题"></a>Python自动化解决Hexo图片引用路径问题</h1><h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>看过我第二篇Blog的小伙伴应该知道，在typora的图片引用和hexo存在一定差别，具体为：</p><img src="/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20220214124532420.png" class><p>可以看到存在一定差距，我昨天一直将原路径里的图片放至blog项目下同名目录中，然后修改markdown文件里图片名称，虽然操作难度不大，但有时候一篇文章可能存在几十张图片，这样子任务繁多，且容易出错，我们是否可以利用<strong>python自动化</strong>完成这些事情呢？答案是可以的！</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>我大体思路如下：</p><ol><li><p>首先逐行读取md文件，如果发现该行存在根目录：C：User\xxxxxxxxxxxxxx,则该行为图片所在行</p></li><li><p>将图片名称存下来，将该行变换为可识别引用重新写入副本里，将图片从老文件里存入新文件夹（使用PIL库）</p></li><li><p>最后将老md文件放入final_url文件夹中方便以后本地查看，副本文件修改名称即可。</p></li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">r 以只读方式打开文件。文件的指针会放在文件的开头。</span><br><span class="hljs-string"></span><br><span class="hljs-string">w 以写入方式打开文件。文件存在覆盖文件，文件不存在创建一个新文件。</span><br><span class="hljs-string"></span><br><span class="hljs-string">a 以追加方式打开文件。如果文件已存在，文件指针放在文件末尾。如果文件不存在，创建新文件并可写入。</span><br><span class="hljs-string"></span><br><span class="hljs-string">r+ 打开一个文件用于读写。文件指针会放在文件的开头</span><br><span class="hljs-string"></span><br><span class="hljs-string">w+ 打开一个文件用于读写。文件存在覆盖文件，文件不存在创建一个新文件。</span><br><span class="hljs-string"></span><br><span class="hljs-string">a+ 打开一个文件用于读写。如果文件已存在，文件指针放在文件末尾。如果文件不存在，创建新文件并可写入。</span><br><span class="hljs-string"></span><br><span class="hljs-string">记忆方法：记住r读，w写，a追加，每个模式后加入+号就变成可读写</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># typora 自动存储图片所在目录</span><br>old_url = <span class="hljs-string">&#x27;C:\\Users\李瑞航\AppData\Roaming\Typora\\typora-user-images\\&#x27;</span><br><span class="hljs-comment"># blog markdown所在目录</span><br>new_url = <span class="hljs-string">&#x27;D:\\Users\\blog\source\_posts\\&#x27;</span><br><span class="hljs-comment"># 最后想存储原markdown目录</span><br>final_url = <span class="hljs-string">&#x27;D:\\Users\\blog\\markdown\\&#x27;</span><br><span class="hljs-comment"># 文件名称</span><br>filename = <span class="hljs-string">&#x27;linux&#x27;</span><br><br><br><span class="hljs-comment"># 处理文件</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_file</span>(<span class="hljs-params">title</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    process .md or .txt format file</span><br><span class="hljs-string">    :param file: .md or .txt format file</span><br><span class="hljs-string">    :return: null</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 如果还没有这个文件夹就创建这个文件夹</span><br>    <span class="hljs-keyword">if</span> title + <span class="hljs-string">&#x27;.md&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> os.listdir(new_url):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;未找到该markdown文件！&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> title <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> os.listdir(new_url):<br>        os.mkdir(new_url + title)<br>    <span class="hljs-comment"># 创建一个副本记录最新处理好的图片路径</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;new_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>_.md&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;new_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>.md&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>):<br>            <span class="hljs-keyword">if</span> old_url <span class="hljs-keyword">in</span> line:<br>                pic_name = line.split(old_url)[-<span class="hljs-number">1</span>][:-<span class="hljs-number">2</span>]<br>                process_pic(pic_name, title)<br>                f.write(<span class="hljs-string">&#x27;&#123;% asset_img &#x27;</span> + pic_name + <span class="hljs-string">&#x27; %&#125;\n&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                f.write(line)<br>    <span class="hljs-comment"># 移动老的md</span><br>    shutil.move(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;new_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>.md&#x27;</span>, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;final_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>.md&#x27;</span>)<br>    <span class="hljs-comment"># 将新的md命名为老的md</span><br>    os.rename(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;new_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>_.md&#x27;</span>, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;new_url&#125;</span><span class="hljs-subst">&#123;title&#125;</span>.md&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_pic</span>(<span class="hljs-params">pic_name, title</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        remove picture</span><br><span class="hljs-string">        :param pic_name: ome picture name</span><br><span class="hljs-string">        :return: null</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    I = Image.<span class="hljs-built_in">open</span>(old_url + pic_name)<br>    I.save(new_url + title + <span class="hljs-string">&#x27;/&#x27;</span> + pic_name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 接收来自cmd的参数</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;尝试处理 <span class="hljs-subst">&#123;sys.argv[<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br>        process_file(sys.argv[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">except</span> IndexError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;未找到该标题所在目录，已经自适应标题~&#x27;</span>)<br>        <span class="hljs-keyword">if</span> filename == <span class="hljs-string">&#x27;&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件名为空！&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            process_file(filename)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;运行结束&#x27;</span>)<br><br><br></code></pre></td></tr></table></figure><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>本脚本所用python第三方库均为内置库，无需下载。</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>old_url: 即为typora存储图片的路径</p><p>new_url: 即为hexo项目markdown文件所在路径</p><p>final_url: 最后想存储原markdown目录</p><p>title: 想要处理的markdown名称（选填，不填则为空）</p><h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><ul><li>脚本运行（推荐）</li></ul><p>因为项目使用了sys库，所以可以在命令行直接启动，具体为：</p><p>python xx.py filename.md</p><p>xx为该python 文件名称，filename为markdown文件名称, 不用加引号</p><ul><li>直接运行</li></ul><p>直接修改文件里filename即可</p><h2 id="结果欣赏"><a href="#结果欣赏" class="headerlink" title="结果欣赏"></a>结果欣赏</h2><p>处理前：</p><img src="/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20220214115422400.png" class><p>处理中：</p><img src="/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20220214122757715.png" class><p>处理后：</p><img src="/2022/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%A3%E5%86%B3Hexo%E5%9B%BE%E7%89%87%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/image-20220214122837301.png" class><p>成功！！</p>]]></content>
    
    
    <categories>
      
      <category>自动化办公</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Python</tag>
      
      <tag>自动化办公</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客引用图片无法显示</title>
    <link href="/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/"/>
    <url>/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客引用图片无法显示"><a href="#Hexo博客引用图片无法显示" class="headerlink" title="Hexo博客引用图片无法显示"></a>Hexo博客引用图片无法显示</h1><p>今天开始编写博客的时候，发现用Typora编写的文章引用图片编译后总是不能正常显示</p><p>于是开始各种百度，出来的都是下载一个路径转换<code>hexo-asset-image</code>的插件</p><p><code>hexo-asset-image</code>使用说明：</p><p><code>npm install hexo-asset-image --save</code></p><img src="/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/image-20220213174631295.png" class title="This is an example image"><p>可一顿操作过后，还是不能够正常显示；</p><img src="/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/image-20220213174756400.png" class title="This is an example image"><p>然后得到了一份index.js脚本的脚本，替换掉博客目录下node_modules&#x2F;hexo-ass-image&#x2F;index.js，并使用标签插件方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPosition</span>(<span class="hljs-params">str, m, i</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">split</span>(m, i).<span class="hljs-title function_">join</span>(m).<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-title class_">String</span>(hexo.<span class="hljs-property">version</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">filter</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.<span class="hljs-property">config</span>;<br>  <span class="hljs-keyword">if</span>(config.<span class="hljs-property">post_asset_folder</span>)&#123;<br>    <span class="hljs-keyword">var</span> link = data.<span class="hljs-property">permalink</span>;<br><span class="hljs-keyword">if</span>(version.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title class_">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>   <span class="hljs-keyword">var</span> beginPos = <span class="hljs-title function_">getPosition</span>(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">var</span> beginPos = <span class="hljs-title function_">getPosition</span>(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">4</span>) + <span class="hljs-number">1</span>;     <span class="hljs-comment">//markdown的本地路径是xxx/x.jpg    hexo g编译后加上这句就是public/2020/05/26/xxx/xx.jpg 前4个文件+后一个图片~</span><br><span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="hljs-keyword">var</span> endPos = link.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.<span class="hljs-title function_">substring</span>(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.<span class="hljs-property">length</span>; i++)&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.<span class="hljs-title function_">load</span>(data[key], &#123;<br>        <span class="hljs-attr">ignoreWhitespace</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">xmlMode</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">lowerCaseTags</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">decodeEntities</span>: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).<span class="hljs-title function_">each</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">if</span> ($(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br><span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="hljs-keyword">var</span> src = $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.<span class="hljs-title function_">test</span>(src) &amp;&amp;<br>   !<span class="hljs-regexp">/^\s*\//</span>.<span class="hljs-title function_">test</span>(src)) &#123;<br>  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>  <span class="hljs-keyword">var</span> linkArray = link.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> srcArray = src.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">if</span>(srcArray.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>)<br>srcArray.<span class="hljs-title function_">shift</span>();<br>  src = srcArray.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  $(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;src&#x27;</span>, config.<span class="hljs-property">root</span> + link + src);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.<span class="hljs-property">root</span> + link + src);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>&amp;&amp;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>($(<span class="hljs-variable language_">this</span>));<br>&#125;<br>      &#125;);<br>      data[key] = $.<span class="hljs-title function_">html</span>();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后就可以正常显示图片了<br>但是请<strong>注意</strong>：这里图片的引入和项目目录十分重要</p><img src="/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/5fa161ad.png" class title="This is an example image"><p>如上图所示，markdown文件应与其同名文件夹在同一目录下，且引入图片时有特殊规范 <code>asset_img</code>为固定写法， 后面直接跟文件夹下图片名称，最后为图片描述。</p><p><strong>最后引入结果：</strong></p><img src="/2022/02/13/hexo/Hexo%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA/c8eb51ec.png" class title="This is an example image"><p>如上图所示：引入成功！</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 搭建个人博客</title>
    <link href="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-搭建个人博客"><a href="#Hexo-搭建个人博客" class="headerlink" title="Hexo 搭建个人博客"></a>Hexo 搭建个人博客</h1><h2 id="0-说明"><a href="#0-说明" class="headerlink" title="0.说明"></a>0.说明</h2><p>本项目基于Windows10利用Hexo部署个人博客并且投放至GitHub</p><h2 id="1-下载node-js"><a href="#1-下载node-js" class="headerlink" title="1.下载node.js"></a>1.下载node.js</h2><p>顺带下载npm</p><p>直接在官网下载，本文不作说明</p><h2 id="2-查看环境"><a href="#2-查看环境" class="headerlink" title="2.查看环境"></a>2.查看环境</h2><p>node -v</p><p>npm -v</p><p>如果没有异常则下载成功</p><h2 id="3-切换镜像"><a href="#3-切换镜像" class="headerlink" title="3.切换镜像"></a>3.切换镜像</h2><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212123235109.png" class title="This is an example image"><h2 id="4-下载hexo"><a href="#4-下载hexo" class="headerlink" title="4.下载hexo"></a>4.下载hexo</h2><p>cnpm install -g hexo-cli</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212123235109.png" class title="This is an example image"><p>hexo -v查看版本</p><h2 id="5-初始化博客"><a href="#5-初始化博客" class="headerlink" title="5.初始化博客"></a>5.初始化博客</h2><p>hexo init</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212123658729.png" class title="This is an example image"><p>初始化结果：</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212123731036.png" class title="This is an example image"><h2 id="6-启动博客"><a href="#6-启动博客" class="headerlink" title="6.启动博客"></a>6.启动博客</h2><p>hexo s</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212124240300.png" class title="This is an example image"><p>初始化结果</p><h2 id="7-写博客"><a href="#7-写博客" class="headerlink" title="7.写博客"></a>7.写博客</h2><p>hexo n “My first blog”</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212124523578.png" class title="This is an example image"><p>对该目录下markdown进行编辑</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212124815007.png" class title="This is an example image"><p>编辑结束后</p><p>hexo clean</p><p>hexo g</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212125017647.png" class title="This is an example image"><p>hexo s</p><p>结果：</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212125137499.png" class title="This is an example image"><h2 id="8-投放至GitHub"><a href="#8-投放至GitHub" class="headerlink" title="8.投放至GitHub"></a>8.投放至GitHub</h2><h3 id="8-1-创建GitHub项目"><a href="#8-1-创建GitHub项目" class="headerlink" title="8.1 创建GitHub项目"></a>8.1 创建GitHub项目</h3><p>命名必须符合规范：name.github.io</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212130118069.png" class title="This is an example image"><h3 id="8-2下载git帮助"><a href="#8-2下载git帮助" class="headerlink" title="8.2下载git帮助"></a>8.2下载git帮助</h3><p>npm install hexo-deployer-git –save</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212130405182.png" class title="This is an example image"><h3 id="8-3设置-config-yml"><a href="#8-3设置-config-yml" class="headerlink" title="8.3设置_config.yml"></a>8.3设置_config.yml</h3><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212130741480.png" class title="This is an example image"><h3 id="8-4-修改Deployment"><a href="#8-4-修改Deployment" class="headerlink" title="8.4 修改Deployment"></a>8.4 修改Deployment</h3><p>修改前：</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212131006177.png" class title="This is an example image"><p>修改后：</p><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212123235109.png" class title="This is an example image"><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212141732952.png" class title="This is an example image"><p>hexo g -d</p><h3 id="8-4成功部署"><a href="#8-4成功部署" class="headerlink" title="8.4成功部署"></a>8.4成功部署</h3><img src="/2022/02/13/hexo/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/image-20220212141749479.png" class title="This is an example image"><p><strong>至此所有部署已经完成</strong> </p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
